/*!
JW Player version 8.20.0
Copyright (c) 2021, JW Player, All Rights Reserved 
https://github.com/jwplayer/jwplayer/blob/v8.20.0/README.md

This source code and its use and distribution is subject to the terms and conditions of the applicable license agreement. 
https://www.jwplayer.com/tos/

This product includes portions of other software. For the full text of licenses, see below:

JW Player Third Party Software Notices and/or Additional Terms and Conditions

**************************************************************************************************
The following software is used under Apache License 2.0
**************************************************************************************************

vtt.js v0.13.0
Copyright (c) 2021 Mozilla (http://mozilla.org)
https://github.com/mozilla/vtt.js/blob/v0.13.0/LICENSE

* * *

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.

You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and
limitations under the License.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************************************
The following software is used under MIT license
**************************************************************************************************

Underscore.js v1.6.0
Copyright (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative
https://github.com/jashkenas/underscore/blob/1.6.0/LICENSE

Backbone backbone.events.js v1.1.2
Copyright (c) 2010-2014 Jeremy Ashkenas, DocumentCloud
https://github.com/jashkenas/backbone/blob/1.1.2/LICENSE

Promise Polyfill v7.1.1
Copyright (c) 2014 Taylor Hakes and Forbes Lindesay
https://github.com/taylorhakes/promise-polyfill/blob/v7.1.1/LICENSE

can-autoplay.js v3.0.0
Copyright (c) 2017 video-dev
https://github.com/video-dev/can-autoplay/blob/v3.0.0/LICENSE

focus-options-polyfill v1.5.0
Copyright (c) 2018 Juan Valencia
https://github.com/calvellido/focus-options-polyfill/blob/v1.5.0/LICENSE

* * *

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************************************
The following software is used under W3C license
**************************************************************************************************

Intersection Observer v0.5.0
Copyright (c) 2016 Google Inc. (http://google.com)
https://github.com/w3c/IntersectionObserver/blob/v0.5.0/LICENSE.md

* * *

W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE
Status: This license takes effect 13 May, 2015.

This work is being provided by the copyright holders under the following license.

License
By obtaining and/or copying this work, you (the licensee) agree that you have read, understood, and will comply with the following terms and conditions.

Permission to copy, modify, and distribute this work, with or without modification, for any purpose and without fee or royalty is hereby granted, provided that you include the following on ALL copies of the work or portions thereof, including modifications:

The full text of this NOTICE in a location viewable to users of the redistributed or derivative work.

Any pre-existing intellectual property disclaimers, notices, or terms and conditions. If none exist, the W3C Software and Document Short Notice should be included.

Notice of any changes or modifications, through a copyright statement on the new code or document such as "This software or document includes material copied from or derived from [title and URI of the W3C document]. Copyright © [YEAR] W3C® (MIT, ERCIM, Keio, Beihang)."

Disclaimers
THIS WORK IS PROVIDED "AS IS," AND COPYRIGHT HOLDERS MAKE NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE SOFTWARE OR DOCUMENT WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.

COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE SOFTWARE OR DOCUMENT.

The name and trademarks of copyright holders may NOT be used in advertising or publicity pertaining to the work without specific, written prior permission. Title to copyright in this work will at all times remain with copyright holders.
*/
(window["webpackJsonpjwplayer"] = window["webpackJsonpjwplayer"] || []).push([["jwplayer.core"],{

/***/ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/src/index.js!./node_modules/less-loader/dist/cjs.js?!./src/css/jwplayer.less":
/*!******************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--4-1!./node_modules/postcss-loader/src!./node_modules/less-loader/dist/cjs.js??ref--4-3!./src/css/jwplayer.less ***!
  \******************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js")(false);
// Module
exports.push([module.i, ".jw-reset{text-align:left;direction:ltr}.jw-reset-text,.jw-reset{color:inherit;background-color:transparent;padding:0;margin:0;float:none;font-family:Arial,Helvetica,sans-serif;font-size:1em;line-height:1em;list-style:none;text-transform:none;vertical-align:baseline;border:0;font-variant:inherit;font-stretch:inherit;-webkit-tap-highlight-color:rgba(255,255,255,0)}body .jw-error,body .jwplayer.jw-state-error{height:100%;width:100%}.jw-title{position:absolute;top:0}.jw-background-color{background:rgba(0,0,0,0.4)}.jw-text{color:rgba(255,255,255,0.8)}.jw-knob{color:rgba(255,255,255,0.8);background-color:#fff}.jw-button-color{color:rgba(255,255,255,0.8)}:not(.jw-flag-touch) .jw-button-color:not(.jw-logo-button):focus,:not(.jw-flag-touch) .jw-button-color:not(.jw-logo-button):hover{color:#fff}.jw-toggle{color:#fff}.jw-toggle.jw-off{color:rgba(255,255,255,0.8)}.jw-toggle.jw-off:focus{color:#fff}.jw-toggle:focus{outline:none}:not(.jw-flag-touch) .jw-toggle.jw-off:hover{color:#fff}.jw-rail{background:rgba(255,255,255,0.3)}.jw-buffer{background:rgba(255,255,255,0.3)}.jw-progress{background:#f2f2f2}.jw-time-tip,.jw-volume-tip{border:0}.jw-slider-volume.jw-volume-tip.jw-background-color.jw-slider-vertical{background:none}.jw-skip{padding:.5em;outline:none}.jw-skip .jw-skiptext,.jw-skip .jw-skip-icon{color:rgba(255,255,255,0.8)}.jw-skip.jw-skippable:hover .jw-skip-icon,.jw-skip.jw-skippable:focus .jw-skip-icon{color:#fff}.jw-icon-cast google-cast-launcher{--connected-color:#fff;--disconnected-color:rgba(255,255,255,0.8)}.jw-icon-cast google-cast-launcher:focus{outline:none}.jw-icon-cast google-cast-launcher.jw-off{--connected-color:rgba(255,255,255,0.8)}.jw-icon-cast:focus google-cast-launcher{--connected-color:#fff;--disconnected-color:#fff}.jw-icon-cast:hover google-cast-launcher{--connected-color:#fff;--disconnected-color:#fff}.jw-nextup-container{bottom:2.5em;padding:5px .5em}.jw-nextup{border-radius:0}.jw-color-active{color:#fff;stroke:#fff;border-color:#fff}:not(.jw-flag-touch) .jw-color-active-hover:hover,:not(.jw-flag-touch) .jw-color-active-hover:focus{color:#fff;stroke:#fff;border-color:#fff}.jw-color-inactive{color:rgba(255,255,255,0.8);stroke:rgba(255,255,255,0.8);border-color:rgba(255,255,255,0.8)}:not(.jw-flag-touch) .jw-color-inactive-hover:hover{color:rgba(255,255,255,0.8);stroke:rgba(255,255,255,0.8);border-color:rgba(255,255,255,0.8)}.jw-option{color:rgba(255,255,255,0.8)}.jw-option.jw-active-option{color:#fff;background-color:rgba(255,255,255,0.1)}:not(.jw-flag-touch) .jw-option:hover{color:#fff}.jwplayer{width:100%;font-size:16px;position:relative;display:block;min-height:0;overflow:hidden;box-sizing:border-box;font-family:Arial,Helvetica,sans-serif;-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:none}.jwplayer *{box-sizing:inherit}.jwplayer.jw-tab-focus:focus{outline:solid 2px #4d90fe}.jwplayer.jw-flag-aspect-mode{height:auto !important}.jwplayer.jw-flag-aspect-mode .jw-aspect{display:block}.jwplayer .jw-aspect{display:none}.jw-media,.jw-preview{position:absolute;width:100%;height:100%;top:0;left:0;bottom:0;right:0}.jw-media{overflow:hidden;cursor:pointer}.jw-plugin{position:absolute;bottom:66px}.jw-breakpoint-7 .jw-plugin{bottom:132px}.jw-plugin .jw-banner{max-width:100%;opacity:0;cursor:pointer;position:absolute;margin:auto auto 0;left:0;right:0;bottom:0;display:block}.jw-preview,.jw-captions,.jw-title{pointer-events:none}.jw-media,.jw-logo{pointer-events:all}.jw-wrapper{background-color:#000;position:absolute;top:0;left:0;right:0;bottom:0}.jw-hidden-accessibility{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}.jw-contract-trigger::before{content:\"\";overflow:hidden;width:200%;height:200%;display:block;position:absolute;top:0;left:0}.jwplayer .jw-media video{position:absolute;top:0;right:0;bottom:0;left:0;width:100%;height:100%;margin:auto;background:transparent;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-focus-ring-color:rgba(0,0,0,0);outline:none}.jwplayer .jw-media video::-webkit-media-controls-start-playback-button{display:none}.jwplayer.jw-stretch-uniform .jw-media video{object-fit:contain}.jwplayer.jw-stretch-none .jw-media video{object-fit:none}.jwplayer.jw-stretch-fill .jw-media video{object-fit:cover}.jwplayer.jw-stretch-exactfit .jw-media video{object-fit:fill}.jw-preview{position:absolute;display:none;opacity:1;visibility:visible;width:100%;height:100%;background:#000 no-repeat 50% 50%}.jwplayer .jw-preview,.jw-error .jw-preview{background-size:contain}.jw-stretch-none .jw-preview{background-size:auto auto}.jw-stretch-fill .jw-preview{background-size:cover}.jw-stretch-exactfit .jw-preview{background-size:100% 100%}.jw-title{display:none;padding-top:20px;width:100%;z-index:1}.jw-title-primary,.jw-title-secondary{color:#fff;padding-left:20px;padding-right:20px;padding-bottom:.5em;overflow:hidden;text-overflow:ellipsis;direction:unset;white-space:nowrap;width:100%}.jw-title-primary{font-size:1.625em}.jw-breakpoint-2 .jw-title-primary,.jw-breakpoint-3 .jw-title-primary{font-size:1.5em}.jw-flag-small-player .jw-title-primary{font-size:1.25em}.jw-breakpoint-0 .jw-ab-truncated .jw-title-primary,.jw-breakpoint-1 .jw-ab-truncated .jw-title-primary,.jw-breakpoint-2 .jw-ab-truncated .jw-title-primary{display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden;padding-bottom:0;margin-bottom:.5em;white-space:pre-wrap;line-height:1.2}.jw-breakpoint-1 .jw-ab-truncated .jw-title-primary{font-size:1.25em}.jw-breakpoint-0 .jw-ab-truncated .jw-title-primary{font-size:1em}.jw-flag-small-player .jw-title-secondary,.jw-breakpoint-0 .jw-ab-truncated .jw-title-secondary,.jw-breakpoint-1 .jw-ab-truncated .jw-title-secondary,.jw-breakpoint-2 .jw-ab-truncated .jw-title-secondary,.jw-title-secondary:empty{display:none}.jw-captions{position:absolute;width:100%;height:100%;text-align:center;display:none;letter-spacing:normal;word-spacing:normal;text-transform:none;text-indent:0;text-decoration:none;pointer-events:none;overflow:hidden;top:0}.jw-captions.jw-captions-enabled{display:block}.jw-captions-window{display:none;padding:.25em;border-radius:.25em}.jw-captions-window.jw-captions-window-active{display:inline-block}.jw-captions-text{display:inline-block;color:#fff;background-color:#000;word-wrap:normal;word-break:normal;white-space:pre-line;font-style:normal;font-weight:normal;text-align:center;text-decoration:none}.jw-text-track-display{font-size:inherit;line-height:1.5}.jw-text-track-cue{background-color:rgba(0,0,0,0.5);color:#fff;padding:.1em .3em}.jwplayer video::-webkit-media-controls{display:none;justify-content:flex-start}.jwplayer video::-webkit-media-text-track-display{min-width:-webkit-min-content}.jwplayer video::cue{background-color:rgba(0,0,0,0.5)}.jwplayer video::-webkit-media-controls-panel-container{display:none}.jwplayer:not(.jw-flag-controls-hidden):not(.jw-state-playing) .jw-captions,.jwplayer.jw-flag-media-audio.jw-state-playing .jw-captions,.jwplayer.jw-state-playing:not(.jw-flag-user-inactive):not(.jw-flag-controls-hidden) .jw-captions{max-height:calc(100% - 60px)}.jwplayer:not(.jw-flag-controls-hidden):not(.jw-state-playing):not(.jw-flag-ios-fullscreen) video::-webkit-media-text-track-container,.jwplayer.jw-flag-media-audio.jw-state-playing:not(.jw-flag-ios-fullscreen) video::-webkit-media-text-track-container,.jwplayer.jw-state-playing:not(.jw-flag-user-inactive):not(.jw-flag-controls-hidden):not(.jw-flag-ios-fullscreen) video::-webkit-media-text-track-container{max-height:calc(100% - 60px)}.jw-logo{position:absolute;margin:20px;cursor:pointer;pointer-events:all;background-repeat:no-repeat;background-size:contain;top:auto;right:auto;left:auto;bottom:auto;outline:none}.jw-logo.jw-tab-focus:focus{outline:solid 2px #4d90fe}.jw-flag-audio-player .jw-logo{display:none}.jw-logo-top-right{top:0;right:0}.jw-logo-top-left{top:0;left:0}.jw-logo-bottom-left{left:0}.jw-logo-bottom-right{right:0}.jw-logo-bottom-left,.jw-logo-bottom-right{bottom:44px;transition:bottom 150ms cubic-bezier(0, .25, .25, 1)}.jw-state-idle .jw-logo{z-index:1}.jw-state-setup .jw-wrapper{background-color:inherit}.jw-state-setup .jw-logo,.jw-state-setup .jw-controls,.jw-state-setup .jw-controls-backdrop{visibility:hidden}span.jw-break{display:block}body .jw-error,body .jwplayer.jw-state-error{background-color:#333;color:#fff;font-size:16px;display:table;opacity:1;position:relative}body .jw-error .jw-display,body .jwplayer.jw-state-error .jw-display{display:none}body .jw-error .jw-media,body .jwplayer.jw-state-error .jw-media{cursor:default}body .jw-error .jw-preview,body .jwplayer.jw-state-error .jw-preview{background-color:#333}body .jw-error .jw-error-msg,body .jwplayer.jw-state-error .jw-error-msg{background-color:#000;border-radius:2px;display:flex;flex-direction:row;align-items:stretch;padding:20px}body .jw-error .jw-error-msg .jw-icon,body .jwplayer.jw-state-error .jw-error-msg .jw-icon{height:30px;width:30px;margin-right:20px;flex:0 0 auto;align-self:center}body .jw-error .jw-error-msg .jw-icon:empty,body .jwplayer.jw-state-error .jw-error-msg .jw-icon:empty{display:none}body .jw-error .jw-error-msg .jw-info-container,body .jwplayer.jw-state-error .jw-error-msg .jw-info-container{margin:0;padding:0}body .jw-error:not(.jw-flag-audio-player).jw-flag-small-player .jw-error-msg,body .jwplayer.jw-state-error:not(.jw-flag-audio-player).jw-flag-small-player .jw-error-msg,body .jw-error:not(.jw-flag-audio-player).jw-breakpoint-2 .jw-error-msg,body .jwplayer.jw-state-error:not(.jw-flag-audio-player).jw-breakpoint-2 .jw-error-msg{flex-direction:column}body .jw-error:not(.jw-flag-audio-player).jw-flag-small-player .jw-error-msg .jw-error-text,body .jwplayer.jw-state-error:not(.jw-flag-audio-player).jw-flag-small-player .jw-error-msg .jw-error-text,body .jw-error:not(.jw-flag-audio-player).jw-breakpoint-2 .jw-error-msg .jw-error-text,body .jwplayer.jw-state-error:not(.jw-flag-audio-player).jw-breakpoint-2 .jw-error-msg .jw-error-text{text-align:center}body .jw-error:not(.jw-flag-audio-player).jw-flag-small-player .jw-error-msg .jw-icon,body .jwplayer.jw-state-error:not(.jw-flag-audio-player).jw-flag-small-player .jw-error-msg .jw-icon,body .jw-error:not(.jw-flag-audio-player).jw-breakpoint-2 .jw-error-msg .jw-icon,body .jwplayer.jw-state-error:not(.jw-flag-audio-player).jw-breakpoint-2 .jw-error-msg .jw-icon{flex:.5 0 auto;margin-right:0;margin-bottom:20px}.jwplayer.jw-state-error.jw-flag-audio-player .jw-error-msg .jw-break,.jwplayer.jw-state-error.jw-flag-small-player .jw-error-msg .jw-break,.jwplayer.jw-state-error.jw-breakpoint-2 .jw-error-msg .jw-break{display:inline}.jwplayer.jw-state-error.jw-flag-audio-player .jw-error-msg .jw-break:before,.jwplayer.jw-state-error.jw-flag-small-player .jw-error-msg .jw-break:before,.jwplayer.jw-state-error.jw-breakpoint-2 .jw-error-msg .jw-break:before{content:\" \"}.jwplayer.jw-state-error.jw-flag-audio-player .jw-error-msg{height:100%;width:100%;top:0;position:absolute;left:0;background:#000;-webkit-transform:none;transform:none;padding:4px 16px;z-index:1}.jwplayer.jw-state-error.jw-flag-audio-player .jw-error-msg.jw-info-overlay{max-width:none;max-height:none}body .jwplayer.jw-state-error .jw-title,.jw-state-idle .jw-title,.jwplayer.jw-state-complete:not(.jw-flag-casting):not(.jw-flag-audio-player):not(.jw-flag-overlay-open-related) .jw-title{display:block}body .jwplayer.jw-state-error .jw-preview,.jw-state-idle .jw-preview,.jwplayer.jw-state-complete:not(.jw-flag-casting):not(.jw-flag-audio-player):not(.jw-flag-overlay-open-related) .jw-preview{display:block}.jw-state-idle .jw-captions,.jwplayer.jw-state-complete .jw-captions,body .jwplayer.jw-state-error .jw-captions{display:none}.jw-state-idle video::-webkit-media-text-track-container,.jwplayer.jw-state-complete video::-webkit-media-text-track-container,body .jwplayer.jw-state-error video::-webkit-media-text-track-container{display:none}.jwplayer.jw-flag-fullscreen{width:100% !important;height:100% !important;top:0;right:0;bottom:0;left:0;z-index:1000;margin:0;position:fixed}.jwplayer.jw-flag-controls-hidden .jw-media{cursor:default}.jw-flag-audio-player .jw-media{visibility:hidden}.jw-flag-audio-player .jw-title{background:none}.jw-flag-floating{background-size:cover;background-color:#000}.jw-flag-floating .jw-wrapper{position:fixed;z-index:2147483647;top:auto;bottom:1rem;left:auto;right:1rem;max-width:400px;max-height:400px;margin:0 auto}@media screen and (min-width:481px){.jw-flag-floating .jw-wrapper:not(.jw-floating-dragged){-webkit-animation:jw-float-to-bottom 150ms cubic-bezier(0, .25, .25, 1) forwards 1;animation:jw-float-to-bottom 150ms cubic-bezier(0, .25, .25, 1) forwards 1}}@media screen and (max-width:480px){.jw-flag-floating .jw-wrapper{width:100%;left:0;right:0}}.jw-flag-floating .jw-wrapper.jw-floating-dragging{transition:none!important}.jw-flag-floating .jw-wrapper .jw-media{touch-action:none}@media screen and (max-device-width:480px) and (orientation:portrait){.jw-flag-touch.jw-flag-floating .jw-wrapper{-webkit-animation:none;animation:none;top:0;margin-top:62px;bottom:auto;max-width:none;max-height:none}}.jw-flag-floating .jw-float-icon{pointer-events:all;cursor:pointer;display:none}.jw-flag-floating .jw-float-icon .jw-svg-icon{-webkit-filter:drop-shadow(0 0 1px #000);filter:drop-shadow(0 0 1px #000)}.jw-flag-floating.jw-floating-dismissible .jw-dismiss-icon{display:none}.jw-flag-floating.jw-floating-dismissible.jw-flag-ads .jw-float-icon{display:flex}.jw-flag-floating.jw-floating-dismissible.jw-state-paused .jw-logo,.jw-flag-floating.jw-floating-dismissible:not(.jw-flag-user-inactive) .jw-logo{display:none}.jw-flag-floating.jw-floating-dismissible.jw-state-paused .jw-float-icon,.jw-flag-floating.jw-floating-dismissible:not(.jw-flag-user-inactive) .jw-float-icon{display:flex}.jw-float-icon{display:none;position:absolute;top:3px;right:5px;align-items:center;justify-content:center}@-webkit-keyframes jw-float-to-bottom{from{-webkit-transform:translateY(100%);transform:translateY(100%)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes jw-float-to-bottom{from{-webkit-transform:translateY(100%);transform:translateY(100%)}to{-webkit-transform:translateY(0);transform:translateY(0)}}.jw-flag-top{margin-top:2em;overflow:visible}.jw-top{height:2em;line-height:2;pointer-events:none;text-align:center;opacity:.8;position:absolute;top:-2em;width:100%}.jw-top .jw-icon{cursor:pointer;pointer-events:all;height:auto;width:auto}.jw-top .jw-text{color:#555}", ""]);



/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return '@media ' + item[2] + '{' + content + '}';
      } else {
        return content;
      }
    }).join('');
  }; // import a list of modules into the list


  list.i = function (modules, mediaQuery) {
    if (typeof modules === 'string') {
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    for (var i = 0; i < this.length; i++) {
      var id = this[i][0];

      if (id != null) {
        alreadyImportedModules[id] = true;
      }
    }

    for (i = 0; i < modules.length; i++) {
      var item = modules[i]; // skip already imported module
      // this implementation is not 100% perfect for weird media query combinations
      // when a module is imported multiple times with different media queries.
      // I hope this will never occur (Hey this way we have smaller bundles)

      if (item[0] == null || !alreadyImportedModules[item[0]]) {
        if (mediaQuery && !item[2]) {
          item[2] = mediaQuery;
        } else if (mediaQuery) {
          item[2] = '(' + item[2] + ') and (' + mediaQuery + ')';
        }

        list.push(item);
      }
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || '';
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;
  return '/*# ' + data + ' */';
}

/***/ }),

/***/ "./src/css/jwplayer.less":
/*!*******************************!*\
  !*** ./src/css/jwplayer.less ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js??ref--4-1!../../node_modules/postcss-loader/src!../../node_modules/less-loader/dist/cjs.js??ref--4-3!./jwplayer.less */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/src/index.js!./node_modules/less-loader/dist/cjs.js?!./src/css/jwplayer.less");
if(typeof content === 'string') content = [['all-players', content, '']];

__webpack_require__(/*! ../../node_modules/simple-style-loader/addStyles.js */ "./node_modules/simple-style-loader/addStyles.js").style(content,'all-players');
if(content.locals) module.exports = content.locals;

/***/ }),

/***/ "./src/js/api/set-config.js":
/*!**********************************!*\
  !*** ./src/js/api/set-config.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var utils_underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils/underscore */ "./src/js/utils/underscore.js");
/* harmony import */ var api_config_normalization__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! api/config-normalization */ "./src/js/api/config-normalization.ts");


var FLOAT_ENUM = ['notVisible', 'always', 'never'];

function setAutoStart(model, controller, autoStart) {
  model.setAutoStart(autoStart);

  if (model.get('state') === 'idle' && autoStart === true) {
    controller.play({
      reason: 'autostart'
    });
  }
}

/* harmony default export */ __webpack_exports__["default"] = (function (controller, newConfig) {
  var model = controller._model;
  var attributes = model.attributes;

  if (newConfig.height) {
    // Prepare width and height for view.resize()
    newConfig.height = Object(api_config_normalization__WEBPACK_IMPORTED_MODULE_1__["normalizeSize"])(newConfig.height);
    newConfig.width = newConfig.width || attributes.width;
  }

  if (newConfig.width) {
    newConfig.width = Object(api_config_normalization__WEBPACK_IMPORTED_MODULE_1__["normalizeSize"])(newConfig.width);

    if (newConfig.aspectratio) {
      // Silently set width on the model for aspectratio update
      attributes.width = newConfig.width;
      delete newConfig.width;
    } else {
      // Prepare width and height for view.resize()
      newConfig.height = attributes.height;
    }
  } // Call view.resize() for width and height when aspectratio is not defined


  if (newConfig.width && newConfig.height && !newConfig.aspectratio) {
    controller._view.resize(newConfig.width, newConfig.height);
  }

  if (newConfig.floating) {
    var currFloatCfg = model.get('floating') || {};

    var newFloatCfg = Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["extend"])({}, currFloatCfg, newConfig.floating);

    if (FLOAT_ENUM.indexOf(newFloatCfg.mode) === -1) {
      delete newConfig.floating;
    } else {
      newConfig.floating = newFloatCfg;
    }
  }

  Object.keys(newConfig).forEach(function (field) {
    var newValue = newConfig[field];

    if (newValue === undefined) {
      return;
    }

    switch (field) {
      case 'aspectratio':
        model.set(field, Object(api_config_normalization__WEBPACK_IMPORTED_MODULE_1__["normalizeAspectRatio"])(newValue, attributes.width));
        break;

      case 'autostart':
        setAutoStart(model, controller, newValue);
        break;

      case 'mute':
        controller.setMute(newValue);
        break;

      case 'volume':
        controller.setVolume(newValue);
        break;

      case 'playbackRateControls':
      case 'playbackRates':
      case 'repeat':
      case 'stretching':
      case 'floating':
        model.set(field, newValue);
        break;

      default:
    }
  });
});

/***/ }),

/***/ "./src/js/controller/async-item.ts":
/*!*****************************************!*\
  !*** ./src/js/controller/async-item.ts ***!
  \*****************************************/
/*! exports provided: AsyncItemController */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AsyncItemController", function() { return AsyncItemController; });
/* harmony import */ var playlist_playlist__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! playlist/playlist */ "./src/js/playlist/playlist.js");
/* harmony import */ var api_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! api/errors */ "./src/js/api/errors.ts");
/* harmony import */ var playlist_item__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! playlist/item */ "./src/js/playlist/item.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


 // Type only imports



var AsyncItemError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(AsyncItemError, _Error);

  function AsyncItemError(message) {
    var _this;

    _this = _Error.call(this, message) || this;
    _this.code = api_errors__WEBPACK_IMPORTED_MODULE_1__["ASYNC_PLAYLIST_ITEM_REJECTED"];
    return _this;
  }

  return AsyncItemError;
}(_wrapNativeSuper(Error));

var AsyncItemController = /*#__PURE__*/function () {
  function AsyncItemController(index, model, api) {
    var _this2 = this;

    this.index = index;
    this.model = model;
    this.api = api;
    this.promise = new Promise(function (resolve, reject) {
      _this2.resolve = resolve;
      _this2.reject = reject;
    });
    this.async = null;
    this.asyncPromise = null;
    this.rejected = false;
  }

  var _proto = AsyncItemController.prototype;

  _proto.run = function run() {
    var _this3 = this;

    var api = this.api,
        async = this.async,
        index = this.index,
        model = this.model,
        resolve = this.resolve,
        reject = this.reject,
        promise = this.promise;
    var playlist = model.get('playlist');
    var playlistItem = this.getItem(index);

    if (!playlistItem) {
      var message = index === -1 ? 'No recs item' : "No playlist item at index " + index;
      this.rejected = true;
      reject(new Error(message));
    }

    if (async) {
      this.clear();
      var asyncPromise = this.asyncPromise = async.call(api, playlistItem, index);

      if (asyncPromise && asyncPromise.then) {
        asyncPromise.then(function (item) {
          if (item && item !== playlistItem && playlist === model.get('playlist')) {
            var newItem = _this3.replace(item);

            if (newItem) {
              resolve(newItem);
              return;
            }
          }

          resolve(playlistItem);
        }).catch(function (error) {
          var setActiveItemError = new AsyncItemError('Item skipped by playlist item callback');
          setActiveItemError.sourceError = error;
          _this3.rejected = true;
          reject(setActiveItemError);
        });
      } else {
        this.asyncPromise = null;
      }
    }

    if (!this.asyncPromise) {
      resolve(playlistItem);
    }

    return promise;
  };

  _proto.getItem = function getItem(index) {
    var model = this.model;

    if (index === -1) {
      return model.get('nextUp');
    }

    var playlist = model.get('playlist');
    return playlist[index];
  };

  _proto.replace = function replace(item) {
    var index = this.index,
        model = this.model;
    var newItem = Object(playlist_playlist__WEBPACK_IMPORTED_MODULE_0__["normalizePlaylistItem"])(model, new playlist_item__WEBPACK_IMPORTED_MODULE_2__["default"](item), item.feedData || {});

    if (newItem) {
      if (index === -1) {
        model.set('nextUp', newItem);
      } else {
        var playlist = model.get('playlist');
        playlist[index] = newItem;
      }

      return newItem;
    }
  };

  _proto.clear = function clear() {
    this.async = null;
  };

  _createClass(AsyncItemController, [{
    key: "callback",
    set: function set(handler) {
      this.async = handler;
    }
  }, {
    key: "skipped",
    get: function get() {
      return this.rejected;
    }
  }]);

  return AsyncItemController;
}();

/***/ }),

/***/ "./src/js/controller/captions.js":
/*!***************************************!*\
  !*** ./src/js/controller/captions.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var utils_underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils/underscore */ "./src/js/utils/underscore.js");
/* harmony import */ var controller_tracks_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! controller/tracks-loader */ "./src/js/controller/tracks-loader.ts");
/* harmony import */ var controller_tracks_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! controller/tracks-helper */ "./src/js/controller/tracks-helper.ts");
/* harmony import */ var utils_backbone_events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! utils/backbone.events */ "./src/js/utils/backbone.events.ts");
/* harmony import */ var events_events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! events/events */ "./src/js/events/events.ts");





/* Displays closed captions or subtitles on top of the video */

var Captions = function Captions(_model) {
  var _this = this;

  var _tracks = [];
  var _tracksById = {};
  var _unknownCount = 0;
  var _defaultIndex = 0; // Reset and load external captions on playlist item

  _model.on('change:playlistItem', function (model) {
    _tracks = [];
    _tracksById = {};
    _unknownCount = 0; // Update model without dispatching events

    var attributes = model.attributes;
    attributes.captionsIndex = 0;
    attributes.captionsList = _captionsMenu();
    model.set('captionsTrack', null);
  }, this); // Update tracks once we know "renderCaptionsNatively" based on provider


  _model.on('change:itemReady', function () {
    // Sideload tracks when not rendering natively
    var item = _model.get('playlistItem');

    var tracks = item.tracks;
    var len = tracks && tracks.length;

    if (len && !_model.get('renderCaptionsNatively')) {
      var _loop = function _loop(i) {
        /* eslint-disable no-loop-func */
        var track = tracks[i];

        if (!track.includedInManifest && _kindSupported(track.kind) && !_tracksById[track._id]) {
          track.sideloaded = true;

          _addTrack(track);

          Object(controller_tracks_loader__WEBPACK_IMPORTED_MODULE_1__["loadFile"])(track, function (vttCues) {
            _addVTTCuesToTrack(track, vttCues);
          }, function (error) {
            _this.trigger(events_events__WEBPACK_IMPORTED_MODULE_4__["WARNING"], error);
          });
        }
      };

      for (var i = 0; i < len; i++) {
        _loop(i);
      }
    }

    _setCaptionsList();
  }, this); // Listen for captions menu index changes from the view


  _model.on('change:captionsIndex', function (model, captionsMenuIndex) {
    var track = null;

    if (captionsMenuIndex !== 0) {
      track = _tracks[captionsMenuIndex - 1];
    }

    model.set('captionsTrack', track);
  }, this);

  function _setSubtitlesTracks(tracks) {
    if (!Array.isArray(tracks)) {
      return;
    }

    if (!tracks.length) {
      _tracks = [];
      _tracksById = {};
      _unknownCount = 0;
    } else {
      tracks.forEach(function (track) {
        return _addTrack(track);
      }); // Make _tracks order match (video) tracks

      _tracks.sort(function (trackA, trackB) {
        var videoTracksIndexOfA = tracks.indexOf(trackA);

        if (videoTracksIndexOfA === -1) {
          return 1;
        }

        var videoTracksIndexOfB = tracks.indexOf(trackB);

        if (videoTracksIndexOfB === -1) {
          return -1;
        }

        return videoTracksIndexOfA - videoTracksIndexOfB;
      });
    }

    _setCaptionsList();
  }

  function _kindSupported(kind) {
    return kind === 'subtitles' || kind === 'captions';
  }

  function _addVTTCuesToTrack(track, vttCues) {
    track.data = vttCues;
  }

  function _addTrack(track) {
    track.data = track.data || [];
    track.name = track.label || track.name || track.language;
    var id = Object(controller_tracks_helper__WEBPACK_IMPORTED_MODULE_2__["createId"])(track, _tracks.length);

    if (!track.name) {
      var labelInfo = Object(controller_tracks_helper__WEBPACK_IMPORTED_MODULE_2__["createLabel"])(track, _unknownCount);
      track.name = labelInfo.label;
      _unknownCount = labelInfo.unknownCount;
    } // During the same playlist we may re-add tracks with the same _id; allow the new track to replace the old


    track._id = id;
    _tracksById[id] = track;
    _tracks = _tracks.filter(function (tr) {
      return tr._id !== id;
    });

    _tracks.push(track);
  }

  function _captionsMenu() {
    var list = [{
      id: 'off',
      label: 'Off'
    }];

    for (var i = 0; i < _tracks.length; i++) {
      list.push({
        id: _tracks[i]._id,
        label: _tracks[i].name || 'Unknown CC',
        language: _tracks[i].language
      });
    }

    return list;
  }

  function _selectDefaultIndex(defaultIndex) {
    var captionsMenuIndex = _defaultIndex = defaultIndex;

    var label = _model.get('captionLabel'); // Because there is no explicit track for "Off"
    //  it is the implied zeroth track


    if (label === 'Off') {
      _model.set('captionsIndex', 0);

      return;
    }

    for (var i = 0; i < _tracks.length; i++) {
      var track = _tracks[i];

      if (label && label === track.name) {
        captionsMenuIndex = i + 1;
        break;
      } else if (track.default || track.defaulttrack || track._id === 'default') {
        captionsMenuIndex = i + 1;
      } else if (track.autoselect) {// TODO: auto select track by comparing track.language to system lang
      }
    } // set the index without the side effect of storing the Off label in _selectCaptions


    _setCurrentIndex(captionsMenuIndex);
  }

  function _setCurrentIndex(index) {
    if (_tracks.length) {
      _model.setVideoSubtitleTrack(index, _tracks);
    } else {
      _model.set('captionsIndex', index);
    }
  }

  function _setCaptionsList() {
    var captionsList = _captionsMenu();

    if (listIdentity(captionsList) !== listIdentity(_model.get('captionsList'))) {
      _model.set('captionsList', captionsList);

      _selectDefaultIndex(_defaultIndex);
    }
  }

  function listIdentity(list) {
    return list.map(function (item) {
      return item.id + "-" + item.label;
    }).join(',');
  }

  this.setSubtitlesTracks = _setSubtitlesTracks;
  this.selectDefaultIndex = _selectDefaultIndex;

  this.getCurrentIndex = function () {
    return _model.get('captionsIndex');
  };

  this.getCaptionsList = function () {
    return _model.get('captionsList');
  };

  this.destroy = function () {
    this.off(null, null, this);
  };
};

Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["extend"])(Captions.prototype, utils_backbone_events__WEBPACK_IMPORTED_MODULE_3__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Captions);

/***/ }),

/***/ "./src/js/controller/controller.js":
/*!*****************************************!*\
  !*** ./src/js/controller/controller.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var utils_underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils/underscore */ "./src/js/utils/underscore.js");
/* harmony import */ var api_players__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! api/players */ "./src/js/api/players.js");
/* harmony import */ var api_core_shim__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! api/core-shim */ "./src/js/api/core-shim.js");
/* harmony import */ var api_set_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! api/set-config */ "./src/js/api/set-config.js");
/* harmony import */ var api_api_queue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! api/api-queue */ "./src/js/api/api-queue.ts");
/* harmony import */ var playlist_loader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! playlist/loader */ "./src/js/playlist/loader.ts");
/* harmony import */ var playlist_playlist__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! playlist/playlist */ "./src/js/playlist/playlist.js");
/* harmony import */ var controller_instream_adapter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! controller/instream-adapter */ "./src/js/controller/instream-adapter.js");
/* harmony import */ var controller_captions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! controller/captions */ "./src/js/controller/captions.js");
/* harmony import */ var controller_model__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! controller/model */ "./src/js/controller/model.ts");
/* harmony import */ var view_view__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! view/view */ "./src/js/view/view.js");
/* harmony import */ var view_view_model__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! view/view-model */ "./src/js/view/view-model.ts");
/* harmony import */ var events_change_state_event__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! events/change-state-event */ "./src/js/events/change-state-event.ts");
/* harmony import */ var controller_events_middleware__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! controller/events-middleware */ "./src/js/controller/events-middleware.ts");
/* harmony import */ var utils_backbone_events__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! utils/backbone.events */ "./src/js/utils/backbone.events.ts");
/* harmony import */ var utils_can_autoplay__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! utils/can-autoplay */ "./src/js/utils/can-autoplay.js");
/* harmony import */ var environment_environment__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! environment/environment */ "./src/js/environment/environment.ts");
/* harmony import */ var providers_utils_stream_type__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! providers/utils/stream-type */ "./src/js/providers/utils/stream-type.ts");
/* harmony import */ var utils_cancelable__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! utils/cancelable */ "./src/js/utils/cancelable.ts");
/* harmony import */ var utils_in_interaction_event__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! utils/in-interaction-event */ "./src/js/utils/in-interaction-event.ts");
/* harmony import */ var model_player_model__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! model/player-model */ "./src/js/model/player-model.ts");
/* harmony import */ var events_events__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! events/events */ "./src/js/events/events.ts");
/* harmony import */ var program_program_controller__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! program/program-controller */ "./src/js/program/program-controller.js");
/* harmony import */ var controller_qoe__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! controller/qoe */ "./src/js/controller/qoe.ts");
/* harmony import */ var program_program_constants__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! program/program-constants */ "./src/js/program/program-constants.ts");
/* harmony import */ var api_errors__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! api/errors */ "./src/js/api/errors.ts");




























 // The model stores a different state than the provider

function normalizeState(newstate) {
  if (newstate === events_events__WEBPACK_IMPORTED_MODULE_21__["STATE_LOADING"] || newstate === events_events__WEBPACK_IMPORTED_MODULE_21__["STATE_STALLED"]) {
    return events_events__WEBPACK_IMPORTED_MODULE_21__["STATE_BUFFERING"];
  }

  return newstate;
}

var Controller = function Controller() {};

var noop = function noop() {};

if (false) {}

Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["extend"])(Controller.prototype, {
  setup: function setup(config, _api, originalContainer, eventListeners, commandQueue, mediaPool) {
    var _this2 = this;

    var _this = this;

    var _model = _this._model = new controller_model__WEBPACK_IMPORTED_MODULE_9__["default"]();

    var _view;

    var _captions;

    var _beforePlay = false;

    var _actionOnAttach;

    var _stopPlaylist = false;

    var _interruptPlay;

    var _resumeAfterScrubbing = null;
    var checkAutoStartCancelable = Object(utils_cancelable__WEBPACK_IMPORTED_MODULE_18__["default"])(_checkAutoStart);
    var updatePlaylistCancelable = Object(utils_cancelable__WEBPACK_IMPORTED_MODULE_18__["default"])(noop);
    _this.originalContainer = _this.currentContainer = originalContainer;
    _this._events = eventListeners; // Delegate trigger so we can run a middleware function before any event is bubbled through the API

    _this.trigger = function (type, args) {
      var data = Object(controller_events_middleware__WEBPACK_IMPORTED_MODULE_13__["default"])(_model, type, args);
      return utils_backbone_events__WEBPACK_IMPORTED_MODULE_14__["default"].trigger.call(this, type, data);
    };

    var eventsReadyQueue = new api_api_queue__WEBPACK_IMPORTED_MODULE_4__["default"](_this, ['trigger'], function () {
      return true;
    });

    var _trigger = function _trigger(type, event) {
      _this.trigger(type, event);
    };

    _model.setup(config);

    var _backgroundLoading = _model.get('backgroundLoading');

    if (false) {} else {
      var viewModel = new view_view_model__WEBPACK_IMPORTED_MODULE_11__["default"](_model);
      _view = this._view = new view_view__WEBPACK_IMPORTED_MODULE_10__["default"](_api, viewModel);

      _view.on('all', function (type, event) {
        if (event && event.doNotForward) {
          return;
        }

        _trigger(type, event);
      }, _this);

      viewModel.on('viewSetup', function (viewElement) {
        Object(api_core_shim__WEBPACK_IMPORTED_MODULE_2__["showView"])(_this2, viewElement);
      });
    }

    var _programController = this._programController = new program_program_controller__WEBPACK_IMPORTED_MODULE_22__["default"](_model, mediaPool, _api._publicApi);

    updateProgramSoundSettings();
    addProgramControllerListeners();
    Object(controller_qoe__WEBPACK_IMPORTED_MODULE_23__["default"])(_model, _programController);

    _model.on(events_events__WEBPACK_IMPORTED_MODULE_21__["ERROR"], _this.triggerError, _this);

    _model.on('change:state', function (model, newstate, oldstate) {
      var adState = _getAdState();

      if (!adState) {
        events_change_state_event__WEBPACK_IMPORTED_MODULE_12__["default"].call(_this2, model, newstate, oldstate);
      }
    }, this);

    _model.on('change:castState', function (model, evt) {
      _this.trigger(events_events__WEBPACK_IMPORTED_MODULE_21__["CAST_SESSION"], evt);
    });

    _model.on('change:fullscreen', function (model, bool) {
      _this.trigger(events_events__WEBPACK_IMPORTED_MODULE_21__["FULLSCREEN"], {
        fullscreen: bool
      });

      if (bool) {
        // Stop autoplay behavior when the player enters fullscreen
        model.set('playOnViewable', false);
      }
    });

    _model.on('change:volume', function (model, vol) {
      _this.trigger(events_events__WEBPACK_IMPORTED_MODULE_21__["MEDIA_VOLUME"], {
        volume: vol
      });
    });

    _model.on('change:mute', function (model) {
      _this.trigger(events_events__WEBPACK_IMPORTED_MODULE_21__["MEDIA_MUTE"], {
        mute: model.getMute()
      });
    });

    _model.on('change:playbackRate', function (model, rate) {
      _this.trigger(events_events__WEBPACK_IMPORTED_MODULE_21__["PLAYBACK_RATE_CHANGED"], {
        playbackRate: rate,
        position: model.get('position')
      });
    });

    var changeReason = function changeReason(model, reason) {
      // Stop autoplay behavior if the video is started by the user or an api call
      if (reason === 'clickthrough' || reason === 'interaction' || reason === 'external') {
        _model.set('playOnViewable', false);

        _model.off('change:playReason change:pauseReason', changeReason);
      }
    };

    _model.on('change:playReason change:pauseReason', changeReason); // Listen for play and pause reasons from instream.


    _this.on(events_events__WEBPACK_IMPORTED_MODULE_21__["AD_PLAY"], function (event) {
      return changeReason(null, event.playReason);
    });

    _this.on(events_events__WEBPACK_IMPORTED_MODULE_21__["AD_PAUSE"], function (event) {
      return changeReason(null, event.pauseReason);
    });

    _model.on('change:scrubbing', function (model, state) {
      if (state) {
        _resumeAfterScrubbing = _model.get('state') !== events_events__WEBPACK_IMPORTED_MODULE_21__["STATE_PAUSED"];

        _pause();
      } else if (_resumeAfterScrubbing) {
        _play({
          reason: 'interaction'
        });
      }
    }); // For onCaptionsList and onCaptionsChange


    _model.on('change:captionsList', function (model, captionsList) {
      _this.trigger(events_events__WEBPACK_IMPORTED_MODULE_21__["CAPTIONS_LIST"], {
        tracks: captionsList,
        track: _model.get('captionsIndex') || 0
      });
    });

    _model.on('change:mediaModel', function (model, mediaModel) {
      var _this3 = this;

      model.set('errorEvent', undefined);
      mediaModel.change('mediaState', function (changedMediaModel, state) {
        if (!model.get('errorEvent')) {
          model.set(events_events__WEBPACK_IMPORTED_MODULE_21__["PLAYER_STATE"], normalizeState(state));
        }
      }, this);
      mediaModel.change('duration', function (changedMediaModel, duration) {
        if (duration === 0) {
          return;
        }

        var minDvrWindow = model.get('minDvrWindow');
        var type = Object(providers_utils_stream_type__WEBPACK_IMPORTED_MODULE_17__["streamType"])(duration, minDvrWindow);
        model.setStreamType(type);
      }, this);
      var recsAuto = (model.get('related') || {}).oncomplete === 'autoplay';
      var index = model.get('item') + 1;
      var item = model.get('playlist')[index];

      if (item || recsAuto) {
        var onPosition = function onPosition(changedMediaModel, position) {
          if (recsAuto && !item) {
            index = -1;
            item = _model.get('nextUp');
          } // Do not background load DAI items because that item will be dynamically replaced before play


          var allowPreload = item && !item.daiSetting;

          if (!allowPreload) {
            return;
          }

          var duration = mediaModel.get('duration');

          if (position && duration > 0 && position >= duration - program_program_constants__WEBPACK_IMPORTED_MODULE_24__["BACKGROUND_LOAD_OFFSET"]) {
            mediaModel.off('change:position', onPosition, _this3);

            if (_backgroundLoading) {
              _programController.backgroundLoad(item, index);
            } else {
              _programController.getAsyncItem(index).run();
            }
          }
        };

        mediaModel.on('change:position', onPosition, this);
      }
    }); // Ensure captionsList event is raised after playlistItem


    if (true) {
      _captions = new controller_captions__WEBPACK_IMPORTED_MODULE_8__["default"](_model);

      _captions.on('all', _trigger, _this);
    }

    this.playerReady = function () {
      if (false) {} else {
        // Fire 'ready' once the view has resized so that player width and height are available
        // (requires the container to be in the DOM)
        _view.once(events_events__WEBPACK_IMPORTED_MODULE_21__["RESIZE"], function () {
          try {
            playerReadyNotify();
          } catch (error) {
            _this.triggerError(Object(api_errors__WEBPACK_IMPORTED_MODULE_25__["convertToPlayerError"])(api_errors__WEBPACK_IMPORTED_MODULE_25__["MSG_TECHNICAL_ERROR"], api_errors__WEBPACK_IMPORTED_MODULE_25__["ERROR_COMPLETING_SETUP"], error));
          }
        });

        _view.init();
      }
    };

    function playerReadyNotify() {
      _model.change('visibility', _updateViewable);

      eventsReadyQueue.off(); // Tell the api that we are loaded

      _this.trigger(events_events__WEBPACK_IMPORTED_MODULE_21__["READY"], {
        // this will be updated by Api
        setupTime: 0
      });

      _model.change('playlist', function (model, playlist) {
        if (playlist.length) {
          var eventData = {
            playlist: playlist
          };

          var feedData = _model.get('feedData');

          if (feedData) {
            eventData.feedData = Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["extend"])({}, feedData);
          }

          _this.trigger(events_events__WEBPACK_IMPORTED_MODULE_21__["PLAYLIST_LOADED"], eventData);
        }
      });

      _model.change('playlistItem', function (model, playlistItem) {
        if (playlistItem) {
          var title = playlistItem.title,
              image = playlistItem.image;

          if ('mediaSession' in navigator && window.MediaMetadata && (title || image)) {
            try {
              navigator.mediaSession.metadata = new window.MediaMetadata({
                title: title,
                artist: window.location.hostname,
                artwork: [{
                  src: image || ''
                }]
              });
            } catch (error) {// catch error that occurs when mediaSession fails to setup
            }
          }

          model.set('cues', []);

          _this.trigger(events_events__WEBPACK_IMPORTED_MODULE_21__["PLAYLIST_ITEM"], {
            index: _model.get('item'),
            item: playlistItem
          });
        }
      });

      eventsReadyQueue.flush();
      eventsReadyQueue.destroy();
      eventsReadyQueue = null;

      _model.change('viewable', viewableChange);

      _model.change('viewable', _checkPlayOnViewable);

      if (_model.get('autoPause').viewability) {
        _model.change('viewable', _checkPauseOnViewable);
      } else {
        _model.once('change:autostartFailed change:mute', function (model) {
          model.off('change:viewable', _checkPlayOnViewable);
        });
      } // Run _checkAutoStart() last
      // 'viewable' changes can result in preload() being called on the initial provider instance


      _checkAutoStart();

      _model.on('change:itemReady', function (changeModel, itemReady) {
        if (itemReady) {
          apiQueue.flush();
        }
      });
    }

    function _updateViewable(model, visibility) {
      if (!Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["isUndefined"])(visibility)) {
        _model.set('viewable', Math.round(visibility));
      }
    }

    function _checkAutoStart() {
      if (!apiQueue) {
        // this player has been destroyed
        return;
      } // Autostart immediately if we're not waiting for the player to become viewable first.


      if (_model.get('autostart') === true && !_model.get('playOnViewable')) {
        _autoStart('autostart');
      }

      apiQueue.flush();
    }

    function viewableChange(model, viewable) {
      _this.trigger('viewable', {
        viewable: viewable
      });

      preload();
    }

    function preload() {
      // Only attempt to preload if this is the first player on the page or viewable
      if (api_players__WEBPACK_IMPORTED_MODULE_1__["default"][0] !== _api && _model.get('viewable') !== 1) {
        return;
      }

      if (_model.get('state') === 'idle' && _model.get('autostart') === false) {
        // If video has not been primed on Android, test that video will play before preloading
        // This ensures we always prime the tag on play when necessary
        if ( true && !mediaPool.primed() && environment_environment__WEBPACK_IMPORTED_MODULE_16__["OS"].android) {
          var video = mediaPool.getTestElement();

          var muted = _this.getMute();

          Promise.resolve().then(function () {
            return Object(utils_can_autoplay__WEBPACK_IMPORTED_MODULE_15__["startPlayback"])(video, {
              muted: muted
            });
          }).then(function () {
            if (_model.get('state') === 'idle') {
              _programController.preloadVideo();
            }
          }).catch(noop);
        } else {
          _programController.preloadVideo();
        }
      }
    }

    function _pauseAfterAd(viewable) {
      _this._instreamAdapter.noResume = !viewable;

      if (!viewable) {
        _updatePauseReason({
          reason: 'viewable'
        });
      }
    }

    function _pauseWhenNotViewable(viewable) {
      if (!viewable) {
        _this.pause({
          reason: 'viewable'
        });

        _model.set('playOnViewable', !viewable);
      }
    }

    function _checkPlayOnViewable(model, viewable) {
      var adState = _getAdState();

      if (model.get('playOnViewable')) {
        if (viewable) {
          var reason = 'viewable';
          var autoPauseAds = model.get('autoPause').pauseAds;
          var pauseReason = model.get('pauseReason');

          if (_getState() === events_events__WEBPACK_IMPORTED_MODULE_21__["STATE_IDLE"]) {
            _autoStart(reason);
          } else if ((!adState || autoPauseAds) && pauseReason !== 'interaction') {
            // resume normal playback or ads if pauseAds is true
            _play({
              reason: reason
            });
          }
        } else if (environment_environment__WEBPACK_IMPORTED_MODULE_16__["OS"].mobile && !adState) {
          _this.pause({
            reason: 'autostart'
          });

          _model.set('playOnViewable', true);
        }

        if (environment_environment__WEBPACK_IMPORTED_MODULE_16__["OS"].mobile && adState) {
          // If during an ad on mobile, we should always be paused after the ad,
          // if not viewable, regardless of autoPause setting.
          _pauseAfterAd(viewable);
        }
      }
    }

    function _checkPauseOnViewable(model, viewable) {
      var playerState = model.get('state');

      var adState = _getAdState();

      var playReason = model.get('playReason');

      if (adState) {
        if (model.get('autoPause').pauseAds) {
          _pauseWhenNotViewable(viewable);
        } else {
          _pauseAfterAd(viewable);
        }
      } else if (playerState === events_events__WEBPACK_IMPORTED_MODULE_21__["STATE_PLAYING"] || playerState === events_events__WEBPACK_IMPORTED_MODULE_21__["STATE_BUFFERING"]) {
        _pauseWhenNotViewable(viewable);
      } else if (playerState === events_events__WEBPACK_IMPORTED_MODULE_21__["STATE_IDLE"] && playReason === 'playlist') {
        // After VAST ads, instream is destroyed and player state is 'idle'
        model.once('change:state', function () {
          _pauseWhenNotViewable(viewable);
        });
      }
    }

    function _load(item, feedData) {
      var instream = _this._instreamAdapter;

      if (instream) {
        instream.noResume = true;
      }

      _this.trigger('destroyPlugin', {});

      _stop(true);

      _programController.clearItemPromises();

      checkAutoStartCancelable.cancel();
      checkAutoStartCancelable = Object(utils_cancelable__WEBPACK_IMPORTED_MODULE_18__["default"])(_checkAutoStart);
      updatePlaylistCancelable.cancel();

      if (Object(utils_in_interaction_event__WEBPACK_IMPORTED_MODULE_19__["inInteraction"])()) {
        mediaPool.prime();
      }

      var loadPromise;

      switch (typeof item) {
        case 'string':
          {
            _model.attributes.item = 0;
            _model.attributes.itemReady = false;
            updatePlaylistCancelable = Object(utils_cancelable__WEBPACK_IMPORTED_MODULE_18__["default"])(function (data) {
              if (data) {
                return _this.updatePlaylist(Object(playlist_playlist__WEBPACK_IMPORTED_MODULE_6__["default"])(data.playlist), data);
              }
            });
            loadPromise = _loadPlaylist(item).then(updatePlaylistCancelable.async);
            break;
          }

        case 'object':
          _model.attributes.item = 0;
          loadPromise = _this.updatePlaylist(Object(playlist_playlist__WEBPACK_IMPORTED_MODULE_6__["default"])(item), feedData || {});
          break;

        case 'number':
          loadPromise = _this.setItemIndex(item);
          break;

        default:
          return;
      } // Catch playlist exceptions. Item exceptions are caught first from setActiveItem.


      loadPromise.catch(function (error) {
        _this.triggerError(Object(api_errors__WEBPACK_IMPORTED_MODULE_25__["composePlayerError"])(error, api_errors__WEBPACK_IMPORTED_MODULE_25__["ERROR_LOADING_PLAYLIST"]));
      });
      loadPromise.then(checkAutoStartCancelable.async).catch(noop);
    }

    function _loadPlaylist(toLoad) {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        var loader = new playlist_loader__WEBPACK_IMPORTED_MODULE_5__["default"]();
        loader.on(events_events__WEBPACK_IMPORTED_MODULE_21__["PLAYLIST_LOADED"], function (data) {
          resolve(data);
        });
        loader.on(events_events__WEBPACK_IMPORTED_MODULE_21__["ERROR"], reject, _this4);
        loader.load(toLoad);
      });
    }

    function _getAdState() {
      var instream = _this._instreamAdapter;

      if (instream) {
        return instream.getState();
      }

      return false;
    }

    function _getState() {
      var adState = _getAdState();

      if (adState) {
        return adState;
      }

      return _model.get('state');
    }

    function _play(meta) {
      checkAutoStartCancelable.cancel();
      _stopPlaylist = false;

      if (_model.get('state') === events_events__WEBPACK_IMPORTED_MODULE_21__["STATE_ERROR"]) {
        return Promise.resolve();
      }

      var playReason = _getReason(meta);

      _model.set('playReason', playReason);

      var adState = _getAdState();

      if (adState) {
        // this will resume the ad. _api.playAd would load a new ad
        _api.pauseAd(false, meta);

        return Promise.resolve();
      }

      if (_model.get('state') === events_events__WEBPACK_IMPORTED_MODULE_21__["STATE_COMPLETE"]) {
        _stop(true);

        return _this.setItemIndex(0).then(function () {
          return _playAttempt(meta, playReason);
        });
      }

      return _playAttempt(meta, playReason);
    }

    function _playAttempt(meta, playReason) {
      if (!_beforePlay) {
        _beforePlay = true;

        _this.trigger(events_events__WEBPACK_IMPORTED_MODULE_21__["MEDIA_BEFOREPLAY"], {
          playReason: playReason,
          startTime: meta && meta.startTime ? meta.startTime : _model.get('playlistItem').starttime
        });

        _beforePlay = false;

        if (Object(utils_in_interaction_event__WEBPACK_IMPORTED_MODULE_19__["inInteraction"])() && !mediaPool.primed()) {
          mediaPool.prime();
        }

        if (playReason === 'playlist' && _model.get('autoPause').viewability) {
          _checkPauseOnViewable(_model, _model.get('viewable'));
        }

        if (_interruptPlay) {
          // Force tags to prime if we're about to play an ad
          // Resetting the source in order to prime is OK since we'll be switching it anyway
          if (Object(utils_in_interaction_event__WEBPACK_IMPORTED_MODULE_19__["inInteraction"])() && !_backgroundLoading) {
            var video = _model.get('mediaElement');

            if (_this._instreamAdapter) {
              video.src = '';
            }

            video.load();
          }

          _interruptPlay = false;
          _actionOnAttach = null;
          return Promise.resolve();
        }
      }

      return _programController.playVideo(playReason) // If playback succeeded that means we captured a gesture (and used it to prime the pool)
      // Avoid priming again in beforePlay because it could cause BGL'd media to be source reset
      .then(mediaPool.played);
    }

    function _getReason(meta) {
      if (meta && meta.reason) {
        return meta.reason;
      }

      return 'unknown';
    }

    function _autoStart(reason) {
      var state = _getState();

      if (state !== events_events__WEBPACK_IMPORTED_MODULE_21__["STATE_IDLE"]) {
        return;
      } // Reset cancelable for new autoplay test below.


      checkAutoStartCancelable = Object(utils_cancelable__WEBPACK_IMPORTED_MODULE_18__["default"])(_checkAutoStart); // Detect and store browser autoplay setting in the model.

      var adConfig = _model.get('advertising');

      var autoPlayCheck =  false ? undefined : utils_can_autoplay__WEBPACK_IMPORTED_MODULE_15__["canAutoplay"];
      autoPlayCheck(mediaPool, {
        cancelable: checkAutoStartCancelable,
        muted: _this.getMute(),
        allowMuted: adConfig ? adConfig.autoplayadsmuted : true
      }).then(function (result) {
        _model.set('canAutoplay', result); // Only apply autostartMuted on un-muted autostart attempt.


        if (result === ( false || utils_can_autoplay__WEBPACK_IMPORTED_MODULE_15__["AUTOPLAY_MUTED"]) && !_this.getMute()) {
          _model.set('autostartMuted', true);

          updateProgramSoundSettings();

          _model.once('change:autostartMuted', function (model) {
            model.off('change:viewable', _checkPlayOnViewable);

            _this.trigger(events_events__WEBPACK_IMPORTED_MODULE_21__["MEDIA_MUTE"], {
              mute: _model.getMute()
            });
          });
        }

        if (_captions && _this.getMute() && _model.get('enableDefaultCaptions')) {
          _captions.selectDefaultIndex(1);
        }

        return _play({
          reason: reason
        }).catch(function () {
          if (!_this._instreamAdapter) {
            _model.set('autostartFailed', true);
          }

          _actionOnAttach = null;
        });
      }).catch(function (error) {
        _model.set('canAutoplay',  false || utils_can_autoplay__WEBPACK_IMPORTED_MODULE_15__["AUTOPLAY_DISABLED"]);

        _model.set('autostart', false); // Emit event unless test was explicitly canceled.


        if (!checkAutoStartCancelable.cancelled()) {
          var code = Object(api_errors__WEBPACK_IMPORTED_MODULE_25__["getPlayAttemptFailedErrorCode"])(error);

          _this.trigger(events_events__WEBPACK_IMPORTED_MODULE_21__["AUTOSTART_NOT_ALLOWED"], {
            reason: error.reason,
            code: code,
            error: error
          });
        }
      });
    }

    function _stop(internal) {
      checkAutoStartCancelable.cancel();
      apiQueue.empty();

      var adState = _getAdState();

      if (adState) {
        var instream = _this._instreamAdapter;

        if (instream) {
          instream.noResume = true;
        }

        _actionOnAttach = function _actionOnAttach() {
          return _programController.stopVideo();
        };

        return;
      }

      var fromApi = !internal;
      _actionOnAttach = null;

      if (fromApi) {
        _stopPlaylist = true;
      }

      if (_beforePlay) {
        _interruptPlay = true;
      }

      _model.set('errorEvent', undefined);

      _programController.stopVideo();
    }

    function _updatePauseReason(meta) {
      var pauseReason = _getReason(meta);

      _model.set('pauseReason', pauseReason);

      _model.set('playOnViewable', pauseReason === 'viewable');
    }

    function _pause(meta) {
      _actionOnAttach = null;
      checkAutoStartCancelable.cancel();

      var adState = _getAdState();

      if (adState && adState !== events_events__WEBPACK_IMPORTED_MODULE_21__["STATE_PAUSED"]) {
        _updatePauseReason(meta);

        _api.pauseAd(true, meta);

        return;
      }

      switch (_model.get('state')) {
        case events_events__WEBPACK_IMPORTED_MODULE_21__["STATE_ERROR"]:
          return;

        case events_events__WEBPACK_IMPORTED_MODULE_21__["STATE_PLAYING"]:
        case events_events__WEBPACK_IMPORTED_MODULE_21__["STATE_BUFFERING"]:
          {
            _updatePauseReason(meta);

            _programController.pause();

            break;
          }

        default:
          if (_beforePlay) {
            _interruptPlay = true;
          }

      }
    }

    function _isIdle() {
      var state = _model.get('state');

      return state === events_events__WEBPACK_IMPORTED_MODULE_21__["STATE_IDLE"] || state === events_events__WEBPACK_IMPORTED_MODULE_21__["STATE_COMPLETE"] || state === events_events__WEBPACK_IMPORTED_MODULE_21__["STATE_ERROR"];
    }

    function _seek(pos, meta) {
      var state = _model.get('state');

      if (state === events_events__WEBPACK_IMPORTED_MODULE_21__["STATE_ERROR"]) {
        return;
      }

      _programController.position = pos;
      var isIdle = state === events_events__WEBPACK_IMPORTED_MODULE_21__["STATE_IDLE"];

      if (!_model.get('scrubbing') && (isIdle || state === events_events__WEBPACK_IMPORTED_MODULE_21__["STATE_COMPLETE"])) {
        if (isIdle) {
          meta = meta || {};
          meta.startTime = pos;
        }

        this.play(meta);
      }
    }

    function _item(index, meta) {
      _this.instreamDestroy();

      _stop(true);

      _this.setItemIndex(index); // Use this.play() so that command is queued until after "playlistItem" event


      _this.play(meta);
    }

    function _prev(meta) {
      _item(_model.get('item') - 1, meta);
    }

    function _next(meta) {
      _item(_model.get('item') + 1, meta);
    }

    function _completeCancelled() {
      if (!_isIdle()) {
        // Something has made an API call before the complete handler has fired.
        return true;
      } else if (_stopPlaylist) {
        // Stop called in onComplete event listener
        _stopPlaylist = false;
        return true;
      }

      return false;
    }

    function _shouldAutoAdvance() {
      // If it's the last item in the playlist
      var idx = _model.get('item');

      return idx !== _model.get('playlist').length - 1;
    }

    function _completeHandler() {
      if (_this.completeCancelled()) {
        return;
      }

      _actionOnAttach = _this.completeHandler;

      if (!_this.shouldAutoAdvance()) {
        if (_model.get('repeat')) {
          _next({
            reason: 'repeat'
          });
        } else {
          // Exit fullscreen on IOS so that our overlays show to the user
          if (environment_environment__WEBPACK_IMPORTED_MODULE_16__["OS"].iOS) {
            _setFullscreen(false);
          } // Autoplay/pause no longer needed since there's no more media to play
          // This prevents media from replaying when a completed video scrolls into view


          _model.set('playOnViewable', false);

          _model.set('state', events_events__WEBPACK_IMPORTED_MODULE_21__["STATE_COMPLETE"]);

          _this.trigger(events_events__WEBPACK_IMPORTED_MODULE_21__["PLAYLIST_COMPLETE"], {});
        }

        return;
      }

      _this.nextItem();
    }

    function _setCurrentQuality(index) {
      _programController.quality = index;
    }

    function _getCurrentQuality() {
      return _programController.quality;
    }

    function _getConfig() {
      return this._model ? this._model.getConfiguration() : undefined;
    }

    function _getVisualQuality() {
      var mediaModel = this._model.get('mediaModel');

      if (mediaModel) {
        return mediaModel.get(events_events__WEBPACK_IMPORTED_MODULE_21__["MEDIA_VISUAL_QUALITY"]);
      }

      return null;
    }

    function _getQualityLevels() {
      return _programController.qualities;
    }

    function _setCurrentAudioTrack(index) {
      _programController.audioTrack = index;
    }

    function _getCurrentAudioTrack() {
      return _programController.audioTrack;
    }

    function _getAudioTracks() {
      return _programController.audioTracks;
    }

    function _setCurrentCaptions(index, tracks) {
      index = parseInt(index, 10) || 0;

      _model.persistVideoSubtitleTrack(index, tracks);

      _programController.subtitles = index;

      _this.trigger(events_events__WEBPACK_IMPORTED_MODULE_21__["CAPTIONS_CHANGED"], {
        tracks: _getCaptionsList(),
        track: index
      });
    }

    function _getCurrentCaptions() {
      return _captions ? _captions.getCurrentIndex() : -1;
    }

    function _getCaptionsList() {
      return _captions ? _captions.getCaptionsList() : [];
    }
    /* Used for the InStream API */


    function _detachMedia() {
      if (_beforePlay) {
        _interruptPlay = true;
      }

      if (_model.get('autoPause').viewability) {
        _checkPauseOnViewable(_model, _model.get('viewable'));
      }

      if (_backgroundLoading) {
        _programController.backgroundActiveMedia();
      } else {
        return _programController.setAttached(false);
      }
    }

    function _attachMedia() {
      // Called after instream ends
      if (_backgroundLoading) {
        _programController.restoreBackgroundMedia();
      } else {
        _programController.setAttached(true);
      }

      if (typeof _actionOnAttach === 'function') {
        _actionOnAttach();
      }
    }

    function _setFullscreen(state) {
      if (!Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["isBoolean"])(state)) {
        state = !_model.get('fullscreen');
      } // TODO: rather than the player responding to this state change this should be view / provider based with
      //  Promise resolution for modern browsers


      _model.set('fullscreen', state);

      if (_this._instreamAdapter && _this._instreamAdapter._adModel) {
        _this._instreamAdapter._adModel.set('fullscreen', state);
      }
    }

    function addProgramControllerListeners() {
      _programController.on('all', _trigger, _this).on('subtitlesTracks', function (e) {
        if (!_captions) {
          return;
        }

        _captions.setSubtitlesTracks(e.tracks);

        var defaultCaptionsIndex = _captions.getCurrentIndex(); // set the current captions if the default index isn't 0 or "Off"


        if (defaultCaptionsIndex > 0) {
          _setCurrentCaptions(defaultCaptionsIndex, e.tracks);
        }
      }, _this).on(events_events__WEBPACK_IMPORTED_MODULE_21__["MEDIA_COMPLETE"], function () {
        // Insert a small delay here so that other complete handlers can execute
        Promise.resolve().then(_completeHandler);
      }, _this).on(events_events__WEBPACK_IMPORTED_MODULE_21__["MEDIA_ERROR"], _this.triggerError, _this);
    }

    function updateProgramSoundSettings() {
      _programController.setMute(_model.getMute());

      _programController.setVolume(_model.get('volume'));
    }

    this.preload = preload;
    /* Controller API / public methods */

    this.load = _load;

    this.play = function (meta) {
      return _play(meta).catch(noop);
    };

    this.pause = _pause;
    this.seek = _seek;
    this.stop = _stop;
    this.playlistItem = _item;
    this.playlistNext = _next;
    this.playlistPrev = _prev;
    this.setCurrentCaptions = _setCurrentCaptions;
    this.setCurrentQuality = _setCurrentQuality;
    this.setFullscreen = _setFullscreen;
    this.getCurrentQuality = _getCurrentQuality;
    this.getQualityLevels = _getQualityLevels;
    this.setCurrentAudioTrack = _setCurrentAudioTrack;
    this.getCurrentAudioTrack = _getCurrentAudioTrack;
    this.getAudioTracks = _getAudioTracks;
    this.getCurrentCaptions = _getCurrentCaptions;
    this.getCaptionsList = _getCaptionsList;
    this.getVisualQuality = _getVisualQuality;
    this.getConfig = _getConfig;
    this.getState = _getState;
    this.next = noop;
    this.completeHandler = _completeHandler;
    this.completeCancelled = _completeCancelled;
    this.shouldAutoAdvance = _shouldAutoAdvance;

    this.nextItem = function () {
      _next({
        reason: 'playlist'
      });
    };

    this.setConfig = function (newConfig) {
      Object(api_set_config__WEBPACK_IMPORTED_MODULE_3__["default"])(_this, newConfig);
    };

    this.setItemIndex = function (index) {
      _programController.stopVideo();

      var playlist = _model.get('playlist');

      var length = playlist.length;
      var wrappedIndex = Object(playlist_playlist__WEBPACK_IMPORTED_MODULE_6__["wrapPlaylistIndex"])(index, length);
      return _programController.setActiveItem(wrappedIndex).catch(function (error) {
        if (error.code === api_errors__WEBPACK_IMPORTED_MODULE_25__["ASYNC_PLAYLIST_ITEM_REJECTED"]) {
          // If all items were rejected throw. This will fail setup with setupError code 102700
          var allSkipped = _programController.asyncItems.reduce(function (skipped, asyncItem) {
            return skipped && asyncItem.skipped;
          }, true);

          if (allSkipped) {
            throw error;
          } // If the last item is rejected we need to stop and complete playlist playback. Otherwise,
          // shouldAutoAdvance will return true because "nextUp" is out of date.
          // "related could not update "nextUp" since we've skipped over "playlistItem" events.
          // We'll need to move "nextUp" logic out of "related" and into here or the program-controller
          // So that "nextUp" can be updated when rejecting item playback with `setPlaylistItemCallback`.


          var restoreAutoAdvance = _this2.shouldAutoAdvance;

          _this2.shouldAutoAdvance = function () {
            return false;
          };

          _completeHandler();

          _model.attributes.itemReady = true;
          _this2.shouldAutoAdvance = restoreAutoAdvance;
          return;
        }

        if (error.code >= 151 && error.code <= 162) {
          error = Object(api_errors__WEBPACK_IMPORTED_MODULE_25__["composePlayerError"])(error, api_errors__WEBPACK_IMPORTED_MODULE_25__["ERROR_LOADING_PROVIDER"]);
        }

        _this2.triggerError(Object(api_errors__WEBPACK_IMPORTED_MODULE_25__["convertToPlayerError"])(api_errors__WEBPACK_IMPORTED_MODULE_25__["MSG_CANT_PLAY_VIDEO"], api_errors__WEBPACK_IMPORTED_MODULE_25__["ERROR_LOADING_PLAYLIST_ITEM"], error));
      });
    };

    this.detachMedia = _detachMedia;
    this.attachMedia = _attachMedia; // Program Controller passthroughs

    this.routeEvents = function (target) {
      return _programController.routeEvents(target);
    };

    this.forwardEvents = function () {
      return _programController.forwardEvents();
    };

    this.playVideo = function (playReason) {
      return _programController.playVideo(playReason);
    };

    this.stopVideo = function () {
      return _programController.stopVideo();
    };

    this.castVideo = function (castProvider, item) {
      return _programController.castVideo(castProvider, item);
    };

    this.stopCast = function () {
      return _programController.stopCast();
    };

    this.backgroundActiveMedia = function () {
      return _programController.backgroundActiveMedia();
    };

    this.restoreBackgroundMedia = function () {
      return _programController.restoreBackgroundMedia();
    };

    this.preloadNextItem = function () {
      if (_programController.background.currentMedia) {
        // Instruct the background media to preload if it's already been loaded
        _programController.preloadVideo();
      }
    };

    this.isBeforeComplete = function () {
      return _programController.beforeComplete;
    }; // Model passthroughs


    this.setVolume = function (volume) {
      _model.setVolume(volume);

      updateProgramSoundSettings();
    };

    this.setMute = function (mute) {
      _model.setMute(mute);

      updateProgramSoundSettings();
    };

    this.setPlaybackRate = function (playbackRate) {
      _model.setPlaybackRate(playbackRate);
    };

    this.getProvider = function () {
      return _model.get('provider');
    };

    this.getWidth = function () {
      return _model.get('containerWidth');
    };

    this.getHeight = function () {
      return _model.get('containerHeight');
    };

    this.getItemQoe = function () {
      return _model._qoeItem;
    };

    this.setItemCallback = function (callback) {
      _programController.itemCallback = callback;
    };

    this.getItemPromise = function (index) {
      var playlist = _model.get('playlist');

      if (index < -1 || index > playlist.length - 1 || isNaN(index)) {
        return null;
      }

      var asyncItem = _programController.getAsyncItem(index);

      if (!asyncItem) {
        return null;
      }

      return asyncItem.promise;
    };

    this.addButton = function (img, tooltip, callback, id, btnClass) {
      var customButtons = _model.get('customButtons') || [];
      var replaced = false;
      var newButton = {
        img: img,
        tooltip: tooltip,
        callback: callback,
        id: id,
        btnClass: btnClass
      };
      customButtons = customButtons.reduce(function (buttons, button) {
        if (button.id === id) {
          replaced = true;
          buttons.push(newButton);
        } else {
          buttons.push(button);
        }

        return buttons;
      }, []);

      if (!replaced) {
        customButtons.unshift(newButton);
      }

      _model.set('customButtons', customButtons);
    };

    this.removeButton = function (id) {
      var customButtons = _model.get('customButtons') || [];
      customButtons = customButtons.filter(function (button) {
        return button.id !== id;
      });

      _model.set('customButtons', customButtons);
    }; // View passthroughs


    if (false) {} else {
      this.resize = _view.resize;
      this.getSafeRegion = _view.getSafeRegion;
      this.setCaptions = _view.setCaptions;
    }

    this.checkBeforePlay = function () {
      return _beforePlay;
    };

    this.setControls = function (mode) {
      if (false) {}

      if (!Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["isBoolean"])(mode)) {
        mode = !_model.get('controls');
      }

      _model.set('controls', mode);

      _programController.controls = mode;
    };

    this.addCues = function (cues) {
      this.setCues(_model.get('cues').concat(cues));
    };

    this.setCues = function (cues) {
      _model.set('cues', cues);
    };

    this.updatePlaylist = function (playlist, feedData) {
      try {
        var filteredPlaylist = Object(playlist_playlist__WEBPACK_IMPORTED_MODULE_6__["filterPlaylist"])(playlist, _model, feedData); // Throw exception if playlist is empty

        Object(playlist_playlist__WEBPACK_IMPORTED_MODULE_6__["validatePlaylist"])(filteredPlaylist);

        var sanitizedFeedData = Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["extend"])({}, feedData);

        delete sanitizedFeedData.playlist;

        _model.set('feedData', sanitizedFeedData);

        _model.set('playlist', filteredPlaylist);
      } catch (error) {
        return Promise.reject(error);
      }

      return this.setItemIndex(_model.get('item'));
    };

    this.setPlaylistItem = function (index, item) {
      var playlist = _model.get('playlist');

      var wrappedIndex = Object(playlist_playlist__WEBPACK_IMPORTED_MODULE_6__["wrapPlaylistIndex"])(index, playlist.length);

      var asyncItemController = _programController.getAsyncItem(wrappedIndex);

      var newItem = asyncItemController.replace(item);

      if (!newItem) {
        return;
      }

      var playlistItem = playlist[wrappedIndex];

      if (item && item !== playlistItem) {
        _programController.asyncItems[wrappedIndex] = null;
        asyncItemController.reject(new Error('Item replaced'));
      } // If the current item was replaced, and the player is idle, reload it


      if (wrappedIndex === _model.get('item') && _model.get('state') === 'idle') {
        this.setItemIndex(wrappedIndex);
      }
    };

    this.playerDestroy = function () {
      this.off();
      this.stop();
      Object(api_core_shim__WEBPACK_IMPORTED_MODULE_2__["showView"])(this, this.originalContainer);

      if (_view) {
        _view.destroy();
      }

      if (_model) {
        _model.destroy();
      }

      if (apiQueue) {
        apiQueue.destroy();
      }

      if (_captions) {
        _captions.destroy();
      }

      if (_programController) {
        _programController.destroy();
      }

      this.instreamDestroy();
    };

    this.isBeforePlay = this.checkBeforePlay;

    this.createInstream = function () {
      this.instreamDestroy();
      this._instreamAdapter = new controller_instream_adapter__WEBPACK_IMPORTED_MODULE_7__["default"](this, _model, _view, mediaPool);
      return this._instreamAdapter;
    };

    this.instreamDestroy = function () {
      if (_this._instreamAdapter) {
        _this._instreamAdapter.destroy();

        _this._instreamAdapter = null;
      }
    }; // Setup ApiQueueDecorator after instance methods have been assigned


    var apiQueue = new api_api_queue__WEBPACK_IMPORTED_MODULE_4__["default"](this, ['play', 'pause', 'setCurrentAudioTrack', 'setCurrentCaptions', 'setCurrentQuality', 'setFullscreen'], function () {
      return !_this2._model.get('itemReady') || eventsReadyQueue;
    }); // Add commands from CoreLoader to queue

    apiQueue.queue.push.apply(apiQueue.queue, commandQueue);

    if (_view) {
      _view.setup();
    }
  },
  get: function get(property) {
    if (property in model_player_model__WEBPACK_IMPORTED_MODULE_20__["INITIAL_MEDIA_STATE"]) {
      var mediaModel = this._model.get('mediaModel');

      if (mediaModel) {
        return mediaModel.get(property);
      }

      return model_player_model__WEBPACK_IMPORTED_MODULE_20__["INITIAL_MEDIA_STATE"][property];
    }

    return this._model.get(property);
  },
  getContainer: function getContainer() {
    return this.currentContainer || this.originalContainer;
  },
  getMute: function getMute() {
    return this._model.getMute();
  },
  triggerError: function triggerError(evt) {
    var model = this._model;
    evt.message = model.get('localization').errors[evt.key];
    delete evt.key;
    model.set('errorEvent', evt);
    model.set('state', events_events__WEBPACK_IMPORTED_MODULE_21__["STATE_ERROR"]);
    model.once('change:state', function () {
      this.set('errorEvent', undefined);
    }, model);
    this.trigger(events_events__WEBPACK_IMPORTED_MODULE_21__["ERROR"], evt);
  }
});

/* harmony default export */ __webpack_exports__["default"] = (Controller);

/***/ }),

/***/ "./src/js/controller/events-middleware.ts":
/*!************************************************!*\
  !*** ./src/js/controller/events-middleware.ts ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return middleware; });
/* harmony import */ var utils_underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils/underscore */ "./src/js/utils/underscore.js");

function middleware(model, type, currentState) {
  var newState = currentState;

  switch (type) {
    case 'time':
    case 'beforePlay':
    case 'pause':
    case 'play':
    case 'ready':
      {
        var viewable = model.get('viewable'); // Don't add viewable to events if we don't know we're viewable

        if (viewable !== undefined) {
          // Emit viewable as 0 or 1
          newState = Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["extend"])({}, currentState, {
            viewable: viewable
          });
        }

        break;
      }

    default:
      {
        break;
      }
  }

  return newState;
}

/***/ }),

/***/ "./src/js/controller/instream-adapter.js":
/*!***********************************************!*\
  !*** ./src/js/controller/instream-adapter.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var utils_underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils/underscore */ "./src/js/utils/underscore.js");
/* harmony import */ var events_events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events/events */ "./src/js/events/events.ts");
/* harmony import */ var _program_program_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../program/program-constants */ "./src/js/program/program-constants.ts");
/* harmony import */ var utils_strings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! utils/strings */ "./src/js/utils/strings.ts");
/* harmony import */ var utils_backbone_events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! utils/backbone.events */ "./src/js/utils/backbone.events.ts");
/* harmony import */ var program_ad_program_controller__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! program/ad-program-controller */ "./src/js/program/ad-program-controller.js");









var _defaultOptions = {
  skipoffset: null,
  tag: null
};
/**
 * InstreamAdapter JW Player instream API. Instantiated via jwplayer().createInstream(). Only one instance can be
 * created per player. It is destroyed via jwplayer().instreamDestroy().
 * @param {Controller} _controller - The player controller instance
 * @param {Model} _model - The player model instance
 * @param {View} _view - The player view instance
 * @param {MediaPool} _mediaPool - The player media pool
 * @constructor
 */

var InstreamAdapter = function InstreamAdapter(_controller, _model, _view, _mediaPool) {
  var _this2 = this;

  var _this = this;

  var _adProgram = new program_ad_program_controller__WEBPACK_IMPORTED_MODULE_5__["default"](_model, _mediaPool);

  var _array;

  var _arrayOptions;

  var _arrayIndex = 0;
  var _data = {};
  var _detachPromise = null;
  var _options = {};
  var _skipAd = _instreamItemNext;
  var _backgroundLoadTriggered = false;

  var _skipOffset;

  var _backgroundLoadStart;

  var _destroyed = false;
  var _inited = false;
  var _beforeComplete = false;

  var _clickHandler = function _clickHandler(evt) {
    if (_destroyed) {
      return;
    }

    evt = evt || {};
    evt.hasControls = !!_model.get('controls');

    _this2.trigger(events_events__WEBPACK_IMPORTED_MODULE_1__["INSTREAM_CLICK"], evt); // toggle playback after click event


    if (_adProgram.model.get('state') === events_events__WEBPACK_IMPORTED_MODULE_1__["STATE_PAUSED"]) {
      if (evt.hasControls) {
        _adProgram.playVideo().catch(function () {});
      }
    } else {
      _adProgram.pause();
    }
  };

  var _doubleClickHandler = function _doubleClickHandler() {
    if (_destroyed) {
      return;
    }

    if (_adProgram.model.get('state') === events_events__WEBPACK_IMPORTED_MODULE_1__["STATE_PAUSED"]) {
      if (_model.get('controls')) {
        _controller.setFullscreen();

        _controller.play();
      }
    }
  };
  /**
   * Put the player in instream ads mode, detaching media, and preparing the ad program for
   * instream playback
   * @return {InstreamAdapter} - chainable
   */


  this.init = function () {
    if (_inited || _destroyed) {
      return;
    }

    _inited = true;
    _data = {}; // Keep track of the original player state

    _adProgram.setup();

    _adProgram.on('all', _instreamForward, this);

    _adProgram.on(events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_PLAY_ATTEMPT_FAILED"], triggerPlayRejected, this);

    _adProgram.on(events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_TIME"], _instreamTime, this);

    _adProgram.on(events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_COMPLETE"], _instreamItemComplete, this);

    _adProgram.on(events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_META"], _instreamMeta, this);

    _adProgram.on(events_events__WEBPACK_IMPORTED_MODULE_1__["PLAYER_STATE"], _handleStateChange, this); // Make sure the original player's provider stops broadcasting events (pseudo-lock...)


    _detachPromise = _controller.detachMedia();

    if (true) {
      var mediaElement = _adProgram.primedElement;

      var mediaContainer = _model.get('mediaContainer');

      mediaContainer.appendChild(mediaElement);
    } // This enters the player into instream mode


    _model.set('instream', _adProgram);

    _adProgram.model.set('state', events_events__WEBPACK_IMPORTED_MODULE_1__["STATE_BUFFERING"]); // don't trigger api play/pause on display click


    if (_view) {
      var clickHandler = _view.clickHandler();

      if (clickHandler) {
        clickHandler.setAlternateClickHandlers(function () {}, null);
      }
    }

    this.setText(_model.get('localization').loadingAd); // We need to know if we're beforeComplete before we reattach, since re-attaching will toggle the beforeComplete flag back if set

    _beforeComplete = _controller.isBeforeComplete() || _model.get('state') === events_events__WEBPACK_IMPORTED_MODULE_1__["STATE_COMPLETE"];
    return this;
  };
  /**
   * Put the player in SSAI ad mode. Detaches media listeners
   * to prevent player events from being triggered during a break.
   * @param {string} clickThroughUrl - Url to open on click while playing
   * @return {InstreamAdapter} - chainable
   */


  this.enableAdsMode = function (clickThroughUrl) {
    var _this3 = this;

    if (_inited || _destroyed) {
      return;
    } // Forward current provider events through instream


    _controller.routeEvents({
      mediaControllerListener: function mediaControllerListener(type, data) {
        _this3.trigger(type, data);
      }
    });

    _model.set('instream', _adProgram);

    _adProgram.model.set('state', events_events__WEBPACK_IMPORTED_MODULE_1__["STATE_PLAYING"]);

    _addClickHandler(clickThroughUrl);

    return this;
  };

  function _addClickHandler(clickThroughUrl) {
    if (!_view) {
      return;
    } // don't trigger api play/pause on display click


    var clickHandler = _view.clickHandler();

    if (clickHandler) {
      clickHandler.setAlternateClickHandlers(function (evt) {
        if (_destroyed) {
          return;
        }

        evt = evt || {};
        evt.hasControls = !!_model.get('controls');

        _this.trigger(events_events__WEBPACK_IMPORTED_MODULE_1__["INSTREAM_CLICK"], evt);

        if (clickThroughUrl) {
          if (_model.get('state') === events_events__WEBPACK_IMPORTED_MODULE_1__["STATE_PAUSED"]) {
            _controller.playVideo();
          } else {
            _controller.pause();

            if (clickThroughUrl) {
              _controller.trigger(events_events__WEBPACK_IMPORTED_MODULE_1__["AD_CLICK"], {
                clickThroughUrl: clickThroughUrl
              });

              window.open(clickThroughUrl);
            }
          }
        }
      }, null);
    }
  }

  function triggerPlayRejected() {
    _adProgram.model.set('playRejected', true);
  }

  function _loadNextItem() {
    _arrayIndex++;

    _this.loadItem(_array).catch(function () {});
  }

  function _instreamForward(type, data) {
    if (type === 'complete') {
      return;
    }

    data = data || {};

    if (_options.tag && !data.tag) {
      data.tag = _options.tag;
    }

    this.trigger(type, data);

    if (type === 'mediaError' || type === 'error') {
      this.loadNextItemOnError();
    }
  }

  function _handleStateChange(event) {
    var newstate = event.newstate;

    var oldstate = event.oldstate || _adProgram.model.get('state');

    if (oldstate !== newstate) {
      _triggerAdPlayPause(Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["extend"])({
        oldstate: oldstate
      }, _data, event));
    }
  }

  function _triggerAdPlayPause(event) {
    var newstate = event.newstate;

    if (newstate === events_events__WEBPACK_IMPORTED_MODULE_1__["STATE_PLAYING"]) {
      _controller.trigger(events_events__WEBPACK_IMPORTED_MODULE_1__["AD_PLAY"], event);
    } else if (newstate === events_events__WEBPACK_IMPORTED_MODULE_1__["STATE_PAUSED"]) {
      _controller.trigger(events_events__WEBPACK_IMPORTED_MODULE_1__["AD_PAUSE"], event);
    }
  }

  this.setEventData = function (data) {
    _data = data;
  };
  /**
   * Update instream player state. If `event.newstate` is 'playing' trigger an 'adPlay' event.
   * If `event.newstate` is 'paused' trigger and 'adPause' event.
   * @param {AdPlayEvent|AdPauseEvent} event - An ad event object containing relevant ad data.
   * @return {void}
   */


  this.setState = function (event) {
    var newstate = event.newstate;
    var adModel = _adProgram.model;
    event.oldstate = adModel.get('state');
    adModel.set('state', newstate);

    _triggerAdPlayPause(event);
  };
  /**
   * Update instream time and trigger 'adTime' event.
   * @param {AdTimeEvent} event - An ad event object containing relavant ad data.
   * @return {void}
   */


  this.setTime = function (event) {
    _instreamTime(event);

    _controller.trigger(events_events__WEBPACK_IMPORTED_MODULE_1__["AD_TIME"], event);
  };

  function _instreamTime(evt) {
    var duration = evt.duration,
        position = evt.position;
    var mediaModel = _adProgram.model.mediaModel || _adProgram.model;
    mediaModel.set('duration', duration);
    mediaModel.set('position', position); // Start background loading once the skip button is clickable
    // If no skipoffset is set, default to background loading 5 seconds before the end

    if (!_backgroundLoadStart) {
      // Ensure background loading doesn't degrade ad performance by starting too early
      _backgroundLoadStart = (Object(utils_strings__WEBPACK_IMPORTED_MODULE_3__["offsetToSeconds"])(_skipOffset, duration) || duration) - _program_program_constants__WEBPACK_IMPORTED_MODULE_2__["BACKGROUND_LOAD_OFFSET"];
    }

    if (!_backgroundLoadTriggered && position >= Math.max(_backgroundLoadStart, _program_program_constants__WEBPACK_IMPORTED_MODULE_2__["BACKGROUND_LOAD_MIN_OFFSET"])) {
      _controller.preloadNextItem();

      _backgroundLoadTriggered = true;
    }
  }

  function _instreamItemComplete(e) {
    var data = {};

    if (_options.tag) {
      data.tag = _options.tag;
    }

    this.trigger(events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_COMPLETE"], data);

    _instreamItemNext.call(this, e);
  }

  function _instreamItemNext(e) {
    _data = {};

    if (_array && _arrayIndex + 1 < _array.length) {
      _loadNextItem();
    } else {
      if (e.type === events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_COMPLETE"]) {
        // Dispatch playlist complete event for ad pods
        this.trigger(events_events__WEBPACK_IMPORTED_MODULE_1__["PLAYLIST_COMPLETE"], {});
      }

      this.destroy();
    }
  }
  /**
   * Called when an error occurs to load the next instream ad if it exists.
   * @return {void}
   */


  this.loadNextItemOnError = function () {
    if (_array && _arrayIndex + 1 < _array.length) {
      _loadNextItem();
    }
  };
  /**
   * Load an Item, playing it as an insteam ad.
   * @param {Item|Array.<Item>} item - The ad item or ad pod array of items to be played.
   * @param {Object|Array.<Object>} options - The ad options or ad pod array of options.
   * @return {Promise} - The ad playback promise.
   */


  this.loadItem = function (item, options) {
    if (_destroyed || !_inited) {
      return Promise.reject(new Error('Instream not setup'));
    }

    _data = {}; // Copy the playlist item passed in and make sure it's formatted as a proper playlist item

    var playlist = item;

    if (Array.isArray(item)) {
      _array = item;
      _arrayOptions = options || _arrayOptions;
      item = _array[_arrayIndex];

      if (_arrayOptions) {
        options = _arrayOptions[_arrayIndex];
      }
    } else {
      playlist = [item];
    }

    if (false) {}

    var adModel = _adProgram.model;
    adModel.set('playlist', playlist);

    _model.set('hideAdsControls', false); // Reset starttime so that if the same ad is replayed by a plugin, it reloads from the start


    item.starttime = 0; // Dispatch playlist item event for ad pods

    _this.trigger(events_events__WEBPACK_IMPORTED_MODULE_1__["PLAYLIST_ITEM"], {
      index: _arrayIndex,
      item: item
    });

    _options = Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["extend"])({}, _defaultOptions, options);

    _setDefaultClickHandler();

    adModel.set('skipButton', false); // Await detachment if video tag is shared.

    var playPromise = !_model.get('backgroundLoading') && _detachPromise ? _detachPromise.then(function () {
      return _adProgram.setActiveItem(_arrayIndex);
    }) : _adProgram.setActiveItem(_arrayIndex);
    _backgroundLoadTriggered = false; // Need to use item.skipoffset since _options is undefined for subsequent ads in pods

    _skipOffset = item.skipoffset || _options.skipoffset;

    if (_skipOffset !== undefined) {
      _this.setupSkipButton(_skipOffset, _options);
    }

    return playPromise;
  };
  /**
   * Add a skip button.
   * @param {Number} skipoffset - The number of seconds from the start where the ad becomes skippable.
   * @param {Object} options - Custom skip button text and message.
   * @param {function} [customNext] - The skip callback.
   * @return {void}
   */


  this.setupSkipButton = function (skipoffset, options, customNext) {
    var adModel = _adProgram.model;

    if (customNext) {
      _skipAd = customNext;
    } else {
      _skipAd = _instreamItemNext;
    }

    adModel.set('skipMessage', options.skipMessage);
    adModel.set('skipText', options.skipText);
    adModel.set('skipOffset', skipoffset);
    adModel.attributes.skipButton = false;
    adModel.set('skipButton', true);
  };
  /**
   * Attach the provider handling ad playback.
   * @param {Object} provider - The provider that will accept media commands and trigger media events.
   * @return {void}
   */


  this.applyProviderListeners = function (provider) {
    _adProgram.usePsuedoProvider(provider);

    _setDefaultClickHandler();
  };
  /**
   * Resume ad playback.
   * @return {void}
   */


  this.play = function () {
    _data = {};

    _adProgram.playVideo();
  };
  /**
   * Pause ad playback.
   * @return {void}
   */


  this.pause = function () {
    _data = {};

    _adProgram.pause();
  };

  function _setDefaultClickHandler() {
    if (_destroyed || !_view) {
      return;
    } // start listening for ad click


    if (_view.clickHandler()) {
      _view.clickHandler().setAlternateClickHandlers(_clickHandler, _doubleClickHandler);
    }
  }
  /**
   * Skip the current Ad.
   * @param {Object} event - The 'adSkipped' event object.
   * @return {void}
   */


  this.skipAd = function (event) {
    var autoPauseAds = _model.get('autoPause').pauseAds;

    var didAutostart = _model.get('playReason') === 'autostart';

    var viewable = _model.get('viewable');

    if (autoPauseAds && !didAutostart && !viewable) {
      // If autoPause.pauseAds is enabled and player is not viewable
      // when skipAd() is called, do not resume playback unless player
      // was autostarted out of view and never came in to view
      this.noResume = true;
    }

    var skipAdType = events_events__WEBPACK_IMPORTED_MODULE_1__["AD_SKIPPED"];
    this.trigger(skipAdType, event);

    _skipAd.call(this, {
      type: skipAdType
    });
  };

  function _instreamMeta(evt) {
    // If we're getting video dimension metadata from the provider, allow the view to resize the media
    if (evt.width && evt.height && _view) {
      _view.resizeMedia();
    }
  }
  /**
   * Replace the current playlist item, with a new source. Used with SSAI plugins.
   * @param {Item} item - The new playlist item.
   * @return {void}
   */


  this.replacePlaylistItem = function (item) {
    if (_destroyed) {
      return;
    }

    _model.set('playlistItem', item);

    _adProgram.srcReset();
  };
  /**
   * Destroy this instream instance, reattach media and resume playback.
   * @return {void}
   */


  this.destroy = function () {
    if (_destroyed) {
      return;
    }

    _destroyed = true;
    this.trigger('destroyed');
    this.off();

    if (_view && _view.clickHandler()) {
      _view.clickHandler().revertAlternateClickHandlers();
    }

    _model.off(null, null, _adProgram);

    _adProgram.off(null, null, _this);

    _adProgram.destroy(); // Force player state with ad to pause for model "change:state" events to trigger


    if (_inited && _adProgram.model) {
      _model.attributes.state = events_events__WEBPACK_IMPORTED_MODULE_1__["STATE_PAUSED"];
    }

    _controller.forwardEvents();

    _model.set('instream', null);

    _adProgram = null;
    _data = {};
    _detachPromise = null;

    if (!_inited || _model.attributes._destroyed) {
      return;
    } // Re-attach the controller & resume playback
    // when instream was inited and the player was not destroyed\


    _controller.attachMedia();

    if (this.noResume) {
      return;
    }

    if (_beforeComplete) {
      _controller.stopVideo();
    } else {
      _controller.playVideo();
    }
  };
  /**
   * Get the ad playback state. Returns false if destroyed.
   * @return {string|boolean} The ad player's playback state
   */


  this.getState = function () {
    if (_destroyed) {
      // api expects false to know we aren't in instreamMode
      return false;
    }

    return _adProgram.model.get('state');
  };
  /**
   * Update the ads mode controlbar message.
   * @param {string} text - The message to display in the controlbar.
   * @return {InstreamAdapter} - chainable
   */


  this.setText = function (text) {
    if (_destroyed || !_view) {
      return this;
    }

    _view.setAltText(text || '');

    return this;
  };
  /**
   * Hide the ads mode controls
   * @return {void}
   */


  this.hide = function () {
    if (_destroyed) {
      return;
    }

    _model.set('hideAdsControls', true);
  };
  /**
   * Extracts the video tag in the foreground.
   * @returns {Element|undefined} videoTag - the HTML <video> element in the foreground.
   */


  this.getMediaElement = function () {
    if (_destroyed) {
      return null;
    }

    return _adProgram.primedElement;
  };
  /**
   * Sets the internal skip offset used for preloading content. Does not setup the skip button.
   * @param {Number} skipOffset - The number of seconds from the start where the ad becomes skippable.
   * @returns {void}
   */


  this.setSkipOffset = function (skipOffset) {
    // IMA will pass -1 if it doesn't know the skipoffset, or if the ad is unskippable
    _skipOffset = skipOffset > 0 ? skipOffset : null;

    if (_adProgram) {
      _adProgram.model.set('skipOffset', _skipOffset);
    }
  };
};

Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["extend"])(InstreamAdapter.prototype, utils_backbone_events__WEBPACK_IMPORTED_MODULE_4__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (InstreamAdapter);

/***/ }),

/***/ "./src/js/controller/model.ts":
/*!************************************!*\
  !*** ./src/js/controller/model.ts ***!
  \************************************/
/*! exports provided: MediaModel, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MediaModel", function() { return MediaModel; });
/* harmony import */ var utils_underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils/underscore */ "./src/js/utils/underscore.js");
/* harmony import */ var environment_environment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! environment/environment */ "./src/js/environment/environment.ts");
/* harmony import */ var model_simplemodel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! model/simplemodel */ "./src/js/model/simplemodel.ts");
/* harmony import */ var model_player_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! model/player-model */ "./src/js/model/player-model.ts");
/* harmony import */ var events_events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! events/events */ "./src/js/events/events.ts");
/* harmony import */ var utils_strings__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! utils/strings */ "./src/js/utils/strings.ts");
/* harmony import */ var providers_providers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! providers/providers */ "./src/js/providers/providers.js");



function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }









// Represents the state of the player
var Model = /*#__PURE__*/function (_SimpleModel) {
  _inheritsLoose(Model, _SimpleModel);

  // These properties are assigned as attribute getters
  function Model() {
    var _this;

    _this = _SimpleModel.call(this) || this;
    _this.providerController = null;
    _this._provider = null;

    _this.addAttributes({
      mediaModel: new MediaModel(),
      minDvrWindow: model_player_model__WEBPACK_IMPORTED_MODULE_3__["DEFAULT_MIN_DVR_WINDOW"],
      dvrSeekLimit: model_player_model__WEBPACK_IMPORTED_MODULE_3__["DEFAULT_DVR_SEEK_LIMIT"]
    });

    return _this;
  }

  var _proto = Model.prototype;

  _proto.setup = function setup(config) {
    config = config || {};

    this._normalizeConfig(config);

    Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["extend"])(this.attributes, config, model_player_model__WEBPACK_IMPORTED_MODULE_3__["INITIAL_PLAYER_STATE"]);

    this.providerController = new providers_providers__WEBPACK_IMPORTED_MODULE_6__["default"](this.getConfiguration());
    this.setAutoStart();
    return this;
  };

  _proto.getConfiguration = function getConfiguration() {
    var config = this.clone();
    var mediaModelAttributes = config.mediaModel.attributes;
    Object.keys(model_player_model__WEBPACK_IMPORTED_MODULE_3__["INITIAL_MEDIA_STATE"]).forEach(function (key) {
      config[key] = mediaModelAttributes[key];
    });
    config.instreamMode = !!config.instream;
    delete config.instream;
    delete config.mediaModel;
    return config;
  };

  _proto.persistQualityLevel = function persistQualityLevel(quality, levels) {
    var currentLevel = levels[quality] || {};
    var label = currentLevel.label; // Default to null if bitrate is bad, or when the quality to persist is "auto" (bitrate is undefined in this case)

    var bitrate = Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["isValidNumber"])(currentLevel.bitrate) ? currentLevel.bitrate : null;
    this.set('bitrateSelection', bitrate);
    this.set('qualityLabel', label);
  };

  _proto.setActiveItem = function setActiveItem(index) {
    var item = this.get('playlist')[index];
    this.resetItem(item);
    this.attributes.playlistItem = null;
    this.set('item', index);
    this.set('minDvrWindow', item.minDvrWindow);
    this.set('dvrSeekLimit', item.dvrSeekLimit || model_player_model__WEBPACK_IMPORTED_MODULE_3__["DEFAULT_DVR_SEEK_LIMIT"]);
    this.set('playlistItem', item);
  };

  _proto.setMediaModel = function setMediaModel(mediaModel) {
    if (this.mediaModel && this.mediaModel !== mediaModel) {
      this.mediaModel.off();
    }

    mediaModel = mediaModel || new MediaModel();
    this.mediaModel = mediaModel;
    syncPlayerWithMediaModel(mediaModel);
  };

  _proto.destroy = function destroy() {
    this.attributes._destroyed = true;
    this.off();

    if (this._provider) {
      this._provider.off(null, null, this);

      this._provider.destroy();
    }
  };

  _proto.getVideo = function getVideo() {
    return this._provider;
  };

  _proto.setFullscreen = function setFullscreen(state) {
    state = !!state;

    if (state !== this.get('fullscreen')) {
      this.set('fullscreen', state);
    }
  };

  _proto.getProviders = function getProviders() {
    return this.providerController;
  };

  _proto.setVolume = function setVolume(volume) {
    if (!Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["isValidNumber"])(volume)) {
      return;
    }

    var vol = Math.min(Math.max(0, volume), 100);
    this.set('volume', vol);
    var mute = vol === 0;

    if (mute !== this.getMute()) {
      this.setMute(mute);
    }
  };

  _proto.getMute = function getMute() {
    return this.get('autostartMuted') || this.get('mute');
  };

  _proto.setMute = function setMute(mute) {
    if (mute === undefined) {
      mute = !this.getMute();
    }

    this.set('mute', !!mute);

    if (!mute) {
      var volume = Math.max(10, this.get('volume'));
      this.set('autostartMuted', false);
      this.setVolume(volume);
    }
  };

  _proto.setStreamType = function setStreamType(streamType) {
    this.set('streamType', streamType);

    if (streamType === 'LIVE') {
      this.setPlaybackRate(1);
    }
  };

  _proto.setProvider = function setProvider(provider) {
    this._provider = provider;
    syncProviderProperties(this, provider);
  };

  _proto.resetProvider = function resetProvider() {
    this._provider = null;
    this.set('provider', undefined);
  };

  _proto.setPlaybackRate = function setPlaybackRate(playbackRate) {
    if (!Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(playbackRate)) {
      return;
    } // Clamp the rate between 0.25x and 4x


    playbackRate = Math.max(Math.min(playbackRate, 4), 0.25);

    if (this.get('streamType') === 'LIVE') {
      playbackRate = 1;
    }

    this.set('defaultPlaybackRate', playbackRate);

    if (this._provider && this._provider.setPlaybackRate) {
      this._provider.setPlaybackRate(playbackRate);
    }
  };

  _proto.persistCaptionsTrack = function persistCaptionsTrack() {
    var track = this.get('captionsTrack');

    if (track) {
      // update preference if an option was selected
      this.set('captionLabel', track.name);
    } else {
      this.set('captionLabel', 'Off');
    }
  };

  _proto.setVideoSubtitleTrack = function setVideoSubtitleTrack(trackIndex, tracks) {
    this.set('captionsIndex', trackIndex);
    /*
     * Tracks could have changed even if the index hasn't.
     * Need to ensure track has data for captionsrenderer.
     */

    if (trackIndex && tracks && trackIndex <= tracks.length && tracks[trackIndex - 1].data) {
      this.set('captionsTrack', tracks[trackIndex - 1]);
    }
  };

  _proto.persistVideoSubtitleTrack = function persistVideoSubtitleTrack(trackIndex, tracks) {
    this.setVideoSubtitleTrack(trackIndex, tracks);
    this.persistCaptionsTrack();
  } // Mobile players always wait to become viewable.
  // Desktop players must have autostart set to viewable
  ;

  _proto.setAutoStart = function setAutoStart(autoStart) {
    if (autoStart !== undefined) {
      this.set('autostart', autoStart);
    }

    var autoStartOnMobile = !!(environment_environment__WEBPACK_IMPORTED_MODULE_1__["OS"].mobile && this.get('autostart'));
    this.set('playOnViewable', autoStartOnMobile || this.get('autostart') === 'viewable');
  };

  _proto.resetItem = function resetItem(item) {
    var position = item ? Object(utils_strings__WEBPACK_IMPORTED_MODULE_5__["seconds"])(item.starttime) : 0;
    var duration = item ? Object(utils_strings__WEBPACK_IMPORTED_MODULE_5__["seconds"])(item.duration) : 0;
    var mediaModel = this.mediaModel;
    this.set('playRejected', false);
    this.attributes.itemMeta = {};
    mediaModel.set('position', position);
    mediaModel.set('currentTime', 0);
    mediaModel.set('duration', duration);
  };

  _proto.persistBandwidthEstimate = function persistBandwidthEstimate(bwEstimate) {
    if (!Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["isValidNumber"])(bwEstimate)) {
      return;
    }

    this.set('bandwidthEstimate', bwEstimate);
  };

  _proto._normalizeConfig = function _normalizeConfig(cfg) {
    var floating = cfg.floating;

    if (floating && !!floating.disabled) {
      delete cfg.floating;
    }
  };

  return Model;
}(model_simplemodel__WEBPACK_IMPORTED_MODULE_2__["default"]);

var syncProviderProperties = function syncProviderProperties(model, provider) {
  model.set('provider', provider.getName());

  if (model.get('instreamMode') === true) {
    provider.instreamMode = true;
  } // Attempt setting the playback rate to be the user selected value


  model.setPlaybackRate(model.get('defaultPlaybackRate')); // Set playbackRate because provider support for playbackRate may have changed and not sent an update

  model.set('supportsPlaybackRate', provider.supportsPlaybackRate);
  model.set('playbackRate', provider.getPlaybackRate());
  model.set('renderCaptionsNatively', provider.renderNatively);
};

function syncPlayerWithMediaModel(mediaModel) {
  // Sync player state with mediaModel state
  var mediaState = mediaModel.get('mediaState');
  mediaModel.trigger('change:mediaState', mediaModel, mediaState, mediaState);
}

// Represents the state of the provider/media element
var MediaModel = /*#__PURE__*/function (_SimpleModel2) {
  _inheritsLoose(MediaModel, _SimpleModel2);

  function MediaModel() {
    var _this2;

    _this2 = _SimpleModel2.call(this) || this;

    _this2.addAttributes({
      mediaState: events_events__WEBPACK_IMPORTED_MODULE_4__["STATE_IDLE"]
    });

    return _this2;
  }

  var _proto2 = MediaModel.prototype;

  _proto2.srcReset = function srcReset() {
    Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["extend"])(this.attributes, {
      setup: false,
      started: false,
      preloaded: false,
      visualQuality: null,
      buffer: 0,
      currentTime: 0
    });
  };

  return MediaModel;
}(model_simplemodel__WEBPACK_IMPORTED_MODULE_2__["default"]);


/* harmony default export */ __webpack_exports__["default"] = (Model);

/***/ }),

/***/ "./src/js/controller/qoe.ts":
/*!**********************************!*\
  !*** ./src/js/controller/qoe.ts ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var events_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events/events */ "./src/js/events/events.ts");
/* harmony import */ var api_timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! api/timer */ "./src/js/api/timer.ts");
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }



var TAB_HIDDEN = 'tabHidden';
var TAB_VISIBLE = 'tabVisible';

var QoeItem = /*#__PURE__*/function (_Timer) {
  _inheritsLoose(QoeItem, _Timer);

  function QoeItem() {
    return _Timer.apply(this, arguments) || this;
  }

  var _proto = QoeItem.prototype;

  _proto.getFirstFrame = function getFirstFrame() {
    var time = this.between(events_events__WEBPACK_IMPORTED_MODULE_0__["MEDIA_PLAY_ATTEMPT"], events_events__WEBPACK_IMPORTED_MODULE_0__["MEDIA_FIRST_FRAME"]); // If time between the tab becoming visible and first frame is valid
    // and less than the time since play attempt, play was not attempted until the tab became visible

    var timeActive = this.between(TAB_VISIBLE, events_events__WEBPACK_IMPORTED_MODULE_0__["MEDIA_FIRST_FRAME"]);

    if (timeActive && time && timeActive > 0 && timeActive < time) {
      return timeActive;
    }

    return time;
  };

  return QoeItem;
}(api_timer__WEBPACK_IMPORTED_MODULE_1__["default"]); // This is to provide a first frame event even when
//  a provider does not give us one.


var onTimeIncreasesGenerator = function onTimeIncreasesGenerator(callback) {
  var lastVal = 0;
  return function (evt) {
    var pos = evt.position;

    if (pos > lastVal) {
      callback(evt);
    } // sometimes the number will wrap around (ie 100 down to 0)
    //  so always update


    lastVal = pos;
  };
};

function unbindFirstFrameEvents(model, programController) {
  programController.off(events_events__WEBPACK_IMPORTED_MODULE_0__["MEDIA_PLAY_ATTEMPT"], model._onPlayAttempt);
  programController.off(events_events__WEBPACK_IMPORTED_MODULE_0__["PROVIDER_FIRST_FRAME"], model._triggerFirstFrame);
  programController.off(events_events__WEBPACK_IMPORTED_MODULE_0__["MEDIA_TIME"], model._onTime);
  model.off('change:activeTab', model._onTabVisible);
}

function trackFirstFrame(model, programController) {
  if (model._onTabVisible) {
    unbindFirstFrameEvents(model, programController);
  } // When it occurs, send the event, and unbind all listeners


  var once = false;

  model._triggerFirstFrame = function (evt) {
    if (once || !programController.mediaController) {
      return;
    } // Only trigger firstFrame while playing or paused or providerFirstFrame
    // (ignores "time" events while loading/stalling/idle/complete)


    var mediaModel = programController.mediaController.mediaModel;
    var state = mediaModel.attributes.mediaState;

    if (state !== events_events__WEBPACK_IMPORTED_MODULE_0__["STATE_PLAYING"] && state !== events_events__WEBPACK_IMPORTED_MODULE_0__["STATE_PAUSED"] && evt.type !== events_events__WEBPACK_IMPORTED_MODULE_0__["PROVIDER_FIRST_FRAME"]) {
      return;
    }

    once = true;
    var qoeItem = model._qoeItem;
    qoeItem.tick(events_events__WEBPACK_IMPORTED_MODULE_0__["MEDIA_FIRST_FRAME"]);
    var time = qoeItem.getFirstFrame();
    programController.trigger(events_events__WEBPACK_IMPORTED_MODULE_0__["MEDIA_FIRST_FRAME"], {
      loadTime: time
    }); // Start firing visualQuality once playback has started

    mediaModel.off("change:" + events_events__WEBPACK_IMPORTED_MODULE_0__["MEDIA_VISUAL_QUALITY"], null, mediaModel);
    mediaModel.change(events_events__WEBPACK_IMPORTED_MODULE_0__["MEDIA_VISUAL_QUALITY"], function (changedMediaModel, eventData) {
      if (eventData) {
        programController.trigger(events_events__WEBPACK_IMPORTED_MODULE_0__["MEDIA_VISUAL_QUALITY"], eventData);
      }
    }, mediaModel);
    unbindFirstFrameEvents(model, programController);
  };

  model._onTime = onTimeIncreasesGenerator(model._triggerFirstFrame);

  model._onPlayAttempt = function () {
    model._qoeItem.tick(events_events__WEBPACK_IMPORTED_MODULE_0__["MEDIA_PLAY_ATTEMPT"]);
  }; // track visibility change


  model._onTabVisible = function (modelChanged, activeTab) {
    if (activeTab) {
      model._qoeItem.tick(TAB_VISIBLE);
    } else {
      model._qoeItem.tick(TAB_HIDDEN);
    }
  };

  model.on('change:activeTab', model._onTabVisible);
  programController.on(events_events__WEBPACK_IMPORTED_MODULE_0__["MEDIA_PLAY_ATTEMPT"], model._onPlayAttempt);
  programController.once(events_events__WEBPACK_IMPORTED_MODULE_0__["PROVIDER_FIRST_FRAME"], model._triggerFirstFrame);
  programController.on(events_events__WEBPACK_IMPORTED_MODULE_0__["MEDIA_TIME"], model._onTime);
}

var initQoe = function initQoe(initialModel, programController) {
  function onMediaModel(model, mediaModel, oldMediaModel) {
    // finish previous item
    if (model._qoeItem && oldMediaModel) {
      model._qoeItem.end(oldMediaModel.get('mediaState'));
    } // reset item level qoe


    model._qoeItem = new QoeItem();

    model._qoeItem.tick(events_events__WEBPACK_IMPORTED_MODULE_0__["PLAYLIST_ITEM"]);

    model._qoeItem.start(mediaModel.get('mediaState'));

    trackFirstFrame(model, programController);
    mediaModel.on('change:mediaState', function (changeMediaModel, newstate, oldstate) {
      if (newstate !== oldstate) {
        model._qoeItem.end(oldstate);

        model._qoeItem.start(newstate);
      }
    });
  }

  initialModel.change('mediaModel', onMediaModel);
};

/* harmony default export */ __webpack_exports__["default"] = (initQoe);

/***/ }),

/***/ "./src/js/controller/tracks-helper.ts":
/*!********************************************!*\
  !*** ./src/js/controller/tracks-helper.ts ***!
  \********************************************/
/*! exports provided: createId, createLabel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createId", function() { return createId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createLabel", function() { return createLabel; });
function createId(track, tracksCount) {
  var trackId;
  var prefix = track.kind || 'cc';

  if (track.default || track.defaulttrack) {
    trackId = 'default';
  } else {
    trackId = track._id || track.file || prefix + tracksCount;
  }

  return trackId;
}
function createLabel(track, unknownCount) {
  var label = track.label || track.name || track.language;

  if (!label) {
    label = 'Unknown CC';
    unknownCount += 1;

    if (unknownCount > 1) {
      label += ' [' + unknownCount + ']';
    }
  }

  return {
    label: label,
    unknownCount: unknownCount
  };
}

/***/ }),

/***/ "./src/js/controller/tracks-loader.ts":
/*!********************************************!*\
  !*** ./src/js/controller/tracks-loader.ts ***!
  \********************************************/
/*! exports provided: loadFile, cancelXhr */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadFile", function() { return loadFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cancelXhr", function() { return cancelXhr; });
/* harmony import */ var parsers_captions_vttcue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! parsers/captions/vttcue */ "./src/js/parsers/captions/vttcue.js");
/* harmony import */ var _api_core_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api/core-loader */ "./src/js/api/core-loader.js");
/* harmony import */ var utils_ajax__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! utils/ajax */ "./src/js/utils/ajax.js");
/* harmony import */ var parsers_parsers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! parsers/parsers */ "./src/js/parsers/parsers.ts");
/* harmony import */ var parsers_captions_srt__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! parsers/captions/srt */ "./src/js/parsers/captions/srt.ts");
/* harmony import */ var parsers_captions_dfxp__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! parsers/captions/dfxp */ "./src/js/parsers/captions/dfxp.ts");
/* harmony import */ var api_errors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! api/errors */ "./src/js/api/errors.ts");







function loadFile(track, successHandler, errorHandler) {
  track.xhr = Object(utils_ajax__WEBPACK_IMPORTED_MODULE_2__["ajax"])(track.file, function (xhr) {
    xhrSuccess(xhr, track, successHandler, errorHandler);
  }, function (key, url, xhr, error) {
    errorHandler(Object(api_errors__WEBPACK_IMPORTED_MODULE_6__["composePlayerError"])(error, api_errors__WEBPACK_IMPORTED_MODULE_6__["ERROR_LOADING_CAPTIONS"]));
  });
}
function cancelXhr(tracks) {
  if (tracks) {
    tracks.forEach(function (track) {
      var xhr = track.xhr;

      if (xhr) {
        xhr.onload = null;
        xhr.onreadystatechange = null;
        xhr.onerror = null;

        if ('abort' in xhr) {
          xhr.abort();
        }
      }

      delete track.xhr;
    });
  }
}

function convertToVTTCues(cues) {
  // VTTCue is available natively or polyfilled where necessary
  return cues.map(function (cue) {
    return new parsers_captions_vttcue__WEBPACK_IMPORTED_MODULE_0__["default"](cue.begin, cue.end, cue.text);
  });
}

function xhrSuccess(xhr, track, successHandler, errorHandler) {
  var xmlRoot = xhr.responseXML ? xhr.responseXML.firstChild : null;
  var cues;
  var vttCues; // IE9 sets the firstChild element to the root <xml> tag

  if (xmlRoot) {
    if (Object(parsers_parsers__WEBPACK_IMPORTED_MODULE_3__["localName"])(xmlRoot) === 'xml') {
      xmlRoot = xmlRoot.nextSibling;
    } // Ignore all comments


    while (xmlRoot && xmlRoot.nodeType === xmlRoot.COMMENT_NODE) {
      xmlRoot = xmlRoot.nextSibling;
    }
  }

  try {
    if (xmlRoot && Object(parsers_parsers__WEBPACK_IMPORTED_MODULE_3__["localName"])(xmlRoot) === 'tt') {
      // parse dfxp track
      if (!xhr.responseXML) {
        throw new Error('Empty XML response');
      }

      cues = Object(parsers_captions_dfxp__WEBPACK_IMPORTED_MODULE_5__["default"])(xhr.responseXML);
      vttCues = convertToVTTCues(cues);
      delete track.xhr;
      successHandler(vttCues);
    } else {
      // parse VTT/SRT track
      var responseText = xhr.responseText;

      if (responseText.indexOf('WEBVTT') >= 0) {
        // make VTTCues from VTT track
        loadVttParser().then(function (VttParser) {
          var parser = new VttParser(window);
          vttCues = [];

          parser.oncue = function (cue) {
            vttCues.push(cue);
          };

          parser.onflush = function () {
            delete track.xhr;
            successHandler(vttCues);
          }; // Parse calls onflush internally


          parser.parse(responseText);
        }).catch(function (error) {
          delete track.xhr;
          errorHandler(Object(api_errors__WEBPACK_IMPORTED_MODULE_6__["convertToPlayerError"])(null, api_errors__WEBPACK_IMPORTED_MODULE_6__["ERROR_LOADING_CAPTIONS"], error));
        });
      } else {
        // make VTTCues from SRT track
        cues = Object(parsers_captions_srt__WEBPACK_IMPORTED_MODULE_4__["default"])(responseText);
        vttCues = convertToVTTCues(cues);
        delete track.xhr;
        successHandler(vttCues);
      }
    }
  } catch (error) {
    delete track.xhr;
    errorHandler(Object(api_errors__WEBPACK_IMPORTED_MODULE_6__["convertToPlayerError"])(null, api_errors__WEBPACK_IMPORTED_MODULE_6__["ERROR_LOADING_CAPTIONS"], error));
  }
}

function loadVttParser() {
  // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
  // @ts-ignore
  return __webpack_require__.e(/*! require.ensure | vttparser */ "vttparser").then((function (require) {
    return __webpack_require__(/*! parsers/captions/vttparser */ "./src/js/parsers/captions/vttparser.js").default;
  }).bind(null, __webpack_require__)).catch(Object(_api_core_loader__WEBPACK_IMPORTED_MODULE_1__["chunkLoadWarningHandler"])(301131));
}

/***/ }),

/***/ "./src/js/events/change-state-event.ts":
/*!*********************************************!*\
  !*** ./src/js/events/change-state-event.ts ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ChangeStateEvent; });
/* harmony import */ var events_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events/events */ "./src/js/events/events.ts");


// The api should dispatch an idle event when the model's state changes to complete
// This is to avoid conflicts with the complete event and to maintain legacy event flow
function normalizeApiState(newstate) {
  if (newstate === events_events__WEBPACK_IMPORTED_MODULE_0__["STATE_COMPLETE"] || newstate === events_events__WEBPACK_IMPORTED_MODULE_0__["STATE_ERROR"]) {
    return events_events__WEBPACK_IMPORTED_MODULE_0__["STATE_IDLE"];
  }

  return newstate;
}

function normalizeReason(newstate, reason) {
  if (newstate === events_events__WEBPACK_IMPORTED_MODULE_0__["STATE_BUFFERING"]) {
    return reason === events_events__WEBPACK_IMPORTED_MODULE_0__["STATE_STALLED"] ? reason : events_events__WEBPACK_IMPORTED_MODULE_0__["STATE_LOADING"];
  }

  return reason;
}

function ChangeStateEvent(model, newstate, oldstate) {
  newstate = normalizeApiState(newstate);
  oldstate = normalizeApiState(oldstate); // do not dispatch idle a second time after complete

  if (newstate !== oldstate) {
    // buffering, playing and paused states become:
    // buffer, play and pause events
    var type = newstate.replace(/(?:ing|d)$/, '');
    var reason = normalizeReason(newstate, model.mediaModel.get('mediaState'));
    var evt = {
      type: type,
      newstate: newstate,
      oldstate: oldstate,
      reason: reason
    }; // add reason for play/pause events

    if (type === 'play') {
      evt.playReason = model.get('playReason');
    } else if (type === 'pause') {
      evt.pauseReason = model.get('pauseReason');
    }

    this.trigger(type, evt);
  }
}

/***/ }),

/***/ "./src/js/parsers/captions/dfxp.ts":
/*!*****************************************!*\
  !*** ./src/js/parsers/captions/dfxp.ts ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Dfxp; });
/* harmony import */ var utils_strings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils/strings */ "./src/js/utils/strings.ts");
/* harmony import */ var api_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! api/errors */ "./src/js/api/errors.ts");


function Dfxp(xmlDoc) {
  if (!xmlDoc) {
    parseError(306007);
  }

  var _captions = [];
  var paragraphs = xmlDoc.getElementsByTagName('p'); // Default frameRate is 30

  var frameRate = 30;
  var tt = xmlDoc.getElementsByTagName('tt');

  if (tt && tt[0]) {
    var parsedFrameRate = parseFloat(tt[0].getAttribute('ttp:frameRate') || '');

    if (!isNaN(parsedFrameRate)) {
      frameRate = parsedFrameRate;
    }
  }

  if (!paragraphs) {
    parseError(306005);
  }

  if (!paragraphs.length) {
    paragraphs = xmlDoc.getElementsByTagName('tt:p');

    if (!paragraphs.length) {
      paragraphs = xmlDoc.getElementsByTagName('tts:p');
    }
  }

  for (var i = 0; i < paragraphs.length; i++) {
    var p = paragraphs[i];
    var breaks = p.getElementsByTagName('br');

    for (var j = 0; j < breaks.length; j++) {
      var b = breaks[j];

      if (b && b.parentNode) {
        b.parentNode.replaceChild(xmlDoc.createTextNode('\r\n'), b);
      }
    }

    var rawText = p.innerHTML || p.textContent || p.text || '';
    var text = Object(utils_strings__WEBPACK_IMPORTED_MODULE_0__["trim"])(rawText).replace(/>\s+</g, '><').replace(/(<\/?)tts?:/g, '$1').replace(/<br.*?\/>/g, '\r\n');

    if (text) {
      var begin = p.getAttribute('begin') || '';
      var dur = p.getAttribute('dur') || '';
      var end = p.getAttribute('end') || '';
      var entry = {
        begin: Object(utils_strings__WEBPACK_IMPORTED_MODULE_0__["seconds"])(begin, frameRate),
        text: text
      };

      if (end) {
        entry.end = Object(utils_strings__WEBPACK_IMPORTED_MODULE_0__["seconds"])(end, frameRate);
      } else if (dur) {
        entry.end = (entry.begin || 0) + Object(utils_strings__WEBPACK_IMPORTED_MODULE_0__["seconds"])(dur, frameRate);
      }

      _captions.push(entry);
    }
  }

  if (!_captions.length) {
    parseError(306005);
  }

  return _captions;
}

function parseError(code) {
  throw new api_errors__WEBPACK_IMPORTED_MODULE_1__["PlayerError"](null, code);
}

/***/ }),

/***/ "./src/js/parsers/captions/srt.ts":
/*!****************************************!*\
  !*** ./src/js/parsers/captions/srt.ts ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Srt; });
/* harmony import */ var utils_strings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils/strings */ "./src/js/utils/strings.ts");

// Component that loads and parses an SRT file
function Srt(data) {
  // Trim whitespace and split the list by returns.
  var _captions = [];
  data = Object(utils_strings__WEBPACK_IMPORTED_MODULE_0__["trim"])(data);
  var list = data.split('\r\n\r\n');

  if (list.length === 1) {
    list = data.split('\n\n');
  }

  for (var i = 0; i < list.length; i++) {
    if (list[i] === 'WEBVTT') {
      continue;
    } // Parse each entry


    var entry = _entry(list[i]);

    if (entry.text) {
      _captions.push(entry);
    }
  }

  return _captions;
}
/* Parse a single captions entry. */

function _entry(data) {
  var entry = {};
  var array = data.split('\r\n');

  if (array.length === 1) {
    array = data.split('\n');
  }

  var idx = 1;

  if (array[0].indexOf(' --> ') > 0) {
    idx = 0;
  }

  if (array.length > idx + 1 && array[idx + 1]) {
    // This line contains the start and end.
    var line = array[idx];
    var index = line.indexOf(' --> ');

    if (index > 0) {
      entry.begin = Object(utils_strings__WEBPACK_IMPORTED_MODULE_0__["seconds"])(line.substr(0, index));
      entry.end = Object(utils_strings__WEBPACK_IMPORTED_MODULE_0__["seconds"])(line.substr(index + 5)); // Remaining lines contain the text

      entry.text = array.slice(idx + 1).join('\r\n');
    }
  }

  return entry;
}

/***/ }),

/***/ "./src/js/parsers/captions/vttcue.js":
/*!*******************************************!*\
  !*** ./src/js/parsers/captions/vttcue.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/
var VTTCue = window.VTTCue;

function findDirectionSetting(value) {
  if (typeof value !== 'string') {
    return false;
  }

  var directionSetting = {
    '': true,
    lr: true,
    rl: true
  };
  var dir = directionSetting[value.toLowerCase()];
  return dir ? value.toLowerCase() : false;
}

function findAlignSetting(value) {
  if (typeof value !== 'string') {
    return false;
  }

  var alignSetting = {
    start: true,
    middle: true,
    end: true,
    left: true,
    right: true
  };
  var align = alignSetting[value.toLowerCase()];
  return align ? value.toLowerCase() : false;
}

if (!VTTCue) {
  var autoKeyword = 'auto';

  VTTCue = function VTTCue(startTime, endTime, text) {
    var cue = this;
    /**
     * Shim implementation specific properties. These properties are not in
     * the spec.
     */
    // Lets us know when the VTTCue's data has changed in such a way that we need
    // to recompute its display state. This lets us compute its display state
    // lazily.

    cue.hasBeenReset = false;
    /**
     * VTTCue and TextTrackCue properties
     * http://dev.w3.org/html5/webvtt/#vttcue-interface
     */

    var _id = '';
    var _pauseOnExit = false;
    var _startTime = startTime;
    var _endTime = endTime;
    var _text = text;
    var _region = null;
    var _vertical = '';
    var _snapToLines = true;
    var _line = autoKeyword;
    var _lineAlign = 'start';
    var _position = autoKeyword;
    var _size = 100;
    var _align = 'middle';
    Object.defineProperty(cue, 'id', {
      enumerable: true,
      get: function get() {
        return _id;
      },
      set: function set(value) {
        _id = '' + value;
      }
    });
    Object.defineProperty(cue, 'pauseOnExit', {
      enumerable: true,
      get: function get() {
        return _pauseOnExit;
      },
      set: function set(value) {
        _pauseOnExit = !!value;
      }
    });
    Object.defineProperty(cue, 'startTime', {
      enumerable: true,
      get: function get() {
        return _startTime;
      },
      set: function set(value) {
        if (typeof value !== 'number') {
          throw new TypeError('Start time must be set to a number.');
        }

        _startTime = value;
        this.hasBeenReset = true;
      }
    });
    Object.defineProperty(cue, 'endTime', {
      enumerable: true,
      get: function get() {
        return _endTime;
      },
      set: function set(value) {
        if (typeof value !== 'number') {
          throw new TypeError('End time must be set to a number.');
        }

        _endTime = value;
        this.hasBeenReset = true;
      }
    });
    Object.defineProperty(cue, 'text', {
      enumerable: true,
      get: function get() {
        return _text;
      },
      set: function set(value) {
        _text = '' + value;
        this.hasBeenReset = true;
      }
    });
    Object.defineProperty(cue, 'region', {
      enumerable: true,
      get: function get() {
        return _region;
      },
      set: function set(value) {
        _region = value;
        this.hasBeenReset = true;
      }
    });
    Object.defineProperty(cue, 'vertical', {
      enumerable: true,
      get: function get() {
        return _vertical;
      },
      set: function set(value) {
        var setting = findDirectionSetting(value); // Have to check for false because the setting an be an empty string.

        if (setting === false) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }

        _vertical = setting;
        this.hasBeenReset = true;
      }
    });
    Object.defineProperty(cue, 'snapToLines', {
      enumerable: true,
      get: function get() {
        return _snapToLines;
      },
      set: function set(value) {
        _snapToLines = !!value;
        this.hasBeenReset = true;
      }
    });
    Object.defineProperty(cue, 'line', {
      enumerable: true,
      get: function get() {
        return _line;
      },
      set: function set(value) {
        if (typeof value !== 'number' && value !== autoKeyword) {
          throw new SyntaxError('An invalid number or illegal string was specified.');
        }

        _line = value;
        this.hasBeenReset = true;
      }
    });
    Object.defineProperty(cue, 'lineAlign', {
      enumerable: true,
      get: function get() {
        return _lineAlign;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);

        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }

        _lineAlign = setting;
        this.hasBeenReset = true;
      }
    });
    Object.defineProperty(cue, 'position', {
      enumerable: true,
      get: function get() {
        return _position;
      },
      set: function set(value) {
        if (value < 0 || value > 100) {
          throw new Error('Position must be between 0 and 100.');
        }

        _position = value;
        this.hasBeenReset = true;
      }
    });
    Object.defineProperty(cue, 'size', {
      enumerable: true,
      get: function get() {
        return _size;
      },
      set: function set(value) {
        if (value < 0 || value > 100) {
          throw new Error('Size must be between 0 and 100.');
        }

        _size = value;
        this.hasBeenReset = true;
      }
    });
    Object.defineProperty(cue, 'align', {
      enumerable: true,
      get: function get() {
        return _align;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);

        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }

        _align = setting;
        this.hasBeenReset = true;
      }
    });
    /**
     * Other <track> spec defined properties
     */
    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state

    cue.displayState = undefined;
  };
  /**
   * VTTCue methods
   */


  VTTCue.prototype.getCueAsHTML = function () {
    // Assume WebVTT.convertCueToDOMTree is on the global.
    var WebVTT = window.WebVTT;
    return WebVTT.convertCueToDOMTree(window, this.text);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (VTTCue);

/***/ }),

/***/ "./src/js/program/ad-program-controller.js":
/*!*************************************************!*\
  !*** ./src/js/program/ad-program-controller.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AdProgramController; });
/* harmony import */ var utils_underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils/underscore */ "./src/js/utils/underscore.js");
/* harmony import */ var events_events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events/events */ "./src/js/events/events.ts");
/* harmony import */ var program_program_controller__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! program/program-controller */ "./src/js/program/program-controller.js");
/* harmony import */ var controller_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! controller/model */ "./src/js/controller/model.ts");
/* harmony import */ var events_change_state_event__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! events/change-state-event */ "./src/js/events/change-state-event.ts");
/* harmony import */ var program_shared_media_pool__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! program/shared-media-pool */ "./src/js/program/shared-media-pool.ts");


function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }







var AdProgramController = /*#__PURE__*/function (_ProgramController) {
  _inheritsLoose(AdProgramController, _ProgramController);

  function AdProgramController(model, mediaPool) {
    var _this;

    _this = _ProgramController.call(this, model, mediaPool) || this;
    var adModel = _this.model = new controller_model__WEBPACK_IMPORTED_MODULE_3__["default"]();
    _this.playerModel = model;
    _this.provider = null;
    _this.backgroundLoading = model.get('backgroundLoading');
    adModel.mediaModel.attributes.mediaType = 'video';

    if (true) {
      // Ad plugins must use only one element, and must use the same element during playback of an item
      // (i.e. prerolls, midrolls, and postrolls must use the same tag)
      var mediaElement;

      if (_this.backgroundLoading) {
        mediaElement = mediaPool.getAdElement();
      } else {
        // Take the tag that we're using to play the current item. The tag has been freed before reaching this point
        mediaElement = model.get('mediaElement');
        adModel.attributes.mediaElement = mediaElement;
        adModel.attributes.mediaSrc = mediaElement.src; // Listen to media element for events that indicate src was reset or load() was called

        var srcResetListener = _this.srcResetListener = function () {
          _this.srcReset();
        };

        mediaElement.addEventListener('emptied', srcResetListener);
        mediaElement.playbackRate = mediaElement.defaultPlaybackRate = 1;
      }

      _this.mediaPool = Object(program_shared_media_pool__WEBPACK_IMPORTED_MODULE_5__["default"])(mediaElement, mediaPool);
    }

    return _this;
  }

  var _proto = AdProgramController.prototype;

  _proto.setup = function setup() {
    var model = this.model,
        playerModel = this.playerModel,
        primedElement = this.primedElement;
    var playerAttributes = playerModel.attributes;
    var mediaModelContext = playerModel.mediaModel;
    model.setup({
      id: playerAttributes.id,
      volume: playerAttributes.volume,
      instreamMode: true,
      edition: playerAttributes.edition,
      mediaContext: mediaModelContext,
      mute: playerAttributes.mute,
      streamType: 'VOD',
      autostartMuted: playerAttributes.autostartMuted,
      autostart: playerAttributes.autostart,
      advertising: playerAttributes.advertising,
      sdkplatform: playerAttributes.sdkplatform,
      skipButton: false
    });
    model.on('change:state', events_change_state_event__WEBPACK_IMPORTED_MODULE_4__["default"], this);
    model.on(events_events__WEBPACK_IMPORTED_MODULE_1__["ERROR"], function (data) {
      this.trigger(events_events__WEBPACK_IMPORTED_MODULE_1__["ERROR"], data);
    }, this);

    if (true) {
      if (!primedElement.paused) {
        primedElement.pause();
      }
    }
  };

  _proto.setActiveItem = function setActiveItem(index) {
    var _this2 = this;

    this.stopVideo();
    this.provider = null;
    return _ProgramController.prototype.setActiveItem.call(this, index).then(function (mediaController) {
      _this2.trigger(events_events__WEBPACK_IMPORTED_MODULE_1__["AD_MEDIA_LOADED"]);

      _this2._setProvider(mediaController.provider);

      return _this2.playVideo();
    });
  };

  _proto.usePsuedoProvider = function usePsuedoProvider(provider) {
    if (!provider) {
      return;
    }

    this._setProvider(provider); // Match the main player's controls state


    provider.off(events_events__WEBPACK_IMPORTED_MODULE_1__["ERROR"]);
    provider.on(events_events__WEBPACK_IMPORTED_MODULE_1__["ERROR"], function (data) {
      this.trigger(events_events__WEBPACK_IMPORTED_MODULE_1__["ERROR"], data);
    }, this);
  };

  _proto._setProvider = function _setProvider(provider) {
    var _this3 = this;

    // Clear current provider when applyProviderListeners(null) is called
    if (!provider || !this.mediaPool) {
      return;
    }

    this.provider = provider;
    var model = this.model,
        playerModel = this.playerModel;
    var isVpaidProvider = provider.type === 'vpaid';
    provider.off();
    provider.on('all', function (type, data) {
      if (isVpaidProvider && type === events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_COMPLETE"]) {
        return;
      }

      this.trigger(type, Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["extend"])({}, data, {
        type: type
      }));
    }, this);
    var adMediaModelContext = model.mediaModel;
    provider.on(events_events__WEBPACK_IMPORTED_MODULE_1__["PLAYER_STATE"], function (event) {
      event.oldstate = event.oldstate || model.get(events_events__WEBPACK_IMPORTED_MODULE_1__["PLAYER_STATE"]);
      adMediaModelContext.set('mediaState', event.newstate);
    });
    provider.on(events_events__WEBPACK_IMPORTED_MODULE_1__["NATIVE_FULLSCREEN"], this._nativeFullscreenHandler, this);
    adMediaModelContext.on('change:mediaState', function (changeAdModel, state) {
      _this3._stateHandler(state);
    });
    provider.attachMedia();

    if (false) { var mediaContainer; }

    provider.volume(playerModel.get('volume'));
    provider.mute(playerModel.getMute());

    if (provider.setPlaybackRate) {
      provider.setPlaybackRate(1);
    }

    playerModel.on('change:volume', function (data, value) {
      this.volume = value;
    }, this);
    playerModel.on('change:mute', function (data, mute) {
      this.mute = mute;

      if (!mute) {
        this.volume = playerModel.get('volume');
      }
    }, this);
    playerModel.on('change:autostartMuted', function (data, value) {
      if (!value) {
        model.set('autostartMuted', value);
        this.mute = playerModel.get('mute');
      }
    }, this);
  };

  _proto.destroy = function destroy() {
    var mediaController = this.mediaController,
        model = this.model,
        mediaPool = this.mediaPool,
        playerModel = this.playerModel;
    model.off();

    if (false) {} // Do not destroy or remove provider event listeners since non-linear ads may continue to run after this point


    this.provider = null; // We only use one media element from ads; getPrimedElement will return it

    var mediaElement = mediaPool.getPrimedElement();

    if (!this.backgroundLoading) {
      if (mediaElement) {
        mediaElement.removeEventListener('emptied', this.srcResetListener); // Reset the player media model if the src was changed externally

        if (mediaElement.src !== model.get('mediaSrc')) {
          this.srcReset();
        }
      }
    } else {
      mediaPool.clean();
      var mediaContainer = playerModel.get('mediaContainer');

      if (mediaElement.parentNode === mediaContainer) {
        mediaContainer.removeChild(mediaElement);
      }
    }
  };

  _proto.srcReset = function srcReset() {
    var playerModel = this.playerModel;
    var mediaModel = playerModel.get('mediaModel');
    var provider = playerModel.getVideo();
    mediaModel.srcReset(); // Set hlsjs.src to null so that it reloads it's item source

    if (provider) {
      provider.src = null;
    }
  };

  _proto._nativeFullscreenHandler = function _nativeFullscreenHandler(evt) {
    this.model.trigger(events_events__WEBPACK_IMPORTED_MODULE_1__["NATIVE_FULLSCREEN"], evt);
    this.trigger(events_events__WEBPACK_IMPORTED_MODULE_1__["FULLSCREEN"], {
      fullscreen: evt.jwstate
    });
  };

  _proto._stateHandler = function _stateHandler(state) {
    var model = this.model;

    switch (state) {
      case events_events__WEBPACK_IMPORTED_MODULE_1__["STATE_PLAYING"]:
      case events_events__WEBPACK_IMPORTED_MODULE_1__["STATE_PAUSED"]:
        model.set(events_events__WEBPACK_IMPORTED_MODULE_1__["PLAYER_STATE"], state);
        break;

      default:
        break;
    }
  };

  _createClass(AdProgramController, [{
    key: "mute",
    set: function set(mute) {
      var mediaController = this.mediaController,
          model = this.model,
          provider = this.provider;
      model.set('mute', mute);

      _ProgramController.prototype.setMute.call(this, mute);

      if (!mediaController) {
        provider.mute(mute);
      }
    }
  }, {
    key: "volume",
    set: function set(volume) {
      var mediaController = this.mediaController,
          model = this.model,
          provider = this.provider;
      model.set('volume', volume);

      _ProgramController.prototype.setVolume.call(this, volume);

      if (!mediaController) {
        provider.volume(volume);
      }
    }
  }]);

  return AdProgramController;
}(program_program_controller__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/program/background-media.ts":
/*!********************************************!*\
  !*** ./src/js/program/background-media.ts ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BackgroundMedia; });
/**
 * A simple data structure for containing both of the background loading objects.
 * currentMedia is the currently active item which has been put into the background during ad playback.
 * nextMedia is an item which is preloading in the background which may be selected in the future. It is usually the
 * next item in the playlist, or the next up item in a recommendations feed.
 * @returns {BackgroundMedia}
 */

/**
 * @typedef {Object} BackgroundMedia
 * @property {MediaController} currentMedia - The mediaController which has been placed into the background during playback.
 * @property {Item} nextItem - The playlist item loading in the background.
 * @property {Promise} nextMedia - A promise representing the media loading in the background. Resolves with the mediaController.
 * @constructor
 */
function BackgroundMedia() {
  var currentMedia = null;
  var nextMedia = null;
  return Object.defineProperties({
    setNext: function setNext(item, loadPromise) {
      nextMedia = {
        item: item,
        loadPromise: loadPromise
      };
    },
    isNext: function isNext(item) {
      return !!(nextMedia && JSON.stringify(nextMedia.item.sources[0]) === JSON.stringify(item.sources[0]));
    },
    updateNext: function updateNext(item) {
      if (nextMedia) {
        nextMedia.item = item;
      }
    },
    clearNext: function clearNext() {
      nextMedia = null;
    }
  }, {
    nextLoadPromise: {
      get: function get() {
        return nextMedia ? nextMedia.loadPromise : null;
      }
    },
    currentMedia: {
      get: function get() {
        return currentMedia;
      },
      set: function set(mediaController) {
        currentMedia = mediaController;
      }
    }
  });
}

/***/ }),

/***/ "./src/js/program/media-controller.js":
/*!********************************************!*\
  !*** ./src/js/program/media-controller.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MediaController; });
/* harmony import */ var utils_underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils/underscore */ "./src/js/utils/underscore.js");
/* harmony import */ var utils_cancelable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! utils/cancelable */ "./src/js/utils/cancelable.ts");
/* harmony import */ var utils_backbone_events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! utils/backbone.events */ "./src/js/utils/backbone.events.ts");
/* harmony import */ var api_api_queue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! api/api-queue */ "./src/js/api/api-queue.ts");
/* harmony import */ var api_errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! api/errors */ "./src/js/api/errors.ts");
/* harmony import */ var program_program_listeners__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! program/program-listeners */ "./src/js/program/program-listeners.ts");
/* harmony import */ var controller_model__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! controller/model */ "./src/js/controller/model.ts");
/* harmony import */ var utils_strings__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! utils/strings */ "./src/js/utils/strings.ts");
/* harmony import */ var events_events__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! events/events */ "./src/js/events/events.ts");


function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }










var MediaController = /*#__PURE__*/function (_Events) {
  _inheritsLoose(MediaController, _Events);

  function MediaController(provider, model) {
    var _this;

    _this = _Events.call(this) || this;
    _this.attached = true;
    _this.beforeComplete = false;
    _this.item = null;
    _this.mediaModel = new controller_model__WEBPACK_IMPORTED_MODULE_6__["MediaModel"]();
    _this.model = model;
    _this.provider = provider;
    _this.providerListener = new program_program_listeners__WEBPACK_IMPORTED_MODULE_5__["ProviderListener"](_assertThisInitialized(_assertThisInitialized(_this)));
    _this.thenPlayPromise = Object(utils_cancelable__WEBPACK_IMPORTED_MODULE_1__["default"])(function () {});
    provider.off();
    provider.on('all', _this.providerListener, _assertThisInitialized(_assertThisInitialized(_this)));
    _this.eventQueue = new api_api_queue__WEBPACK_IMPORTED_MODULE_3__["default"](_assertThisInitialized(_assertThisInitialized(_this)), ['trigger'], function () {
      return !_this.attached || _this.background;
    });
    return _this;
  }

  var _proto = MediaController.prototype;

  _proto.play = function play(playReason) {
    var item = this.item,
        model = this.model,
        mediaModel = this.mediaModel,
        provider = this.provider;

    if (!playReason) {
      playReason = model.get('playReason');
    }

    model.set('playRejected', false); // If play has already been called, then only return provider.play

    if (mediaModel.get('setup')) {
      return provider.play() || Promise.resolve();
    }

    mediaModel.set('setup', true); // If this is the first call to play, load the media and play

    var playPromise = this._loadAndPlay(item, provider); // Trigger "playAttempt" if playback has not yet started


    if (mediaModel.get('started')) {
      return playPromise;
    }

    return this._playAttempt(playPromise, playReason);
  };

  _proto.stop = function stop() {
    var provider = this.provider;
    this.beforeComplete = false;
    provider.stop();
  };

  _proto.pause = function pause() {
    var provider = this.provider;
    provider.pause();
  };

  _proto.preload = function preload() {
    var item = this.item,
        mediaModel = this.mediaModel,
        provider = this.provider;

    if (!item || item && item.preload === 'none') {
      return;
    } // The provider has a video tag, but has not started nor preloaded


    if (this.attached && !this.setup && !this.preloaded) {
      mediaModel.set('preloaded', true);
      provider.preload(item);
    }
  };

  _proto.destroy = function destroy() {
    var provider = this.provider,
        mediaModel = this.mediaModel;
    this.off();
    mediaModel.off();
    provider.off();
    this.eventQueue.destroy();
    this.detach();

    if (provider.getContainer()) {
      provider.remove();
    }

    delete provider.instreamMode;
    this.provider = null;
    this.item = null;
  };

  _proto.attach = function attach() {
    var model = this.model,
        provider = this.provider; // Restore the playback rate to the provider in case it changed while detached and we reused a video tag.

    model.setPlaybackRate(model.get('defaultPlaybackRate'));
    provider.attachMedia();
    this.attached = true;
    this.eventQueue.flush();

    if (this.beforeComplete) {
      this._playbackComplete();
    }
  };

  _proto.detach = function detach() {
    var provider = this.provider;
    this.thenPlayPromise.cancel();
    var result = provider.detachMedia();
    this.attached = false;
    return result;
  } // Extends the playPromise
  ;

  _proto._playAttempt = function _playAttempt(playPromise, playReason) {
    var _this2 = this;

    var item = this.item,
        mediaModel = this.mediaModel,
        model = this.model,
        provider = this.provider;
    var video = provider ? provider.video : null;
    this.trigger(events_events__WEBPACK_IMPORTED_MODULE_8__["MEDIA_PLAY_ATTEMPT"], {
      item: item,
      playReason: playReason
    }); // Immediately set player state to buffering if these conditions are met

    if (video ? !video.paused : model.get(events_events__WEBPACK_IMPORTED_MODULE_8__["PLAYER_STATE"]) === events_events__WEBPACK_IMPORTED_MODULE_8__["STATE_PLAYING"]) {
      model.set(events_events__WEBPACK_IMPORTED_MODULE_8__["PLAYER_STATE"], events_events__WEBPACK_IMPORTED_MODULE_8__["STATE_BUFFERING"]);
    }

    return playPromise.then(function () {
      if (!mediaModel.get('setup')) {
        // Exit if model state was reset
        return;
      }

      mediaModel.set('started', true);

      if (mediaModel === model.mediaModel) {
        syncPlayerWithMediaModel(mediaModel);
      }
    }).catch(function (error) {
      if (_this2.item && mediaModel === model.mediaModel) {
        model.set('playRejected', true);
        var videoTagPaused = video && video.paused;

        if (videoTagPaused) {
          // Check if the video.src was set to empty, resolving to location.href and loaded.
          // This can be caused by 3rd party ads libraries after an ad break.
          if (video.src === location.href) {
            // Attempt to reload the video once within the play promise chain.
            return _this2._loadAndPlay(item, provider);
          }

          mediaModel.set('mediaState', events_events__WEBPACK_IMPORTED_MODULE_8__["STATE_PAUSED"]);
        }

        var playerError = Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["extend"])(new api_errors__WEBPACK_IMPORTED_MODULE_4__["PlayerError"](null, Object(api_errors__WEBPACK_IMPORTED_MODULE_4__["getPlayAttemptFailedErrorCode"])(error), error), {
          error: error,
          item: item,
          playReason: playReason
        });

        delete playerError.key;

        _this2.trigger(events_events__WEBPACK_IMPORTED_MODULE_8__["MEDIA_PLAY_ATTEMPT_FAILED"], playerError);

        throw error;
      }
    });
  };

  _proto._playbackComplete = function _playbackComplete() {
    var item = this.item,
        provider = this.provider;

    if (item) {
      delete item.starttime;
    }

    this.beforeComplete = false;
    provider.setState(events_events__WEBPACK_IMPORTED_MODULE_8__["STATE_COMPLETE"]);
    this.trigger(events_events__WEBPACK_IMPORTED_MODULE_8__["MEDIA_COMPLETE"], {});
  };

  _proto._loadAndPlay = function _loadAndPlay() {
    var item = this.item,
        provider = this.provider; // Calling load() on Shaka may return a player setup promise

    var providerSetupPromise = provider.load(item);

    if (providerSetupPromise) {
      var thenPlayPromise = Object(utils_cancelable__WEBPACK_IMPORTED_MODULE_1__["default"])(function () {
        return provider.play() || Promise.resolve();
      });
      this.thenPlayPromise = thenPlayPromise;
      return providerSetupPromise.then(thenPlayPromise.async);
    }

    return provider.play() || Promise.resolve();
  };

  _createClass(MediaController, [{
    key: "audioTrack",
    get: function get() {
      return this.provider.getCurrentAudioTrack();
    },
    set: function set(index) {
      this.provider.setCurrentAudioTrack(index);
    }
  }, {
    key: "quality",
    get: function get() {
      return this.provider.getCurrentQuality();
    },
    set: function set(index) {
      this.provider.setCurrentQuality(index);
    }
  }, {
    key: "audioTracks",
    get: function get() {
      return this.provider.getAudioTracks();
    }
  }, {
    key: "background",
    get: function get() {
      // A backgrounded provider is attached to a video tag
      if (!this.attached) {
        return false;
      }

      var provider = this.provider;

      if (false) {}

      if (!provider.video) {
        // A provider without a video tag cannot be backgrounded
        return false;
      } // A backgrounded provider does not have a parent container, or has one, but without the media tag as a child


      var container = provider.getContainer();
      return !container || container && !container.contains(provider.video);
    },
    set: function set(shouldBackground) {
      var provider = this.provider; // A provider without a video tag must use attach and detach

      if (!provider.video && !false) {
        if (shouldBackground) {
          this.detach();
        } else {
          this.attach();
        }

        return;
      }

      var container = provider.getContainer();

      if (!container) {
        return;
      }

      if (shouldBackground) {
        if (!this.background) {
          this.thenPlayPromise.cancel();
          this.pause();

          if (provider.removeFromContainer) {
            provider.removeFromContainer();
          } else {
            if (false) {} else {
              container.removeChild(provider.video);
            }
          }

          this.container = null;
        }
      } else {
        this.eventQueue.flush();

        if (this.beforeComplete) {
          this._playbackComplete();
        }
      }
    }
  }, {
    key: "container",
    get: function get() {
      return this.provider.getContainer();
    },
    set: function set(element) {
      var provider = this.provider;
      provider.setContainer(element);
    }
  }, {
    key: "mediaElement",
    get: function get() {
      return this.provider.video;
    }
  }, {
    key: "preloaded",
    get: function get() {
      return this.mediaModel.get('preloaded');
    }
  }, {
    key: "qualities",
    get: function get() {
      return this.provider.getQualityLevels();
    }
  }, {
    key: "setup",
    get: function get() {
      return this.mediaModel.get('setup');
    }
  }, {
    key: "started",
    get: function get() {
      return this.mediaModel.get('started');
    }
  }, {
    key: "activeItem",
    set: function set(item) {
      var mediaModel = this.mediaModel = new controller_model__WEBPACK_IMPORTED_MODULE_6__["MediaModel"]();
      var position = item ? Object(utils_strings__WEBPACK_IMPORTED_MODULE_7__["seconds"])(item.starttime) : 0;
      var duration = item ? Object(utils_strings__WEBPACK_IMPORTED_MODULE_7__["seconds"])(item.duration) : 0;
      var mediaModelState = mediaModel.attributes;
      mediaModel.srcReset();
      mediaModelState.position = position;
      mediaModelState.duration = duration;
      this.item = item;
      this.provider.init(item);

      if (false) {}
    }
  }, {
    key: "controls",
    set: function set(mode) {
      this.provider.setControls(mode);
    }
  }, {
    key: "mute",
    set: function set(mute) {
      this.provider.mute(mute);
    }
  }, {
    key: "position",
    set: function set(pos) {
      var provider = this.provider;

      if (this.model.get('scrubbing') && provider.fastSeek) {
        provider.fastSeek(pos);
      } else {
        provider.seek(pos);
      }
    }
  }, {
    key: "subtitles",
    set: function set(index) {
      if (this.provider.setSubtitlesTrack) {
        this.provider.setSubtitlesTrack(index);
      }
    }
  }, {
    key: "volume",
    set: function set(volume) {
      this.provider.volume(volume);
    }
  }]);

  return MediaController;
}(utils_backbone_events__WEBPACK_IMPORTED_MODULE_2__["default"]);



function syncPlayerWithMediaModel(mediaModel) {
  // Sync player state with mediaModel state
  var mediaState = mediaModel.get('mediaState');
  mediaModel.trigger('change:mediaState', mediaModel, mediaState, mediaState);
}

/***/ }),

/***/ "./src/js/program/program-controller.js":
/*!**********************************************!*\
  !*** ./src/js/program/program-controller.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var utils_underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils/underscore */ "./src/js/utils/underscore.js");
/* harmony import */ var providers_providers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! providers/providers */ "./src/js/providers/providers.js");
/* harmony import */ var program_media_controller__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! program/media-controller */ "./src/js/program/media-controller.js");
/* harmony import */ var utils_cancelable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! utils/cancelable */ "./src/js/utils/cancelable.ts");
/* harmony import */ var program_program_listeners__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! program/program-listeners */ "./src/js/program/program-listeners.ts");
/* harmony import */ var utils_backbone_events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! utils/backbone.events */ "./src/js/utils/backbone.events.ts");
/* harmony import */ var program_background_media__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! program/background-media */ "./src/js/program/background-media.ts");
/* harmony import */ var events_events__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! events/events */ "./src/js/events/events.ts");
/* harmony import */ var api_errors__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! api/errors */ "./src/js/api/errors.ts");
/* harmony import */ var controller_async_item__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! controller/async-item */ "./src/js/controller/async-item.ts");
/* harmony import */ var controller_model__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! controller/model */ "./src/js/controller/model.ts");


function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }












var ProgramController = /*#__PURE__*/function (_Events) {
  _inheritsLoose(ProgramController, _Events);

  /**
   * ProgramController constructor
   * @param {Model} model - The player's model
   * @param {MediaElementPool} mediaPool - The player's media element pool
   * @param {PublicApi} publicApi - The player API applied as context in async playlist item promise callback execution
   */
  function ProgramController(model, mediaPool, publicApi) {
    var _this;

    _this = _Events.call(this) || this;
    _this.adPlaying = false;
    _this.apiContext = publicApi;
    _this.background = Object(program_background_media__WEBPACK_IMPORTED_MODULE_6__["default"])();
    _this.mediaPool = mediaPool;
    _this.mediaController = null;
    _this.mediaControllerListener = Object(program_program_listeners__WEBPACK_IMPORTED_MODULE_4__["MediaControllerListener"])(model);
    _this.model = model;
    _this.providers = new providers_providers__WEBPACK_IMPORTED_MODULE_1__["default"](model.getConfiguration());
    _this.loadPromise = null;
    _this.backgroundLoading = model.get('backgroundLoading');
    _this.asyncItems = [];
    _this.itemSetContext = 0;

    if (false) {}

    if (!_this.backgroundLoading) {
      // If background loading is not supported, set the shared media element
      model.set('mediaElement', _this.mediaPool.getPrimedElement());
    }

    return _this;
  }
  /**
   * Runs the async playlist item callback / promise
   * @param {number} index - The playlist index of the item
   * @returns {Promise<PlaylistItem>} The ItemPromise run promise
   * @memberOf ProgramController
   */


  var _proto = ProgramController.prototype;

  _proto.asyncActiveItem = function asyncActiveItem(index) {
    var _this2 = this;

    var model = this.model; // Set the player state to buffering if there is a playlist item callback

    var deferBufferingState =  false ? undefined : setTimeout(function () {
      model.set(events_events__WEBPACK_IMPORTED_MODULE_7__["PLAYER_STATE"], events_events__WEBPACK_IMPORTED_MODULE_7__["STATE_BUFFERING"]);
    }, 50);
    return this.getAsyncItem(index).run().then(function (playlistItem) {
      clearTimeout(deferBufferingState);
      return playlistItem;
    }).catch(function (itemPromiseError) {
      clearTimeout(deferBufferingState);

      if (index < model.get('playlist').length - 1) {
        return _this2.setActiveItem(index + 1).then(function () {
          return null;
        });
      }

      throw itemPromiseError;
    });
  }
  /**
   * Activates a playlist item, loading it into the foreground.
   * This method will either load a new Provider or reuse the active one.
   * @param {number} index - The playlist index of the item
   * @returns {Promise<MediaController>} The Provider promise. Resolves with the active Media Controller
   * @memberOf ProgramController
   */
  ;

  _proto.setActiveItem = function setActiveItem(index) {
    var _this3 = this;

    var background = this.background,
        mediaController = this.mediaController,
        model = this.model;
    var item = model.get('playlist')[index];
    model.attributes.itemReady = false; // Reset the mediaModel now to synchronously "cancel" play promise callbacks
    // that check `mediaModel === model.mediaModel`

    if (mediaController) {
      mediaController.mediaModel.off();
      model.attributes.mediaModel = new controller_model__WEBPACK_IMPORTED_MODULE_10__["MediaModel"]();
      model.mediaModel.attributes = mediaController.mediaModel.clone();
    } // Destroy background loading item early so we can reuse the media elements in asyncItem


    if (!background.isNext(item)) {
      // Loading a new item invalidates all background loading media
      this._destroyBackgroundMedia();
    } // Set a context for this async call. If asyncActiveItem resolves and this.itemSetContext has changed exit early.


    var itemSetContext = this.itemSetContext = Math.random();
    return this.loadPromise = this.asyncActiveItem(index).then(function (playlistItem) {
      // Resolve and exit on asyncActiveItem() itemPromiseError,
      // or if setActiveItem was called again changing itemSetContext
      if (playlistItem === null || itemSetContext !== _this3.itemSetContext) {
        return null;
      }

      model.setActiveItem(index);
      var source = getSource(playlistItem);

      if (!source) {
        return Promise.reject(new api_errors__WEBPACK_IMPORTED_MODULE_8__["PlayerError"](api_errors__WEBPACK_IMPORTED_MODULE_8__["MSG_CANT_PLAY_VIDEO"], api_errors__WEBPACK_IMPORTED_MODULE_8__["ERROR_PLAYLIST_ITEM_MISSING_SOURCE"]));
      } // Activate the background media if it's loading the item we want to play


      if (background.isNext(playlistItem)) {
        // First destroy the active item so that the BGL provider can enter the foreground
        _this3._destroyActiveMedia(); // Attach the BGL provider into the load/play chain


        return _this3._activateBackgroundMedia();
      }

      if (mediaController) {
        var casting = model.get('castActive');

        if (casting || _this3._providerCanPlay(mediaController.provider, source)) {
          // We can synchronously reuse the current mediaController
          // Reinitialize the mediaController with the new item, allowing a new playback session
          mediaController.activeItem = playlistItem;

          _this3._setActiveMedia(mediaController);

          return mediaController;
        } // If we can't play the source with the current provider, reset the current one and
        // prime the next tag within the gesture


        _this3._destroyActiveMedia();
      }

      return _this3._setupMediaController(source).then(function (nextMediaController) {
        // Don't do anything if we've tried to load another provider while this promise was resolving
        // We check using the mediaModel because it is unique per item, and per instance of that item
        if (itemSetContext === _this3.itemSetContext) {
          nextMediaController.activeItem = playlistItem;

          _this3._setActiveMedia(nextMediaController);

          return nextMediaController;
        }
      }).catch(function (err) {
        _this3._destroyActiveMedia();

        throw err;
      });
    });
  }
  /**
   * Attaches or detaches the current media
   * @param {boolean} shouldAttach - Attach or detach?
   * @returns {Promise|void} A detach promise. Resolves when media is detached.
   */
  ;

  _proto.setAttached = function setAttached(shouldAttach) {
    var mediaController = this.mediaController;
    this.attached = shouldAttach;

    if (!mediaController) {
      return;
    }

    if (shouldAttach) {
      mediaController.attach();
    } else {
      var result = mediaController.detach();
      var item = mediaController.item,
          mediaModel = mediaController.mediaModel; // If detaching to play a midroll (pos > 0), ensure that the player resumes at the detached time by setting starttime
      // We don't need to do this for prerolls because the player re-attaches at time 0 by default

      var pos = mediaModel.get('position');

      if (pos) {
        item.starttime = pos;
      }

      return result;
    }
  }
  /**
   * Plays the active item.
   * Will wait for the Provider promise to resolve before any play attempt.
   * @param {string} playReason - The reason playback is beginning.
   * @returns {Promise} The Play promise. Resolves when playback begins; rejects upon failure.
   */
  ;

  _proto.playVideo = function playVideo(playReason) {
    var _this4 = this;

    var mediaController = this.mediaController,
        model = this.model;
    var item = model.get('playlistItem');
    var playPromise;

    if (!item) {
      return Promise.reject(new Error('No media'));
    }

    if (!playReason) {
      playReason = model.get('playReason');
    } // Start playback immediately if we have already loaded a mediaController


    if (mediaController) {
      playPromise = mediaController.play(playReason);
    } else {
      // Wait for the provider to load before starting initial playback
      model.set(events_events__WEBPACK_IMPORTED_MODULE_7__["PLAYER_STATE"], events_events__WEBPACK_IMPORTED_MODULE_7__["STATE_BUFFERING"]); // Make the subsequent promise cancelable so that we can avoid playback when no longer wanted

      var thenPlayPromise = Object(utils_cancelable__WEBPACK_IMPORTED_MODULE_3__["default"])(function (nextMediaController) {
        if (_this4.mediaController && _this4.mediaController.mediaModel === nextMediaController.mediaModel) {
          return nextMediaController.play(playReason);
        }

        throw new Error('Playback cancelled.');
      });
      playPromise = (this.loadPromise || Promise.resolve()).catch(function (error) {
        thenPlayPromise.cancel(); // Fail the playPromise to trigger "playAttemptFailed"

        throw error;
      }).then(thenPlayPromise.async);
    }

    return playPromise;
  }
  /**
   * Stops playback of the active item, and sets the player state to IDLE.
   * @returns {void}
   */
  ;

  _proto.stopVideo = function stopVideo() {
    var mediaController = this.mediaController,
        model = this.model;
    var item = model.get('playlist')[model.get('item')];
    model.attributes.playlistItem = item;
    model.resetItem(item);

    if (mediaController) {
      mediaController.stop();
    }
  }
  /**
   * Preloads the active item, which loads and buffers some content.
   * @returns {void}
   */
  ;

  _proto.preloadVideo = function preloadVideo() {
    var background = this.background,
        mediaController = this.mediaController;
    var media = mediaController || background.currentMedia;

    if (!media) {
      return;
    }

    media.preload();
  }
  /**
   * Pauses playback of the current video, and sets the player state to PAUSED.
   * @returns {void}
   */
  ;

  _proto.pause = function pause() {
    var mediaController = this.mediaController;

    if (!mediaController) {
      return;
    }

    mediaController.pause();
  }
  /**
   * Casts a video. The Cast Controller will control the Cast Provider.
   * @param {CastProvider} castProvider - The playback provider instance (Casting is implemented in jwplayer-commercial).
   * @param {Item} item - The playlist Item instance to cast.
   * @returns {void}
   */
  ;

  _proto.castVideo = function castVideo(castProvider, item) {
    var model = this.model;
    model.attributes.itemReady = false;

    var playlistItem = Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["extend"])({}, item);

    var currentTime = playlistItem.starttime = model.mediaModel.get('currentTime');

    this._destroyActiveMedia();

    var castMediaController = new program_media_controller__WEBPACK_IMPORTED_MODULE_2__["default"](castProvider, model);
    castMediaController.activeItem = playlistItem;

    this._setActiveMedia(castMediaController);

    model.mediaModel.set('currentTime', currentTime);
  }
  /**
   * Stops casting. The Player is expected to restore video playback afterwards.
   * @returns {void}
   */
  ;

  _proto.stopCast = function stopCast() {
    var model = this.model;
    var index = model.get('item');
    var item = model.get('playlist')[index];
    item.starttime = model.mediaModel.get('currentTime');
    this.stopVideo();
    this.setActiveItem(index).catch(function () {
      /* noop */
    });
  }
  /**
   * Places the currently active Media Controller into the background.
   * The media is still attached to a media element, but is removed from the Player's container.
   * Background media still emits events, but we stop listening to them.
   * Background media can (and will) be updated via it's API.
   * @returns {void}
   */
  ;

  _proto.backgroundActiveMedia = function backgroundActiveMedia() {
    this.adPlaying = true;
    var background = this.background,
        mediaController = this.mediaController;

    if (!mediaController) {
      return;
    } // Destroy any existing background media


    if (background.currentMedia) {
      this._destroyMediaController(background.currentMedia);
    }

    mediaController.background = true;
    background.currentMedia = mediaController;
    this.mediaController = null;
  }
  /**
   * Restores the background media to the foreground.
   * Its media element is reattached to the Player container.
   * We start listening to its events again.
   * @returns {void}
   */
  ;

  _proto.restoreBackgroundMedia = function restoreBackgroundMedia() {
    this.adPlaying = false;
    var background = this.background,
        mediaController = this.mediaController;
    var backgroundMediaController = background.currentMedia;

    if (!backgroundMediaController) {
      return;
    } else if (mediaController && mediaController !== backgroundMediaController) {
      // An existing media controller means that we've changed the active item
      // The current background media is no longer relevant, so destroy it
      this._destroyMediaController(backgroundMediaController);

      background.currentMedia = null;
      return;
    }

    var attributes = backgroundMediaController.mediaModel.attributes;

    if (attributes.mediaState === events_events__WEBPACK_IMPORTED_MODULE_7__["STATE_IDLE"]) {
      attributes.mediaState = events_events__WEBPACK_IMPORTED_MODULE_7__["STATE_PAUSED"];
    } else if (attributes.mediaState !== events_events__WEBPACK_IMPORTED_MODULE_7__["STATE_PAUSED"]) {
      attributes.mediaState = events_events__WEBPACK_IMPORTED_MODULE_7__["STATE_BUFFERING"];
    }

    this._setActiveMedia(backgroundMediaController);

    backgroundMediaController.background = false;
    background.currentMedia = null;
  }
  /**
   * Loads the next playlist item in the background.
   * @param {Item} item - The playlist item to load.
   * @param {number} index - The playlist item promise index.
   *
   * @returns {void}
   */
  ;

  _proto.backgroundLoad = function backgroundLoad(item, index) {
    var _this5 = this;

    var background = this.background;
    var loadPromise = this.getAsyncItem(index).run().then(function (playlistItem) {
      background.updateNext(playlistItem);
      var source = getSource(playlistItem);
      return _this5._setupMediaController(source).then(function (nextMediaController) {
        nextMediaController.activeItem = playlistItem;
        nextMediaController.preload();
        return nextMediaController;
      });
    }).catch(function () {
      background.clearNext();
    });
    background.setNext(item, loadPromise);
  }
  /**
   * Add the 'all' events listener that forwards events from the media-controller
   * @returns {void}
   */
  ;

  _proto.forwardEvents = function forwardEvents() {
    var mediaController = this.mediaController;

    if (!mediaController) {
      return;
    }

    _forwardEvents(mediaController, this);
  }
  /**
   * Remove the 'all' events listener that forwards events from the media-controller.
   * If a target is specified, route all events to target.mediaControllerListener.
   * @param {Object} [target] - Optional argument that must contain a mediaControllerListener method.
   * @returns {void}
   */
  ;

  _proto.routeEvents = function routeEvents(target) {
    var mediaController = this.mediaController;

    if (!mediaController) {
      return;
    }

    mediaController.off();

    if (target) {
      _forwardEvents(mediaController, target);
    }
  }
  /**
   * Removes all event listeners and destroys all media.
   * @returns {void}
   */
  ;

  _proto.destroy = function destroy() {
    this.off();

    this._destroyBackgroundMedia();

    this._destroyActiveMedia();

    this.apiContext = null;
  }
  /**
   * Activates the provided media controller, placing it into the foreground.
   * Events fired from the media controller will be forwarded through the program controller.
   * @param {MediaController} mediaController - The media controller to activate.
   * @returns {void}
   * @private
   */
  ;

  _proto._setActiveMedia = function _setActiveMedia(mediaController) {
    var model = this.model;
    var mediaModel = mediaController.mediaModel,
        provider = mediaController.provider;
    assignMediaContainer(model, mediaController);
    this.mediaController = mediaController;
    model.set('mediaElement', mediaController.mediaElement);
    model.setMediaModel(mediaModel);
    model.setProvider(provider);

    _forwardEvents(mediaController, this);

    model.set('itemReady', true);
  }
  /**
   * Destroys the active media controller and current playback.
   * @returns {void}
   * @private
   */
  ;

  _proto._destroyActiveMedia = function _destroyActiveMedia() {
    var mediaController = this.mediaController,
        model = this.model;

    if (!mediaController || !mediaController.provider) {
      return;
    }

    mediaController.detach();

    this._destroyMediaController(mediaController);

    model.resetProvider();
    this.mediaController = null;
  }
  /**
   * Destroys all background media.
   * @returns {void}
   * @private
   */
  ;

  _proto._destroyBackgroundMedia = function _destroyBackgroundMedia() {
    var background = this.background;

    this._destroyMediaController(background.currentMedia);

    background.currentMedia = null;

    this._destroyBackgroundLoadingMedia();
  }
  /**
   * Destroys a mediaController, and returns it's tag to the pool.
   * @param {MediaController} mediaController - The media controller to destroy and recycle.
   * @returns {void}
   * @private
   */
  ;

  _proto._destroyMediaController = function _destroyMediaController(mediaController) {
    var mediaPool = this.mediaPool;

    if (!mediaController || !mediaController.provider) {
      return;
    }

    mediaPool.recycle(mediaController.mediaElement);
    mediaController.destroy();
  }
  /**
   * Constructs a new media controller with the provider whose able to play the current source.
   * Will wait and load the provider constructor if it has not already been loaded.
   * If the required provider cannot be loaded, the subsequent promise rejection will destroy playback.
   * @param {Source} source - The playlist item Source for which a provider is needed.
   * @returns {Promise} The Provider constructor promise.
   * @private
   */
  ;

  _proto._setupMediaController = function _setupMediaController(source) {
    var _this6 = this;

    var model = this.model,
        providers = this.providers;

    var makeMediaController = function makeMediaController(ProviderConstructor) {
      return new program_media_controller__WEBPACK_IMPORTED_MODULE_2__["default"](new ProviderConstructor(model.get('id'), model.getConfiguration(), _this6.primedElement), model);
    };

    var _providers$choose = providers.choose(source),
        provider = _providers$choose.provider,
        name = _providers$choose.name;

    if (provider) {
      return Promise.resolve(makeMediaController(provider));
    }

    return providers.load(name).then(function (ProviderConstructor) {
      return makeMediaController(ProviderConstructor);
    });
  }
  /**
   * Places the background loading media into the foreground. Will wait for the provider promise to resolve.
   * If the program controller has been placed into ads mode, the background loading media will replace the background
   * loaded media. When the ad is over, the loaded media will be placed into the foreground via _restoreBackgroundMedia().
   * This is done to avoid a race condition where we have activated the loading item, but switch to ads mode before the
   * promise resovles, resulting in two tags in the foreground (since _backgroundActiveMedia "misses" the pending promise).
   * @returns {Promise} The Provider promise. Resolves with preloaded media controller.
   * @memberOf ProgramController
   */
  ;

  _proto._activateBackgroundMedia = function _activateBackgroundMedia() {
    var _this7 = this;

    var background = this.background,
        nextLoadPromise = this.background.nextLoadPromise,
        model = this.model; // Activating this item means that any media already loaded in the background will no longer be needed

    this._destroyMediaController(background.currentMedia);

    background.currentMedia = null;
    return nextLoadPromise.then(function (nextMediaController) {
      if (!nextMediaController) {
        return;
      }

      background.clearNext();

      if (_this7.adPlaying) {
        model.attributes.itemReady = true;
        background.currentMedia = nextMediaController;
      } else {
        _this7._setActiveMedia(nextMediaController);

        nextMediaController.background = false;
      }

      return nextMediaController;
    }); // The catch is chained as part of the play promise chain
  }
  /**
   * Destroys the mediaController which was constructed and loading in the background (nextMedia).
   * Does not destroy the mediaController which was already playing and subsequently placed into the background (currentMedia).
   * @returns {void}
   * @private
   */
  ;

  _proto._destroyBackgroundLoadingMedia = function _destroyBackgroundLoadingMedia() {
    var _this8 = this;

    var background = this.background,
        nextLoadPromise = this.background.nextLoadPromise;

    if (!nextLoadPromise) {
      return;
    }

    nextLoadPromise.then(function (nextMediaController) {
      _this8._destroyMediaController(nextMediaController);

      background.clearNext();
    });
  };

  _proto._providerCanPlay = function _providerCanPlay(_provider, source) {
    var _this$providers$choos = this.providers.choose(source),
        provider = _this$providers$choos.provider;

    return provider && _provider && _provider instanceof provider;
  }
  /**
   * Returns the active audio track index.
   * @returns {number} The active audio track index.
   */
  ;

  /**
   * Mutes or unmutes the activate media.
   * Syncs across all media elements.
   * @param {boolean} mute - Mute or unmute media?
   * @returns {void}
   */
  _proto.setMute = function setMute(mute) {
    var background = this.background,
        mediaController = this.mediaController,
        mediaPool = this.mediaPool;

    if (mediaController) {
      mediaController.mute = mute;
    }

    if (background.currentMedia) {
      background.currentMedia.mute = mute;
    }

    if (true) {
      mediaPool.syncMute(mute);
    }
  }
  /**
   * Sets the volume level.
   * Syncs across all media elements.
   * @param {number} volume - A number from 0 to 1.
   * @returns {void}
   */
  ;

  _proto.setVolume = function setVolume(volume) {
    var background = this.background,
        mediaController = this.mediaController,
        mediaPool = this.mediaPool;

    if (mediaController) {
      mediaController.volume = volume;
    }

    if (background.currentMedia) {
      background.currentMedia.volume = volume;
    }

    if (true) {
      mediaPool.syncVolume(volume);
    }
  };

  _proto.getAsyncItem = function getAsyncItem(index) {
    var asyncItem = this.asyncItems[index];

    if (!asyncItem) {
      asyncItem = this.asyncItems[index] = new controller_async_item__WEBPACK_IMPORTED_MODULE_9__["AsyncItemController"](index, this.model, this.apiContext);
      asyncItem.callback = this.model.get('playlistItemCallback');
    }

    return asyncItem;
  };

  _proto.clearItemPromises = function clearItemPromises() {
    this.asyncItems.forEach(function (asyncItemController) {
      if (asyncItemController) {
        asyncItemController.reject(new Error('Item playback aborted'));
      }
    });
    this.asyncItems.length = 0;
  };

  _createClass(ProgramController, [{
    key: "audioTrack",
    get: function get() {
      var mediaController = this.mediaController;

      if (!mediaController) {
        return -1;
      }

      return mediaController.audioTrack;
    }
    /**
     * Returns the list of audio tracks.
     * @returns {Array<AudioTrackOption>} An array of AudioTrackOption instances.
     */
    ,

    /**
     * Sets the active audio index.
     * @param {number} index - The index of the audio track to select.
     * @returns {void}
     */
    set: function set(index) {
      var mediaController = this.mediaController;

      if (!mediaController) {
        return;
      }

      mediaController.audioTrack = parseInt(index, 10) || 0;
    }
    /**
     * Seeks the media to the provided position.
     * Set the item's starttime so that if detached while seeking it resumes from the correct time.
     * ALso set the item's starttime so that if we seek before loading, we load and begin at the correct time.
     * @param {number} pos - The position to start at or seek to.
     * @returns {void}
     */

  }, {
    key: "audioTracks",
    get: function get() {
      var mediaController = this.mediaController;

      if (!mediaController) {
        return undefined;
      }

      return mediaController.audioTracks;
    }
    /**
     * Returns whether the current media has completed playback.
     * @returns {boolean} Is the "beforeComplete" event being propagated
     * or did it result in the media being detached or backgrounded?
     */

  }, {
    key: "beforeComplete",
    get: function get() {
      var mediaController = this.mediaController,
          currentMedia = this.background.currentMedia;

      if (!mediaController && !currentMedia) {
        return false;
      }

      return mediaController ? mediaController.beforeComplete : currentMedia.beforeComplete;
    }
    /**
     * Returns a primed element from the media pool.
     * @returns {HTMLVideoElement|null} The first video element in the pool, or null if the pool is empty.
     */

  }, {
    key: "primedElement",
    get: function get() {
      if (!this.backgroundLoading) {
        // If background loading is not supported, the model will always contain the shared media element
        // Prime it so that playback after changing the active item does not require further gestures
        var model = this.model;
        return model.get('mediaElement');
      }

      return this.mediaPool.getPrimedElement();
    }
    /**
     * Returns the active quality index.
     * @returns {number} The active quality level index.
     */

  }, {
    key: "quality",
    get: function get() {
      if (!this.mediaController) {
        return -1;
      }

      return this.mediaController.quality;
    }
    /**
     * Returns the list of quality levels.
     * @returns {Array<QualityOption>} An array of QualityOption objects.
     */
    ,

    /**
     * Sets the current quality level.
     * @param {number} index - The index of the quality level to select.
     * @returns {void}
     */
    set: function set(index) {
      var mediaController = this.mediaController;

      if (!mediaController) {
        return;
      }

      mediaController.quality = parseInt(index, 10) || 0;
    }
    /**
     * Sets the current subtitles track.
     * @param {number} index - The index of the subtitle track to select.
     * @returns {void}
     */

  }, {
    key: "qualities",
    get: function get() {
      var mediaController = this.mediaController;

      if (!mediaController) {
        return null;
      }

      return mediaController.qualities;
    }
  }, {
    key: "position",
    set: function set(pos) {
      var mediaController = this.mediaController;

      if (!mediaController) {
        return;
      }

      mediaController.item.starttime = pos;

      if (mediaController.attached) {
        mediaController.position = pos;
      }
    }
  }, {
    key: "subtitles",
    set: function set(index) {
      var mediaController = this.mediaController;

      if (!mediaController) {
        return;
      }

      mediaController.subtitles = index;
    }
  }, {
    key: "itemCallback",
    set: function set(callback) {
      this.model.set('playlistItemCallback', callback);
      this.asyncItems.forEach(function (asyncItem) {
        if (asyncItem) {
          asyncItem.callback = callback;
        }
      });
    }
  }]);

  return ProgramController;
}(utils_backbone_events__WEBPACK_IMPORTED_MODULE_5__["default"]);

function assignMediaContainer(model, mediaController) {
  var container = model.get('mediaContainer');

  if (container) {
    mediaController.container = container;
  } else {
    model.once('change:mediaContainer', function (changedModel, changedContainer) {
      mediaController.container = changedContainer;
    });
  }
}

function _forwardEvents(mediaController, target) {
  var mediaControllerListener = target.mediaControllerListener;
  mediaController.off().on('all', mediaControllerListener, target);
}

function getSource(item) {
  return item && item.sources && item.sources[0];
}

/* harmony default export */ __webpack_exports__["default"] = (ProgramController);

/***/ }),

/***/ "./src/js/program/program-listeners.ts":
/*!*********************************************!*\
  !*** ./src/js/program/program-listeners.ts ***!
  \*********************************************/
/*! exports provided: ProviderListener, MediaControllerListener */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ProviderListener", function() { return ProviderListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MediaControllerListener", function() { return MediaControllerListener; });
/* harmony import */ var utils_underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils/underscore */ "./src/js/utils/underscore.js");
/* harmony import */ var events_events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events/events */ "./src/js/events/events.ts");





function ProviderListener(mediaController) {
  return function (type, data) {
    var mediaModel = mediaController.mediaModel;

    var event = Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["extend"])({}, data, {
      type: type
    });

    switch (type) {
      case events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_TYPE"]:
        if (mediaModel.get(events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_TYPE"]) === event.mediaType) {
          return;
        }

        mediaModel.set(events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_TYPE"], event.mediaType);
        break;

      case events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_VISUAL_QUALITY"]:
        mediaModel.set(events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_VISUAL_QUALITY"], Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["extend"])({}, data));
        return;

      case events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_MUTE"]:
        // Only forward and queue mute changes
        if (data[events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_MUTE"]] === mediaController.model.getMute()) {
          return;
        }

        break;

      case events_events__WEBPACK_IMPORTED_MODULE_1__["PLAYER_STATE"]:
        {
          var _ref = data,
              newstate = _ref.newstate;

          if (newstate === events_events__WEBPACK_IMPORTED_MODULE_1__["STATE_IDLE"]) {
            mediaController.thenPlayPromise.cancel();
            mediaModel.srcReset();
          } // Always fire change:mediaState to keep player model in sync


          var previousState = mediaModel.attributes.mediaState;
          mediaModel.attributes.mediaState = newstate;
          mediaModel.trigger('change:mediaState', mediaModel, newstate, previousState);
          break;
        }

      case events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_COMPLETE"]:
        mediaController.beforeComplete = true;
        mediaController.trigger(events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_BEFORECOMPLETE"], event);

        if (mediaController.attached && !mediaController.background) {
          mediaController._playbackComplete();
        }

        return;

      case events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_ERROR"]:
        if (mediaModel.get('setup')) {
          mediaController.thenPlayPromise.cancel();
          mediaModel.srcReset();
        } else {
          // A MEDIA_ERROR received before setup is a preload error
          // We stop propagation here allow the player to try loading once more when playback is initiated
          // MEDIA_ERROR codes are in the 200,000 range; adding 100,000 puts it in the 300,000 warning range.
          type = events_events__WEBPACK_IMPORTED_MODULE_1__["WARNING"];
          event.code += 100000;
        }

        break;

      case events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_META"]:
        {
          var _ref2 = data,
              duration = _ref2.duration,
              metadataType = _ref2.metadataType,
              seekRange = _ref2.seekRange;

          if (!metadataType) {
            event.metadataType = 'unknown';
          }

          if (Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["isValidNumber"])(duration)) {
            mediaModel.set('seekRange', seekRange);
            mediaModel.set('duration', duration);
          }

          break;
        }

      case events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_BUFFER"]:
        mediaModel.set('buffer', data.bufferPercent);

      /* falls through to update duration while media is loaded */

      case events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_TIME"]:
        {
          var timeData = data;
          mediaModel.set('seekRange', timeData.seekRange);
          mediaModel.set('position', timeData.position);
          mediaModel.set('currentTime', timeData.currentTime);
          var _duration = timeData.duration;

          if (Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["isValidNumber"])(_duration)) {
            mediaModel.set('duration', _duration);
          }

          if (type === events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_TIME"] && 'starttime' in mediaController.item) {
            delete mediaController.item.starttime;
          }

          break;
        }

      case events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_SEEKED"]:
        {
          // After seeking, if the video tag is in a paused state, update the player state to "paused"
          var mediaElement = mediaController.mediaElement;

          if (mediaElement && mediaElement.paused) {
            mediaModel.set('mediaState', 'paused');
          }

          break;
        }

      case events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_LEVELS"]:
        mediaModel.set(events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_LEVELS"], data.levels);

      /* falls through to update current level */

      case events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_LEVEL_CHANGED"]:
        {
          var _ref3 = data,
              currentQuality = _ref3.currentQuality,
              levels = _ref3.levels;

          if (currentQuality > -1 && levels.length > 1) {
            mediaModel.set('currentLevel', parseInt(currentQuality));
          }

          break;
        }

      case events_events__WEBPACK_IMPORTED_MODULE_1__["AUDIO_TRACKS"]:
        mediaModel.set(events_events__WEBPACK_IMPORTED_MODULE_1__["AUDIO_TRACKS"], data.tracks);

      /* falls through to update current track */

      case events_events__WEBPACK_IMPORTED_MODULE_1__["AUDIO_TRACK_CHANGED"]:
        {
          var _ref4 = data,
              currentTrack = _ref4.currentTrack,
              tracks = _ref4.tracks;

          if (currentTrack > -1 && tracks.length > 0 && currentTrack < tracks.length) {
            mediaModel.set('currentAudioTrack', parseInt(currentTrack));
          }

          break;
        }

      default:
        break;
    }

    mediaController.trigger(type, event);
  };
}
function MediaControllerListener(model) {
  return function (type, event) {
    switch (type) {
      case events_events__WEBPACK_IMPORTED_MODULE_1__["PLAYER_STATE"]:
        // This "return" is important because
        //  we are choosing to not propagate model event.
        //  Instead letting the master controller do so
        return;

      case events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_VOLUME"]:
        model.set(events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_VOLUME"], event[events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_VOLUME"]]);
        return;

      case events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_MUTE"]:
        model.set(events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_MUTE"], event[events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_MUTE"]]);
        return;

      case events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_RATE_CHANGE"]:
        model.set('playbackRate', event.playbackRate);
        return;

      case events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_META"]:
        {
          Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["extend"])(model.get('itemMeta'), event.metadata);

          break;
        }

      case events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_LEVEL_CHANGED"]:
        model.persistQualityLevel(event.currentQuality, event.levels);
        break;

      case events_events__WEBPACK_IMPORTED_MODULE_1__["SUBTITLES_TRACK_CHANGED"]:
        model.persistVideoSubtitleTrack(event.currentTrack, event.tracks);
        break;

      case events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_TIME"]:
        if (event.targetLatency) {
          model.set('dvrSeekLimit', event.targetLatency);
        }

      /* falls through to to trigger model event off model */

      case events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_SEEK"]:
      case events_events__WEBPACK_IMPORTED_MODULE_1__["MEDIA_SEEKED"]:
      case events_events__WEBPACK_IMPORTED_MODULE_1__["NATIVE_FULLSCREEN"]:
      case events_events__WEBPACK_IMPORTED_MODULE_1__["SUBTITLES_TRACKS"]:
      case 'subtitlesTracksData':
        model.trigger(type, event);
        break;

      case events_events__WEBPACK_IMPORTED_MODULE_1__["BANDWIDTH_ESTIMATE"]:
        {
          model.persistBandwidthEstimate(event.bandwidthEstimate);
          return;
        }

      default:
    }

    this.trigger(type, event);
  };
}

/***/ }),

/***/ "./src/js/providers/utils/play-promise.ts":
/*!************************************************!*\
  !*** ./src/js/providers/utils/play-promise.ts ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createPlayPromise; });
// These properties must be redefined because they are readonly on DOMException
function createPlayPromise(video) {
  return new Promise(function (resolve, reject) {
    if (video.paused) {
      return reject(playPromiseError('NotAllowedError', 0, 'play() failed.'));
    }

    var removeEventListeners = function removeEventListeners() {
      video.removeEventListener('play', playListener);
      video.removeEventListener('playing', listener);
      video.removeEventListener('pause', listener);
      video.removeEventListener('abort', listener);
      video.removeEventListener('error', listener);
    };

    var playListener = function playListener() {
      video.addEventListener('playing', listener);
      video.addEventListener('abort', listener);
      video.addEventListener('error', listener);
      video.addEventListener('pause', listener);
    };

    var listener = function listener(e) {
      removeEventListeners();

      if (e.type === 'playing') {
        resolve();
      } else {
        var message = "The play() request was interrupted by a \"" + e.type + "\" event.";

        if (e.type === 'error') {
          return reject(playPromiseError('NotSupportedError', 9, message));
        }

        return reject(playPromiseError('AbortError', 20, message));
      }
    };

    video.addEventListener('play', playListener);
  });
}

function playPromiseError(name, code, message) {
  var error = new Error(message);
  error.name = name;
  error.code = code;
  return error;
}

/***/ }),

/***/ "./src/js/providers/utils/stream-type.ts":
/*!***********************************************!*\
  !*** ./src/js/providers/utils/stream-type.ts ***!
  \***********************************************/
/*! exports provided: isDvr, streamType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDvr", function() { return isDvr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "streamType", function() { return streamType; });
/** @module */

/**
 * It's DVR if the duration is not Infinity and above the minDvrWindow, Live otherwise.
 * @param {number} duration - The duration or seekable range of a stream in seconds.
 * @param {number} minDvrWindow - The duration threshold beyond which a stream should be treated as DVR instead of Live.
 * @returns {boolean} DVR or not.
 */
function isDvr(duration, minDvrWindow) {
  return duration !== Infinity && Math.abs(duration) >= Math.max(validMinDvrWindow(minDvrWindow), 0);
}
/**
 * Determine the adaptive type.
 * @param {number} duration - The duration or seekable range of a stream in seconds. Can be positive or negative.
 * Positive or non-infinite values will result in a return value of 'VOD'. Infinite values always return 'LIVE'.
 * @param {number} minDvrWindow - The duration threshold beyond which a stream should be treated as DVR instead of Live.
 * minDvrWindow should always be positive.
 * @returns {StreamType} The stream type.
 */

function streamType(duration, minDvrWindow) {
  var _streamType = 'VOD';

  if (duration === Infinity) {
    _streamType = 'LIVE';
  } else if (duration < 0) {
    _streamType = isDvr(duration, validMinDvrWindow(minDvrWindow)) ? 'DVR' : 'LIVE';
  }

  return _streamType;
}

function validMinDvrWindow(minDvrWindow) {
  return minDvrWindow === undefined ? 120 : Math.max(minDvrWindow, 0);
}

/***/ }),

/***/ "./src/js/templates/logo.ts":
/*!**********************************!*\
  !*** ./src/js/templates/logo.ts ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (position, hide) {
  var jwhide = hide ? ' jw-hide' : '';
  return "<div class=\"jw-logo jw-logo-" + position + jwhide + " jw-reset\"></div>";
});

/***/ }),

/***/ "./src/js/templates/player.ts":
/*!************************************!*\
  !*** ./src/js/templates/player.ts ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (id, ariaLabel) {
  return "<div id=\"" + id + "\" class=\"jwplayer jw-reset jw-state-setup\" tabindex=\"0\" aria-label=\"" + (ariaLabel || '') + "\" role=\"application\">" + "<div class=\"jw-aspect jw-reset\"></div>" + "<div class=\"jw-wrapper jw-reset\">" + "<div class=\"jw-top jw-reset\"></div>" + "<div class=\"jw-aspect jw-reset\"></div>" + "<div class=\"jw-media jw-reset\"></div>" + "<div class=\"jw-preview jw-reset\"></div>" + "<div class=\"jw-title jw-reset-text\" dir=\"auto\">" + "<div class=\"jw-title-primary jw-reset-text\"></div>" + "<div class=\"jw-title-secondary jw-reset-text\"></div>" + "</div>" + "<div class=\"jw-overlays jw-reset\"></div>" + "<div class=\"jw-hidden-accessibility\">" + "<span class=\"jw-time-update\" aria-live=\"assertive\"></span>" + "<span class=\"jw-volume-update\" aria-live=\"assertive\"></span>" + "</div>" + "</div>" + "</div>";
});

/***/ }),

/***/ "./src/js/utils/can-autoplay.js":
/*!**************************************!*\
  !*** ./src/js/utils/can-autoplay.js ***!
  \**************************************/
/*! exports provided: startPlayback, AUTOPLAY_ENABLED, AUTOPLAY_MUTED, AUTOPLAY_DISABLED, canAutoplay */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startPlayback", function() { return startPlayback; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AUTOPLAY_ENABLED", function() { return AUTOPLAY_ENABLED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AUTOPLAY_MUTED", function() { return AUTOPLAY_MUTED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AUTOPLAY_DISABLED", function() { return AUTOPLAY_DISABLED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "canAutoplay", function() { return canAutoplay; });
/* harmony import */ var _providers_utils_play_promise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../providers/utils/play-promise */ "./src/js/providers/utils/play-promise.ts");
/* harmony import */ var _environment_environment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../environment/environment */ "./src/js/environment/environment.ts");
// https://github.com/video-dev/can-autoplay/tree/v3.0.0 (modified)
//
// MIT License
// Copyright (c) 2017 video-dev
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

 // Use webkitURL or mozURL as a backup if URL was overwritten

var URL = function (global) {
  return global.URL && global.URL.createObjectURL ? global.URL : global.webkitURL || global.mozURL;
}(window);

var videoBlob;
var Blob = window.Blob;
function startPlayback(element, _ref) {
  var muted = _ref.muted;

  // Lazy instantiate video blob
  if (!videoBlob) {
    /**
     * Small video file with audio.
     * Source: https://github.com/mathiasbynens/small
     *
     * @constant
     * @default
     * @type {String}
     */
    try {
      videoBlob = new Blob([new Uint8Array([0, 0, 0, 28, 102, 116, 121, 112, 105, 115, 111, 109, 0, 0, 2, 0, 105, 115, 111, 109, 105, 115, 111, 50, 109, 112, 52, 49, 0, 0, 0, 8, 102, 114, 101, 101, 0, 0, 2, 239, 109, 100, 97, 116, 33, 16, 5, 32, 164, 27, 255, 192, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55, 167, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 112, 33, 16, 5, 32, 164, 27, 255, 192, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55, 167, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 112, 0, 0, 2, 194, 109, 111, 111, 118, 0, 0, 0, 108, 109, 118, 104, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 232, 0, 0, 0, 47, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1, 236, 116, 114, 97, 107, 0, 0, 0, 92, 116, 107, 104, 100, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 101, 100, 116, 115, 0, 0, 0, 28, 101, 108, 115, 116, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 47, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 100, 109, 100, 105, 97, 0, 0, 0, 32, 109, 100, 104, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 172, 68, 0, 0, 8, 0, 85, 196, 0, 0, 0, 0, 0, 45, 104, 100, 108, 114, 0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0, 0, 0, 1, 15, 109, 105, 110, 102, 0, 0, 0, 16, 115, 109, 104, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 100, 105, 110, 102, 0, 0, 0, 28, 100, 114, 101, 102, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1, 0, 0, 0, 211, 115, 116, 98, 108, 0, 0, 0, 103, 115, 116, 115, 100, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 87, 109, 112, 52, 97, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 16, 0, 0, 0, 0, 172, 68, 0, 0, 0, 0, 0, 51, 101, 115, 100, 115, 0, 0, 0, 0, 3, 128, 128, 128, 34, 0, 2, 0, 4, 128, 128, 128, 20, 64, 21, 0, 0, 0, 0, 1, 244, 0, 0, 1, 243, 249, 5, 128, 128, 128, 2, 18, 16, 6, 128, 128, 128, 1, 2, 0, 0, 0, 24, 115, 116, 116, 115, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 4, 0, 0, 0, 0, 28, 115, 116, 115, 99, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 28, 115, 116, 115, 122, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 115, 0, 0, 1, 116, 0, 0, 0, 20, 115, 116, 99, 111, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 44, 0, 0, 0, 98, 117, 100, 116, 97, 0, 0, 0, 90, 109, 101, 116, 97, 0, 0, 0, 0, 0, 0, 0, 33, 104, 100, 108, 114, 0, 0, 0, 0, 0, 0, 0, 0, 109, 100, 105, 114, 97, 112, 112, 108, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45, 105, 108, 115, 116, 0, 0, 0, 37, 169, 116, 111, 111, 0, 0, 0, 29, 100, 97, 116, 97, 0, 0, 0, 1, 0, 0, 0, 0, 76, 97, 118, 102, 53, 54, 46, 52, 48, 46, 49, 48, 49])], {
        type: 'video/mp4'
      });
    } catch (err) {
      // Resolve autoplay test in browsers that do not support Blob creation (smart TVs)
      return Promise.resolve();
    }
  } // Resolve autoplay for Tizen


  if (_environment_environment__WEBPACK_IMPORTED_MODULE_1__["OS"].tizen) {
    return Promise.resolve();
  } // Configure element.


  element.muted = muted;
  element.src = URL.createObjectURL(videoBlob); // Start playback.

  return element.play() || Object(_providers_utils_play_promise__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
}
var AUTOPLAY_ENABLED = 'autoplayEnabled';
var AUTOPLAY_MUTED = 'autoplayMuted';
var AUTOPLAY_DISABLED = 'autoplayDisabled';
var autoplayPagePromises = {};
function canAutoplay(mediaPool, _ref2) {
  var cancelable = _ref2.cancelable,
      _ref2$muted = _ref2.muted,
      muted = _ref2$muted === void 0 ? false : _ref2$muted,
      _ref2$allowMuted = _ref2.allowMuted,
      allowMuted = _ref2$allowMuted === void 0 ? false : _ref2$allowMuted,
      _ref2$timeout = _ref2.timeout,
      timeout = _ref2$timeout === void 0 ? 10000 : _ref2$timeout;
  var element = mediaPool.getTestElement();
  var key = muted ? 'muted' : "" + allowMuted; // Skip test if it is currently running, or test previously evaluated to AUTOPLAY_ENABLED.

  if (!autoplayPagePromises[key]) {
    // Run the first test: autoplay with specified muted setting.
    autoplayPagePromises[key] = startPlayback(element, {
      muted: muted
    }).catch(function (e) {
      // Second optional test: autoplay muted.
      if (!cancelable.cancelled() && muted === false && allowMuted) {
        muted = true;
        return startPlayback(element, {
          muted: muted
        });
      }

      throw e;
    }).then(function () {
      if (muted) {
        autoplayPagePromises[key] = null; // Clear cache.

        return AUTOPLAY_MUTED;
      }

      return AUTOPLAY_ENABLED;
    }).catch(function (error) {
      clearTimeout(timeoutId);
      autoplayPagePromises[key] = null; // Clear cache.

      error.reason = AUTOPLAY_DISABLED;
      throw error;
    });
  } // If the cancelable was canceled, abort the test.


  var promise = autoplayPagePromises[key].then(function (result) {
    clearTimeout(timeoutId);

    if (cancelable.cancelled()) {
      var error = new Error('Autoplay test was cancelled');
      error.reason = 'cancelled';
      throw error;
    }

    return result;
  }); // Return playback promise, or timeout.

  var timeoutId;
  var timer = new Promise(function (resolve, reject) {
    timeoutId = setTimeout(function () {
      autoplayPagePromises[key] = null; // Clear cache.

      var error = new Error('Autoplay test timed out');
      error.reason = 'timeout';
      reject(error);
    }, timeout);
  });
  return Promise.race([promise, timer]);
}

/***/ }),

/***/ "./src/js/utils/cancelable.ts":
/*!************************************!*\
  !*** ./src/js/utils/cancelable.ts ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cancelable; });
function cancelable(callback) {
  var _cancelled = false;
  return {
    async: function async() {
      var _this = this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return Promise.resolve().then(function () {
        if (_cancelled) {
          return;
        }

        return callback.apply(_this, args);
      });
    },
    cancel: function cancel() {
      _cancelled = true;
    },
    cancelled: function cancelled() {
      return _cancelled;
    }
  };
}

/***/ }),

/***/ "./src/js/utils/in-interaction-event.ts":
/*!**********************************************!*\
  !*** ./src/js/utils/in-interaction-event.ts ***!
  \**********************************************/
/*! exports provided: inInteraction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inInteraction", function() { return inInteraction; });
function inInteraction(event) {
  event = event || window.event;
  return !!event && /^(?:mouse|pointer|touch|gesture|click|key)/.test(event.type);
}

/***/ }),

/***/ "./src/js/view/captionsrenderer.js":
/*!*****************************************!*\
  !*** ./src/js/view/captionsrenderer.js ***!
  \*****************************************/
/*! exports provided: _defaults, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_defaults", function() { return _defaults; });
/* harmony import */ var utils_underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils/underscore */ "./src/js/utils/underscore.js");
/* harmony import */ var environment_environment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! environment/environment */ "./src/js/environment/environment.ts");
/* harmony import */ var _api_core_loader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../api/core-loader */ "./src/js/api/core-loader.js");
/* harmony import */ var utils_backbone_events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! utils/backbone.events */ "./src/js/utils/backbone.events.ts");
/* harmony import */ var events_events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! events/events */ "./src/js/events/events.ts");
/* harmony import */ var utils_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! utils/css */ "./src/js/utils/css.js");
/* harmony import */ var utils_dom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! utils/dom */ "./src/js/utils/dom.js");











var _WebVTT;

var _defaults = {
  back: true,
  backgroundOpacity: 50,
  edgeStyle: null,
  fontSize: 14,
  fontOpacity: 100,
  fontScale: 0.05,
  // Default captions font size = 1/20th of the video's height
  preprocessor: utils_underscore__WEBPACK_IMPORTED_MODULE_0__["identity"],
  windowOpacity: 0
};
/**
 * Component that renders the actual captions on screen.
 * @class CaptionsRenderer
 * param {ViewModel} viewModel - The player's ViewModel instance.
 */

var CaptionsRenderer = function CaptionsRenderer(viewModel) {
  var _this = this;

  var _model = viewModel.player;

  var _options;

  var _captionsTrack;

  var _currentCues;

  var _timeEvent;

  var _display;

  var _captionsWindow;

  var _textContainer;

  var _fontScale;

  var _windowStyle;

  _display = document.createElement('div');
  _display.className = 'jw-captions jw-reset';

  this.show = function () {
    Object(utils_dom__WEBPACK_IMPORTED_MODULE_6__["addClass"])(_display, 'jw-captions-enabled');
  };

  this.hide = function () {
    Object(utils_dom__WEBPACK_IMPORTED_MODULE_6__["removeClass"])(_display, 'jw-captions-enabled');
  }; // Assign list of captions to the renderer


  this.populate = function (captions) {
    if (_model.get('renderCaptionsNatively')) {
      return;
    }

    _currentCues = [];
    _captionsTrack = captions;

    if (!captions) {
      this.renderCues();
      return;
    }

    this.selectCues(captions, _timeEvent);
  };

  this.resize = function () {
    _setFontSize();

    this.renderCues(true);
  };

  this.renderCues = function (updateBoxPosition) {
    updateBoxPosition = !!updateBoxPosition;

    if (_WebVTT) {
      _WebVTT.processCues(window, _currentCues, _display, updateBoxPosition);
    }
  };

  this.selectCues = function (track, timeEvent) {
    if (!track || !track.data || !timeEvent || _model.get('renderCaptionsNatively')) {
      return;
    }

    var pos = this.getAlignmentPosition(track, timeEvent);

    if (pos === false) {
      return;
    }

    _currentCues = this.getCurrentCues(track.data, pos);
    this.renderCues(true);
  };

  this.getCurrentCues = function (allCues, pos) {
    return Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["filter"])(allCues, function (cue) {
      return pos >= cue.startTime && (!cue.endTime || pos <= cue.endTime);
    });
  };

  this.getAlignmentPosition = function (track, timeEvent) {
    var source = track.source;
    var metadata = timeEvent.metadata;
    var time = timeEvent.currentTime; // subtitles with "source" time must be synced with "metadata[source]"

    if (source) {
      if (metadata && Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(metadata[source])) {
        time = metadata[source];
      }
    }

    return time;
  };

  this.clear = function () {
    Object(utils_dom__WEBPACK_IMPORTED_MODULE_6__["empty"])(_display);
  };
  /**
   * Initialize the captions renderer
   * @param {string} playerElementId - The player container's DOM id
   * @param {object} options - The captions styling configuration
   * @returns {void}
   */


  this.setup = function (playerElementId, options) {
    _captionsWindow = document.createElement('div');
    _textContainer = document.createElement('span');
    _captionsWindow.className = 'jw-captions-window jw-reset';
    _textContainer.className = 'jw-captions-text jw-reset';
    _options = Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["extend"])({}, _defaults, options);
    _fontScale = _defaults.fontScale;

    var styleCaptions = function styleCaptions() {
      _setFontScale(_options.fontSize);

      var windowColor = _options.windowColor;
      var windowOpacity = _options.windowOpacity;
      var edgeStyle = _options.edgeStyle;
      _windowStyle = {};
      var textStyle = {};

      _addTextStyle(textStyle, _options);

      if (windowColor || windowOpacity !== _defaults.windowOpacity) {
        _windowStyle.backgroundColor = Object(utils_css__WEBPACK_IMPORTED_MODULE_5__["getRgba"])(windowColor || '#000000', windowOpacity);
      }

      _addEdgeStyle(edgeStyle, textStyle, _options.fontOpacity);

      if (!_options.back && edgeStyle === null) {
        _addEdgeStyle('uniform', textStyle);
      }

      Object(utils_css__WEBPACK_IMPORTED_MODULE_5__["style"])(_captionsWindow, _windowStyle);
      Object(utils_css__WEBPACK_IMPORTED_MODULE_5__["style"])(_textContainer, textStyle);

      _setupCaptionStyles(playerElementId, textStyle);
    };

    styleCaptions();

    _captionsWindow.appendChild(_textContainer);

    _display.appendChild(_captionsWindow);

    _model.change('captionsTrack', function (model, captionsTrack) {
      this.populate(captionsTrack);
    }, this);

    _model.set('captions', _options);

    _model.on('change:captions', function (model, newOptions) {
      _options = newOptions;
      styleCaptions();
    });
  };

  this.element = function () {
    return _display;
  };

  this.destroy = function () {
    _model.off(null, null, this);

    this.off();
  };

  function _setFontScale() {
    if (!Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["isFinite"])(_options.fontSize)) {
      return;
    }

    var height = _model.get('containerHeight');

    if (!height) {
      _model.once('change:containerHeight', _setFontScale, this);

      return;
    } // Adjust scale based on font size relative to the default


    _fontScale = _defaults.fontScale * (_options.userFontScale || 1) * _options.fontSize / _defaults.fontSize;
  }

  function _setFontSize() {
    var height = _model.get('containerHeight');

    if (!height) {
      return;
    }

    var fontSize;

    if (_model.get('fullscreen') && environment_environment__WEBPACK_IMPORTED_MODULE_1__["OS"].iOS) {
      fontSize = null;
    } else {
      // round to 1dp to match browser precision
      var containerFontSize = height * _fontScale;
      fontSize = Math.round(getScaledFontSize(containerFontSize) * 10) / 10;
    }

    if (_model.get('renderCaptionsNatively')) {
      _setShadowDOMFontSize(_model.get('id'), fontSize);
    } else {
      // 'px' will automatically be appended if fontSize is a number
      Object(utils_css__WEBPACK_IMPORTED_MODULE_5__["style"])(_display, {
        fontSize: fontSize
      });
    }
  }

  function getScaledFontSize(fontSize) {
    var video = _model.get('mediaElement');

    if (video && video.videoHeight) {
      var videoWidth = video.videoWidth,
          videoHeight = video.videoHeight;
      var aspectVideo = videoWidth / videoHeight; // default to container dimensions for determining font size

      var containerHeight = _model.get('containerHeight');

      var containerWidth = _model.get('containerWidth'); // Use screen dimensions when in fullscreen on mobile devices


      if (_model.get('fullscreen') && environment_environment__WEBPACK_IMPORTED_MODULE_1__["OS"].mobile) {
        var _window = window,
            screen = _window.screen;

        if (screen.orientation) {
          containerHeight = screen.availHeight;
          containerWidth = screen.availWidth;
        }
      }

      if (containerWidth && containerHeight && videoWidth && videoHeight) {
        var aspectContainer = containerWidth / containerHeight;
        var height = aspectContainer > aspectVideo ? containerHeight : videoHeight * containerWidth / videoWidth;
        return height * _fontScale;
      }
    }

    return fontSize;
  }

  function _setupCaptionStyles(playerId, textStyle) {
    _setFontSize();

    _styleNativeCaptions(playerId, textStyle);

    _stylePlayerCaptions(playerId, textStyle);
  }

  function _stylePlayerCaptions(playerId, textStyle) {
    // VTT.js DOM window and text styles
    Object(utils_css__WEBPACK_IMPORTED_MODULE_5__["css"])('#' + playerId + ' .jw-text-track-display', _windowStyle, playerId);
    Object(utils_css__WEBPACK_IMPORTED_MODULE_5__["css"])('#' + playerId + ' .jw-text-track-cue', textStyle, playerId);
  }

  function _styleNativeCaptions(playerId, textStyle) {
    if (environment_environment__WEBPACK_IMPORTED_MODULE_1__["Browser"].safari) {
      // Only Safari uses a separate element for styling text background
      Object(utils_css__WEBPACK_IMPORTED_MODULE_5__["css"])('#' + playerId + ' .jw-video::-webkit-media-text-track-display-backdrop', {
        backgroundColor: textStyle.backgroundColor
      }, playerId, true);
    }

    Object(utils_css__WEBPACK_IMPORTED_MODULE_5__["css"])('#' + playerId + ' .jw-video::-webkit-media-text-track-display', _windowStyle, playerId, true);
    Object(utils_css__WEBPACK_IMPORTED_MODULE_5__["css"])('#' + playerId + ' .jw-video::cue', textStyle, playerId, true);
  }

  function _setShadowDOMFontSize(playerId, fontSize) {
    // Set Shadow DOM font size (needs to be important to override browser's in line style)
    var selector = "#" + playerId + " .jw-video::-webkit-media-text-track-display";

    if (fontSize) {
      fontSize += 'px';

      if (environment_environment__WEBPACK_IMPORTED_MODULE_1__["OS"].iOS) {
        // Force layout after exiting fullscreen
        Object(utils_css__WEBPACK_IMPORTED_MODULE_5__["css"])(selector, {
          fontSize: 'inherit'
        }, playerId, true);
      }
    }

    _windowStyle.fontSize = fontSize;
    Object(utils_css__WEBPACK_IMPORTED_MODULE_5__["css"])(selector, _windowStyle, playerId, true);
  }

  function _addTextStyle(textStyle, options) {
    var color = options.color;
    var fontOpacity = options.fontOpacity;

    if (color || fontOpacity !== _defaults.fontOpacity) {
      textStyle.color = Object(utils_css__WEBPACK_IMPORTED_MODULE_5__["getRgba"])(color || '#ffffff', fontOpacity);
    }

    if (options.back) {
      var bgColor = options.backgroundColor;
      var bgOpacity = options.backgroundOpacity;

      if (bgColor !== _defaults.backgroundColor || bgOpacity !== _defaults.backgroundOpacity) {
        textStyle.backgroundColor = Object(utils_css__WEBPACK_IMPORTED_MODULE_5__["getRgba"])(bgColor, bgOpacity);
      }
    } else {
      textStyle.background = 'transparent';
    }

    if (options.fontFamily) {
      textStyle.fontFamily = options.fontFamily;
    }

    if (options.fontStyle) {
      textStyle.fontStyle = options.fontStyle;
    }

    if (options.fontWeight) {
      textStyle.fontWeight = options.fontWeight;
    }

    if (options.textDecoration) {
      textStyle.textDecoration = options.textDecoration;
    }
  }

  function _addEdgeStyle(option, styles, fontOpacity) {
    var color = Object(utils_css__WEBPACK_IMPORTED_MODULE_5__["getRgba"])('#000000', fontOpacity);

    if (option === 'dropShadow') {
      // small drop shadow
      styles.textShadow = '0 2px 1px ' + color;
    } else if (option === 'raised') {
      // larger drop shadow
      styles.textShadow = '0 0 5px ' + color + ', 0 1px 5px ' + color + ', 0 2px 5px ' + color;
    } else if (option === 'depressed') {
      // top down shadow
      styles.textShadow = '0 -2px 1px ' + color;
    } else if (option === 'uniform') {
      // outline
      styles.textShadow = '-2px 0 1px ' + color + ',2px 0 1px ' + color + ',0 -2px 1px ' + color + ',0 2px 1px ' + color + ',-1px 1px 1px ' + color + ',1px 1px 1px ' + color + ',1px -1px 1px ' + color + ',1px 1px 1px ' + color;
    }
  }

  var _timeChange = function _timeChange(e) {
    _timeEvent = e;

    _this.selectCues(_captionsTrack, _timeEvent);
  };

  function _captionsListHandler(model, captionsList) {
    var _this2 = this;

    if (captionsList.length === 1) {
      // captionsList only contains 'off'
      return;
    } // don't load the polyfill or do unnecessary work if rendering natively


    if (!model.get('renderCaptionsNatively') && !_WebVTT) {
      loadWebVttPolyfill().catch(function (error) {
        _this2.trigger(events_events__WEBPACK_IMPORTED_MODULE_4__["WARNING"], error);
      });
      model.off('change:captionsList', _captionsListHandler, this);
    }
  }

  function loadWebVttPolyfill() {
    return __webpack_require__.e(/*! require.ensure | polyfills.webvtt */ "polyfills.webvtt").then((function (require) {
      _WebVTT = __webpack_require__(/*! polyfills/webvtt */ "./src/js/polyfills/webvtt.js").default;
    }).bind(null, __webpack_require__)).catch(Object(_api_core_loader__WEBPACK_IMPORTED_MODULE_2__["chunkLoadWarningHandler"])(301121));
  }

  _model.on('change:playlistItem', function () {
    _timeEvent = null;
    _currentCues = [];
  }, this);

  _model.on(events_events__WEBPACK_IMPORTED_MODULE_4__["MEDIA_SEEK"], function (e) {
    _currentCues = [];

    _timeChange(e);
  }, this);

  _model.on(events_events__WEBPACK_IMPORTED_MODULE_4__["MEDIA_TIME"], _timeChange, this);

  _model.on('subtitlesTrackData', function () {
    // update captions after a provider's subtitle track changes
    this.selectCues(_captionsTrack, _timeEvent);
  }, this);

  _model.on('change:captionsList', _captionsListHandler, this);
};

Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["extend"])(CaptionsRenderer.prototype, utils_backbone_events__WEBPACK_IMPORTED_MODULE_3__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (CaptionsRenderer);

/***/ }),

/***/ "./src/js/view/floating/floating-controller.ts":
/*!*****************************************************!*\
  !*** ./src/js/view/floating/floating-controller.ts ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FloatingController; });
/* harmony import */ var view_floating_floating_drag_ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! view/floating/floating-drag-ui */ "./src/js/view/floating/floating-drag-ui.js");
/* harmony import */ var environment_environment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! environment/environment */ "./src/js/environment/environment.ts");
/* harmony import */ var utils_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! utils/dom */ "./src/js/utils/dom.js");
/* harmony import */ var utils_browser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! utils/browser */ "./src/js/utils/browser.ts");
/* harmony import */ var events_events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! events/events */ "./src/js/events/events.ts");
/* harmony import */ var utils_underscore__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! utils/underscore */ "./src/js/utils/underscore.js");
/* harmony import */ var utils_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! utils/css */ "./src/js/utils/css.js");
/* harmony import */ var view_utils_views_manager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! view/utils/views-manager */ "./src/js/view/utils/views-manager.js");
/* harmony import */ var view_utils_player_size__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! view/utils/player-size */ "./src/js/view/utils/player-size.ts");










var FLOATING_TOP_OFFSET = 62;
var _floatingPlayer = null;
var fpContainer = {
  floatingPlayer: _floatingPlayer
};
Object.defineProperty(fpContainer, 'floatingPlayer', {
  get: function get() {
    return _floatingPlayer;
  },
  set: function set(val) {
    if (val === _floatingPlayer) {
      return;
    }

    _floatingPlayer = val;
    var watchersToRun = watchers.slice();
    watchers.length = 0;
    watchersToRun.forEach(function (fc) {
      fc.startFloating();
    });
  }
});
var watchers = [];

var addFPWatcher = function addFPWatcher(fc) {
  if (watchers.indexOf(fc) !== -1) {
    return;
  }

  watchers.push(fc);
};

var removeFPWatcher = function removeFPWatcher(fc) {
  var watcherIDX = watchers.indexOf(fc);

  if (watcherIDX !== -1) {
    watchers.splice(watcherIDX, 1);
  }
};

var FloatingController = /*#__PURE__*/function () {
  function FloatingController(model, playerBounds, elements, isMobile) {
    if (isMobile === void 0) {
      isMobile = environment_environment__WEBPACK_IMPORTED_MODULE_1__["OS"].mobile;
    }

    this._playerEl = elements.player;
    this._wrapperEl = elements.wrapper;
    this._preview = elements.preview;
    this._model = model;
    this._floatingUI = new view_floating_floating_drag_ui__WEBPACK_IMPORTED_MODULE_0__["default"](this._wrapperEl);
    this._floatingStoppedForever = false;
    this._lastIntRatio = 0;
    this._playerBounds = playerBounds;
    this._isMobile = isMobile;
    this._mobileCheckCanFire = true;
    this._boundThrottledMobileFloatScrollHandler = this.throttledMobileFloatScrollHandler.bind(this);
    this._boundInitFloatingBehavior = this.initFloatingBehavior.bind(this);
  }

  var _proto = FloatingController.prototype;

  _proto.setup = function setup() {
    this._model.change('floating', this._boundInitFloatingBehavior);
  };

  _proto.initFloatingBehavior = function initFloatingBehavior() {
    // Don't reinitialize this behavior if the user dismissed the floating player
    if (this._floatingStoppedForever) {
      return;
    } // Setup floating scroll handler


    view_utils_views_manager__WEBPACK_IMPORTED_MODULE_7__["default"].removeScrollHandler(this._boundThrottledMobileFloatScrollHandler);
    removeFPWatcher(this);

    if (this.getFloatingConfig()) {
      var fm = this.getFloatMode();

      if (fm === 'notVisible') {
        if (this._isMobile) {
          view_utils_views_manager__WEBPACK_IMPORTED_MODULE_7__["default"].addScrollHandler(this._boundThrottledMobileFloatScrollHandler);

          this._boundThrottledMobileFloatScrollHandler();
        } else {
          this.checkFloatIntersection();
        }
      } else if (fm === 'always') {
        this.startFloating();
      } else if (fm === 'never') {
        this.stopFloating();
      }
    }
  };

  _proto.updatePlayerBounds = function updatePlayerBounds(pb) {
    this._playerBounds = pb;
  };

  _proto.getFloatingConfig = function getFloatingConfig() {
    return this._model.get('floating');
  };

  _proto.getFloatMode = function getFloatMode() {
    var fc = this.getFloatingConfig();
    return fc && fc.mode || 'notVisible';
  };

  _proto.resize = function resize() {
    if (this._model.get('isFloating')) {
      this.updateFloatingSize();
    }
  };

  _proto.fosMobileBehavior = function fosMobileBehavior() {
    return this._isMobile && !Object(utils_dom__WEBPACK_IMPORTED_MODULE_2__["deviceIsLandscape"])() && !this._model.get('fullscreen');
  };

  _proto.shouldFloatOnViewable = function shouldFloatOnViewable() {
    var state = this._model.get('state');

    return state !== events_events__WEBPACK_IMPORTED_MODULE_4__["STATE_IDLE"] && state !== events_events__WEBPACK_IMPORTED_MODULE_4__["STATE_ERROR"] && state !== events_events__WEBPACK_IMPORTED_MODULE_4__["STATE_COMPLETE"];
  };

  _proto.startFloating = function startFloating(mobileFloatIntoPlace) {
    var _this = this;

    var playerBounds = this._playerBounds;

    if (this.getFloatingPlayer() === null) {
      this.setFloatingPlayer(this._playerEl);

      this._model.set('isFloating', true);

      Object(utils_dom__WEBPACK_IMPORTED_MODULE_2__["addClass"])(this._playerEl, 'jw-flag-floating');

      if (mobileFloatIntoPlace) {
        // Creates a dynamic animation where the top of the current player
        // Smoothly transitions into the expected floating space in the event
        // we can't start floating at 62px
        Object(utils_css__WEBPACK_IMPORTED_MODULE_6__["style"])(this._wrapperEl, {
          transform: "translateY(-" + (FLOATING_TOP_OFFSET - playerBounds.top) + "px)"
        });
        setTimeout(function () {
          Object(utils_css__WEBPACK_IMPORTED_MODULE_6__["style"])(_this._wrapperEl, {
            transform: 'translateY(0)',
            transition: 'transform 150ms cubic-bezier(0, 0.25, 0.25, 1)'
          });
        });
      } // Copy background from preview element


      var previewEl = this._preview.el;
      Object(utils_css__WEBPACK_IMPORTED_MODULE_6__["style"])(this._playerEl, {
        backgroundImage: previewEl.style.backgroundImage
      });
      this.updateFloatingSize();

      if (!this._model.get('instreamMode')) {
        this._floatingUI.enable();
      } // Perform resize and trigger "float" event responsively to prevent layout thrashing


      this._model.trigger('forceResponsiveListener', {});
    } else if (this.getFloatingPlayer() !== this._playerEl && this.getFloatMode() === 'always') {
      addFPWatcher(this);
    }
  };

  _proto.stopFloating = function stopFloating(forever, mobileFloatIntoPlace) {
    var _this2 = this;

    if (forever) {
      this._floatingStoppedForever = true;
      view_utils_views_manager__WEBPACK_IMPORTED_MODULE_7__["default"].removeScrollHandler(this._boundThrottledMobileFloatScrollHandler);
    }

    if (this.getFloatingPlayer() !== this._playerEl) {
      return;
    }

    this.setFloatingPlayer(null);

    this._model.set('isFloating', false);

    var playerBounds = this._playerBounds;

    var resetFloatingStyles = function resetFloatingStyles() {
      Object(utils_dom__WEBPACK_IMPORTED_MODULE_2__["removeClass"])(_this2._playerEl, 'jw-flag-floating');

      _this2._model.trigger('forceAspectRatioChange', {}); // Wrapper should inherit from parent unless floating.


      Object(utils_css__WEBPACK_IMPORTED_MODULE_6__["style"])(_this2._playerEl, {
        backgroundImage: null
      }); // Reset to avoid flicker.

      Object(utils_css__WEBPACK_IMPORTED_MODULE_6__["style"])(_this2._wrapperEl, {
        maxWidth: null,
        width: null,
        height: null,
        transform: null,
        transition: null,
        'transition-timing-function': null
      });
    };

    if (mobileFloatIntoPlace) {
      // Reverses a dynamic animation where the top of the current player
      // Smoothly transitions into the expected static space in the event
      // we didn't start floating at 62px
      Object(utils_css__WEBPACK_IMPORTED_MODULE_6__["style"])(this._wrapperEl, {
        transform: "translateY(-" + (FLOATING_TOP_OFFSET - playerBounds.top) + "px)",
        'transition-timing-function': 'ease-out'
      });
      setTimeout(resetFloatingStyles, 150);
    } else {
      resetFloatingStyles();
    }

    this.disableFloatingUI(); // Perform resize and trigger "float" event responsively to prevent layout thrashing

    this._model.trigger('forceResponsiveListener', {});
  };

  _proto.updateFloatingSize = function updateFloatingSize() {
    var playerBounds = this._playerBounds; // Always use aspect ratio to determine floating player size
    // This allows us to support fixed pixel width/height or 100%*100% by matching the player container

    var width = this._model.get('width');

    var height = this._model.get('height');

    var styles = Object(view_utils_player_size__WEBPACK_IMPORTED_MODULE_8__["getPlayerSizeStyles"])(this._model, width);
    styles.maxWidth = Math.min(400, playerBounds.width);

    if (!this._model.get('aspectratio')) {
      var containerWidth = playerBounds.width;
      var containerHeight = playerBounds.height;
      var aspectRatio = containerHeight / containerWidth || 0.5625; // (fallback to 16 by 9)

      if (Object(utils_underscore__WEBPACK_IMPORTED_MODULE_5__["isNumber"])(width) && Object(utils_underscore__WEBPACK_IMPORTED_MODULE_5__["isNumber"])(height)) {
        aspectRatio = height / width;
      }

      this._model.trigger('forceAspectRatioChange', {
        ratio: aspectRatio * 100 + '%'
      });
    }

    Object(utils_css__WEBPACK_IMPORTED_MODULE_6__["style"])(this._wrapperEl, styles);
  };

  _proto.enableFloatingUI = function enableFloatingUI() {
    this._floatingUI.enable();
  };

  _proto.disableFloatingUI = function disableFloatingUI() {
    this._floatingUI.disable();
  };

  _proto.setFloatingPlayer = function setFloatingPlayer(container) {
    fpContainer.floatingPlayer = container;
  };

  _proto.getFloatingPlayer = function getFloatingPlayer() {
    return fpContainer.floatingPlayer;
  };

  _proto.destroy = function destroy() {
    if (this.getFloatingPlayer() === this._playerEl) {
      this.setFloatingPlayer(null);
    }

    if (this.getFloatingConfig() && this._isMobile) {
      view_utils_views_manager__WEBPACK_IMPORTED_MODULE_7__["default"].removeScrollHandler(this._boundThrottledMobileFloatScrollHandler);
    }

    removeFPWatcher(this);

    this._model.off('change:floating', this._boundInitFloatingBehavior);
  };

  _proto.updateFloating = function updateFloating(intersectionRatio, mobileFloatIntoPlace) {
    // Player is 50% visible or less and no floating player already in the DOM. Player is not in iframe
    var shouldFloat = intersectionRatio < 0.5 && !Object(utils_browser__WEBPACK_IMPORTED_MODULE_3__["isIframe"])() && this.shouldFloatOnViewable();

    if (shouldFloat) {
      this.startFloating(mobileFloatIntoPlace);
    } else {
      this.stopFloating(false, mobileFloatIntoPlace);
    }
  } // Functions for handler float on scroll (mobile)
  ;

  _proto.checkFloatOnScroll = function checkFloatOnScroll() {
    if (this.getFloatMode() !== 'notVisible') {
      return;
    }

    var floating = this._model.get('isFloating');

    var pb = this._playerBounds;
    var enoughRoomForFloat = pb.top < FLOATING_TOP_OFFSET;
    var scrollPos = window.scrollY || window.pageYOffset;
    var hasCrossedThreshold = enoughRoomForFloat ? pb.top <= scrollPos : pb.top <= scrollPos + FLOATING_TOP_OFFSET;

    if (!floating && hasCrossedThreshold) {
      this.updateFloating(0, enoughRoomForFloat);
    } else if (floating && !hasCrossedThreshold) {
      this.updateFloating(1, enoughRoomForFloat);
    }
  };

  _proto.throttledMobileFloatScrollHandler = function throttledMobileFloatScrollHandler() {
    var _this3 = this;

    if (!this.fosMobileBehavior() || !this._model.get('inDom')) {
      return;
    }

    clearTimeout(this._mobileDebounceTimeout);
    this._mobileDebounceTimeout = setTimeout(this.checkFloatOnScroll.bind(this), 150);

    if (!this._mobileCheckCanFire) {
      return;
    }

    this._mobileCheckCanFire = false;
    this.checkFloatOnScroll();
    setTimeout(function () {
      _this3._mobileCheckCanFire = true;
    }, 50);
  } // End functions for float on scroll (mobile)
  ;

  _proto.checkFloatIntersection = function checkFloatIntersection(ratio) {
    var ratioIsNumber = typeof ratio === 'number';
    var intersectionRatio = ratioIsNumber ? ratio : this._lastIntRatio; // Ensure even if floating mode was not `notVisible` to start, that any change takes
    //  into account any instance of seeing the player

    this._canFloat = this._canFloat || intersectionRatio >= 0.5;

    if (this.getFloatingConfig() && this.getFloatMode() === 'notVisible' && !this.fosMobileBehavior() && !this._floatingStoppedForever) {
      // Only start floating if player has been mostly visible at least once.
      if (this._canFloat) {
        this.updateFloating(intersectionRatio);
      }
    }

    if (ratioIsNumber) {
      this._lastIntRatio = ratio;
    }
  };

  _proto.updateStyles = function updateStyles() {
    if (!this._floatingStoppedForever && this.getFloatingConfig() && this.getFloatMode() === 'notVisible') {
      this._boundThrottledMobileFloatScrollHandler();
    }
  };

  return FloatingController;
}();



/***/ }),

/***/ "./src/js/view/floating/floating-drag-ui.js":
/*!**************************************************!*\
  !*** ./src/js/view/floating/floating-drag-ui.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FloatingDragUI; });
/* harmony import */ var utils_ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils/ui */ "./src/js/utils/ui.js");
/* harmony import */ var utils_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! utils/css */ "./src/js/utils/css.js");
/* harmony import */ var utils_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! utils/dom */ "./src/js/utils/dom.js");




var FloatingDragUI = /*#__PURE__*/function () {
  function FloatingDragUI(element) {
    this.container = element;
    this.input = element.querySelector('.jw-media');
  }

  var _proto = FloatingDragUI.prototype;

  _proto.disable = function disable() {
    var container = this.container;

    if (container) {
      // 'Dragged' state is reset so the transition animation can fire again if the player re-floats.
      Object(utils_dom__WEBPACK_IMPORTED_MODULE_2__["removeClass"])(container, 'jw-floating-dragged');
      Object(utils_dom__WEBPACK_IMPORTED_MODULE_2__["removeClass"])(container, 'jw-floating-dragging');
      setWillChange(container, 'auto');
    }

    if (this.ui) {
      this.ui.destroy();
      this.ui = null;
    }
  };

  _proto.enable = function enable() {
    var container = this.container,
        input = this.input;
    var startX;
    var startY;
    var deltaX;
    var deltaY;
    var x = 0;
    var y = 0; // A min/max delta is assigned to prevent the player from being dragged off screen.

    var minDeltaX;
    var minDeltaY;
    var maxDeltaX;
    var maxDeltaY;
    this.ui = new utils_ui__WEBPACK_IMPORTED_MODULE_0__["default"](input, {
      preventScrolling: true
    }).on('dragStart', function (e) {
      var pageX = e.pageX,
          pageY = e.pageY;
      var _window = window,
          innerWidth = _window.innerWidth,
          innerHeight = _window.innerHeight;
      var offsetLeft = container.offsetLeft,
          offsetTop = container.offsetTop,
          offsetWidth = container.offsetWidth,
          offsetHeight = container.offsetHeight;
      startX = pageX;
      startY = pageY;
      minDeltaX = -offsetLeft;
      minDeltaY = -offsetTop;
      maxDeltaX = calculateMax(innerWidth, offsetLeft, offsetWidth);
      maxDeltaY = calculateMax(innerHeight, offsetTop, offsetHeight); // Class prevents initial animation styles from overriding translate styling.

      Object(utils_dom__WEBPACK_IMPORTED_MODULE_2__["addClass"])(container, 'jw-floating-dragged');
      Object(utils_dom__WEBPACK_IMPORTED_MODULE_2__["addClass"])(container, 'jw-floating-dragging');
      setWillChange(container, 'transform');
    }).on('drag', function (e) {
      var pageX = e.pageX,
          pageY = e.pageY;
      deltaX = calculateDelta(x, pageX, startX, maxDeltaX, minDeltaX);
      deltaY = calculateDelta(y, pageY, startY, maxDeltaY, minDeltaY);
      Object(utils_css__WEBPACK_IMPORTED_MODULE_1__["transform"])(container, "translate(" + deltaX + "px, " + deltaY + "px)");
    }).on('dragEnd', function () {
      Object(utils_dom__WEBPACK_IMPORTED_MODULE_2__["removeClass"])(container, 'jw-floating-dragging');
      setWillChange(container, 'auto');
      x = deltaX;
      y = deltaY;
    });
  };

  return FloatingDragUI;
}();



var calculateMax = function calculateMax(windowLength, offset, length) {
  return windowLength - offset - length;
};

var calculateDelta = function calculateDelta(last, current, first, max, min) {
  return Math.max(Math.min(last + current - first, max), min);
};

var setWillChange = function setWillChange(element, willChange) {
  return Object(utils_css__WEBPACK_IMPORTED_MODULE_1__["style"])(element, {
    willChange: willChange
  });
};

/***/ }),

/***/ "./src/js/view/logo.js":
/*!*****************************!*\
  !*** ./src/js/view/logo.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Logo; });
/* harmony import */ var utils_underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils/underscore */ "./src/js/utils/underscore.js");
/* harmony import */ var templates_logo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! templates/logo */ "./src/js/templates/logo.ts");
/* harmony import */ var events_events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! events/events */ "./src/js/events/events.ts");
/* harmony import */ var utils_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! utils/ui */ "./src/js/utils/ui.js");
/* harmony import */ var utils_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! utils/css */ "./src/js/utils/css.js");
/* harmony import */ var utils_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! utils/dom */ "./src/js/utils/dom.js");
/* harmony import */ var utils_backbone_events__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! utils/backbone.events */ "./src/js/utils/backbone.events.ts");








var LogoDefaults = {
  linktarget: '_blank',
  margin: 8,
  hide: false,
  position: 'top-right'
};
function Logo(_model) {
  Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["extend"])(this, utils_backbone_events__WEBPACK_IMPORTED_MODULE_6__["default"]);

  var _logo;

  var _settings;

  var _img = new Image();

  this.setup = function () {
    _settings = Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["extend"])({}, LogoDefaults, _model.get('logo'));
    _settings.position = _settings.position || LogoDefaults.position;
    _settings.hide = _settings.hide.toString() === 'true'; // We should only create a logo in the display container when
    // it is not supposed to be in the control bar, as it will
    // handle the creation in that case

    if (!_settings.file || _settings.position === 'control-bar') {
      return;
    }

    if (!_logo) {
      _logo = Object(utils_dom__WEBPACK_IMPORTED_MODULE_5__["createElement"])(Object(templates_logo__WEBPACK_IMPORTED_MODULE_1__["default"])(_settings.position, _settings.hide));
    }

    _model.set('logo', _settings); // apply styles onload when image width and height are known


    _img.onload = function () {
      // update logo style
      var height = this.height;
      var width = this.width;
      var styles = {
        backgroundImage: 'url("' + this.src + '")'
      };

      if (_settings.margin !== LogoDefaults.margin) {
        var positions = /(\w+)-(\w+)/.exec(_settings.position);

        if (positions.length === 3) {
          styles['margin-' + positions[1]] = _settings.margin;
          styles['margin-' + positions[2]] = _settings.margin;
        }
      } // Constraint logo size to 15% of their respective player dimension


      var maxHeight = _model.get('containerHeight') * 0.15;
      var maxWidth = _model.get('containerWidth') * 0.15;

      if (height > maxHeight || width > maxWidth) {
        var logoAR = width / height;
        var videoAR = maxWidth / maxHeight;

        if (videoAR > logoAR) {
          // height = max dimension
          height = maxHeight;
          width = maxHeight * logoAR;
        } else {
          // width = max dimension
          width = maxWidth;
          height = maxWidth / logoAR;
        }
      }

      styles.width = Math.round(width);
      styles.height = Math.round(height);
      Object(utils_css__WEBPACK_IMPORTED_MODULE_4__["style"])(_logo, styles); // update title

      _model.set('logoWidth', styles.width);
    };

    _img.src = _settings.file;

    if (_settings.link) {
      _logo.setAttribute('tabindex', '0');

      _logo.setAttribute('aria-label', _model.get('localization').logo);
    }

    this.ui = new utils_ui__WEBPACK_IMPORTED_MODULE_3__["default"](_logo).on('click tap enter', function (evt) {
      if (evt && evt.stopPropagation) {
        evt.stopPropagation();
      }

      this.trigger(events_events__WEBPACK_IMPORTED_MODULE_2__["LOGO_CLICK"], {
        link: _settings.link,
        linktarget: _settings.linktarget
      });
    }, this);
  };

  this.setContainer = function (container) {
    if (_logo) {
      container.appendChild(_logo);
    }
  };

  this.element = function () {
    return _logo;
  };

  this.position = function () {
    return _settings.position;
  };

  this.destroy = function () {
    _img.onload = null;

    if (this.ui) {
      this.ui.destroy();
    }
  };
}

/***/ }),

/***/ "./src/js/view/preview.ts":
/*!********************************!*\
  !*** ./src/js/view/preview.ts ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var utils_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils/css */ "./src/js/utils/css.js");


var Preview = /*#__PURE__*/function () {
  function Preview(_model) {
    this.model = _model;
    this.image = null;
  }

  var _proto = Preview.prototype;

  _proto.setup = function setup(el) {
    this.el = el;
    this.hasZoomThumbnail = this.model.get('_abZoomThumbnail');

    if (this.hasZoomThumbnail) {
      this.zoomOriginX = Math.ceil(Math.random() * 100) + '%';
      this.zoomOriginY = Math.ceil(Math.random() * 100) + '%';
      this.model.on('change:viewable', this.pauseZoomThumbnail, this);
      this.model.on('change:isFloating', this.enableZoomThumbnail, this);
    }
  };

  _proto.setImage = function setImage(img) {
    // Remove onload function from previous image
    var image = this.image;

    if (image) {
      image.onload = null;
    }

    this.image = null;
    var backgroundImage = '';

    if (typeof img === 'string') {
      backgroundImage = 'url("' + img + '")';
      image = this.image = new Image();
      image.src = img;
    }

    if (this.hasZoomThumbnail) {
      this.imageEl = document.createElement('div');
      Object(utils_css__WEBPACK_IMPORTED_MODULE_0__["style"])(this.imageEl, {
        backgroundImage: backgroundImage
      });

      if (this.el) {
        this.el.appendChild(this.imageEl);
      }

      this.enableZoomThumbnail();
    } else {
      Object(utils_css__WEBPACK_IMPORTED_MODULE_0__["style"])(this.el, {
        backgroundImage: backgroundImage
      });
    }
  };

  _proto.enableZoomThumbnail = function enableZoomThumbnail() {
    var _this = this;

    if (!this.hasZoomThumbnail || this.model.get('isFloating')) {
      return;
    }

    clearTimeout(this.zoomThumbnailTimeout);
    this.zoomThumbnailTimeout = setTimeout(function () {
      if (_this.imageEl) {
        _this.imageEl.classList.add('jw-ab-zoom-thumbnail');

        _this.imageEl.style.transformOrigin = _this.zoomOriginX + ' ' + _this.zoomOriginY;
      }
    }, 2000);
  };

  _proto.pauseZoomThumbnail = function pauseZoomThumbnail() {
    clearTimeout(this.zoomThumbnailTimeout);

    if (this.imageEl) {
      this.imageEl.style.animationPlayState = this.model.get('viewable') ? 'running' : 'paused';
    }
  };

  _proto.removeZoomThumbnail = function removeZoomThumbnail() {
    clearTimeout(this.zoomThumbnailTimeout);

    if (this.imageEl) {
      this.imageEl.classList.remove('jw-ab-zoom-thumbnail');
    }
  };

  _proto.resize = function resize(width, height, stretching) {
    var _this2 = this;

    if (stretching === 'uniform') {
      if (width) {
        this.playerAspectRatio = width / height;
      }

      if (!this.playerAspectRatio || !this.image || !validState(this.model.get('state'))) {
        return;
      } // snap image to edges when the difference in aspect ratio is less than 9%


      var image = this.image;
      var backgroundSize = null;

      if (image) {
        if (image.width === 0) {
          image.onload = function () {
            _this2.resize(width, height, stretching);
          };

          return;
        }

        var imageAspectRatio = image.width / image.height;

        if (Math.abs(this.playerAspectRatio - imageAspectRatio) < 0.09) {
          backgroundSize = 'cover';
        }
      }

      Object(utils_css__WEBPACK_IMPORTED_MODULE_0__["style"])(this.el, {
        backgroundSize: backgroundSize
      });
    }
  };

  _proto.element = function element() {
    return this.el;
  };

  _proto.destroy = function destroy() {
    if (this.hasZoomThumbnail) {
      this.removeZoomThumbnail();
      this.model.off(null, null, this);
    }
  };

  return Preview;
}();

function validState(state) {
  return state === 'complete' || state === 'idle' || state === 'error' || state === 'buffering';
}

/* harmony default export */ __webpack_exports__["default"] = (Preview);

/***/ }),

/***/ "./src/js/view/title.ts":
/*!******************************!*\
  !*** ./src/js/view/title.ts ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var utils_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils/css */ "./src/js/utils/css.js");
/* harmony import */ var utils_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! utils/dom */ "./src/js/utils/dom.js");
/* harmony import */ var environment_environment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! environment/environment */ "./src/js/environment/environment.ts");




var Title = /*#__PURE__*/function () {
  function Title(_model) {
    this.model = _model.player;
    this.truncated = _model.get('__ab_truncated') && !environment_environment__WEBPACK_IMPORTED_MODULE_2__["Browser"].ie;
  } // This is normally shown/hidden by states
  //   these are only used for when no title exists


  var _proto = Title.prototype;

  _proto.hide = function hide() {
    Object(utils_css__WEBPACK_IMPORTED_MODULE_0__["style"])(this.el, {
      display: 'none'
    });
  };

  _proto.show = function show() {
    Object(utils_css__WEBPACK_IMPORTED_MODULE_0__["style"])(this.el, {
      display: ''
    });
  };

  _proto.setup = function setup(titleEl) {
    this.el = titleEl;

    if (!this.el) {
      return;
    } // Perform the DOM search only once


    var arr = this.el.getElementsByTagName('div');
    this.title = arr[0];
    this.description = arr[1];

    if (this.truncated) {
      this.el.classList.add('jw-ab-truncated');
    }

    this.model.on('change:logoWidth', this.update, this);
    this.model.change('playlistItem', this.playlistItem, this);
  };

  _proto.update = function update(model) {
    var titleStyle = {};
    var logo = model.get('logo');

    if (logo) {
      // Only use Numeric or pixel ("Npx") margin values
      var margin = 1 * parseInt(('' + logo.margin).replace('px', ''));
      var padding = model.get('logoWidth') + (isNaN(margin) ? 0 : margin + 10);

      if (logo.position === 'top-left') {
        titleStyle.paddingLeft = padding;
      } else if (logo.position === 'top-right') {
        titleStyle.paddingRight = padding;
      }
    }

    Object(utils_css__WEBPACK_IMPORTED_MODULE_0__["style"])(this.el, titleStyle);
  };

  _proto.playlistItem = function playlistItem(model, item) {
    if (!item) {
      return;
    }

    if (model.get('displaytitle') || model.get('displaydescription')) {
      var title = '';
      var description = '';

      if (item.title && model.get('displaytitle')) {
        title = item.title;
      }

      if (item.description && model.get('displaydescription')) {
        description = item.description;
      }

      this.updateText(title, description);
    } else {
      this.hide();
    }
  };

  _proto.updateText = function updateText(title, description) {
    if (!this.title || !this.description) {
      return;
    }

    Object(utils_dom__WEBPACK_IMPORTED_MODULE_1__["replaceInnerHtml"])(this.title, title);
    Object(utils_dom__WEBPACK_IMPORTED_MODULE_1__["replaceInnerHtml"])(this.description, description);

    if (this.title.firstChild || this.description.firstChild) {
      this.show();
    } else {
      this.hide();
    }
  };

  _proto.element = function element() {
    return this.el;
  };

  return Title;
}();

/* harmony default export */ __webpack_exports__["default"] = (Title);

/***/ }),

/***/ "./src/js/view/utils/audio-mode.ts":
/*!*****************************************!*\
  !*** ./src/js/view/utils/audio-mode.ts ***!
  \*****************************************/
/*! exports provided: CONTROLBAR_ONLY_HEIGHT, isAudioMode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONTROLBAR_ONLY_HEIGHT", function() { return CONTROLBAR_ONLY_HEIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAudioMode", function() { return isAudioMode; });
var CONTROLBAR_ONLY_HEIGHT = 44;
var isAudioMode = function isAudioMode(model) {
  var playerHeight = model.get('height');

  if (model.get('aspectratio')) {
    return false;
  }

  if (typeof playerHeight === 'string' && playerHeight.indexOf('%') > -1) {
    return false;
  } // Coerce into Number (don't parse out CSS units)


  var verticalPixels = playerHeight * 1 || NaN;
  verticalPixels = !isNaN(verticalPixels) ? verticalPixels : model.get('containerHeight');

  if (!verticalPixels) {
    return false;
  }

  return !!(verticalPixels && verticalPixels <= CONTROLBAR_ONLY_HEIGHT);
};

/***/ }),

/***/ "./src/js/view/utils/breakpoint.ts":
/*!*****************************************!*\
  !*** ./src/js/view/utils/breakpoint.ts ***!
  \*****************************************/
/*! exports provided: getBreakpoint, setBreakpoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBreakpoint", function() { return getBreakpoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setBreakpoint", function() { return setBreakpoint; });
/* harmony import */ var utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils/dom */ "./src/js/utils/dom.js");

function getBreakpoint(width) {
  var breakpoint = -1;

  if (width >= 1280) {
    breakpoint = 7;
  } else if (width >= 960) {
    breakpoint = 6;
  } else if (width >= 800) {
    breakpoint = 5;
  } else if (width >= 640) {
    breakpoint = 4;
  } else if (width >= 540) {
    breakpoint = 3;
  } else if (width >= 420) {
    breakpoint = 2;
  } else if (width >= 320) {
    breakpoint = 1;
  } else if (width >= 250) {
    breakpoint = 0;
  }

  return breakpoint;
}
function setBreakpoint(playerElement, breakpointNumber) {
  var breakpointClass = 'jw-breakpoint-' + breakpointNumber;
  Object(utils_dom__WEBPACK_IMPORTED_MODULE_0__["replaceClass"])(playerElement, /jw-breakpoint--?\d+/, breakpointClass);
}

/***/ }),

/***/ "./src/js/view/utils/clickhandler.ts":
/*!*******************************************!*\
  !*** ./src/js/view/utils/clickhandler.ts ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ClickHandler; });
/* harmony import */ var events_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events/events */ "./src/js/events/events.ts");
/* harmony import */ var utils_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! utils/ui */ "./src/js/utils/ui.js");
/* harmony import */ var utils_backbone_events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! utils/backbone.events */ "./src/js/utils/backbone.events.ts");
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }





var ClickHandler = /*#__PURE__*/function (_Events) {
  _inheritsLoose(ClickHandler, _Events);

  function ClickHandler(model, element) {
    var _this;

    _this = _Events.call(this) || this;

    _this.revertAlternateClickHandlers();

    _this.domElement = element;
    _this.model = model;
    _this.ui = new utils_ui__WEBPACK_IMPORTED_MODULE_1__["default"](element).on('click tap', _this.clickHandler, _assertThisInitialized(_assertThisInitialized(_this))).on('doubleClick doubleTap', function () {
      if (this.alternateDoubleClickHandler) {
        this.alternateDoubleClickHandler();
        return;
      }

      this.trigger('doubleClick');
    }, _assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }

  var _proto = ClickHandler.prototype;

  _proto.destroy = function destroy() {
    if (this.ui) {
      this.ui.destroy();
      this.ui = null;
      this.domElement = null;
      this.model = null;
      this.revertAlternateClickHandlers();
    }
  };

  _proto.clickHandler = function clickHandler(evt) {
    if (!this.model) {
      return;
    }

    if (this.alternateClickHandler) {
      this.alternateClickHandler(evt);
      return;
    }

    this.trigger(evt.type === events_events__WEBPACK_IMPORTED_MODULE_0__["CLICK"] ? 'click' : 'tap');
  };

  _proto.element = function element() {
    return this.domElement;
  };

  _proto.setAlternateClickHandlers = function setAlternateClickHandlers(clickHandler, doubleClickHandler) {
    this.alternateClickHandler = clickHandler;
    this.alternateDoubleClickHandler = doubleClickHandler || null;
  };

  _proto.revertAlternateClickHandlers = function revertAlternateClickHandlers() {
    this.alternateClickHandler = null;
    this.alternateDoubleClickHandler = null;
  };

  return ClickHandler;
}(utils_backbone_events__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/view/utils/player-size.ts":
/*!******************************************!*\
  !*** ./src/js/view/utils/player-size.ts ***!
  \******************************************/
/*! exports provided: getPlayerSizeStyles */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPlayerSizeStyles", function() { return getPlayerSizeStyles; });
/* harmony import */ var utils_underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils/underscore */ "./src/js/utils/underscore.js");
/* harmony import */ var view_utils_audio_mode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! view/utils/audio-mode */ "./src/js/view/utils/audio-mode.ts");


function getPlayerSizeStyles(model, playerWidth, playerHeight, resetAspectMode) {
  var styles = {
    width: playerWidth
  }; // when jwResize is called remove aspectMode and force layout

  if (resetAspectMode && playerHeight !== undefined) {
    model.set('aspectratio', null);
  }

  if (!model.get('aspectratio')) {
    // If the height is a pixel value (number) greater than 0, snap it to the minimum supported height
    // Allow zero to mean "hide the player"
    var height = playerHeight;

    if (Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(height) && height !== 0) {
      height = Math.max(height, view_utils_audio_mode__WEBPACK_IMPORTED_MODULE_1__["CONTROLBAR_ONLY_HEIGHT"]);
    }

    styles.height = height;
  }

  return styles;
}

/***/ }),

/***/ "./src/js/view/utils/request-fullscreen-helper.js":
/*!********************************************************!*\
  !*** ./src/js/view/utils/request-fullscreen-helper.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var DOCUMENT_FULLSCREEN_EVENTS = ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'];
/* harmony default export */ __webpack_exports__["default"] = (function (elementContext, documentContext, changeCallback) {
  var _requestFullscreen = elementContext.requestFullscreen || elementContext.webkitRequestFullscreen || elementContext.webkitRequestFullScreen || elementContext.mozRequestFullScreen || elementContext.msRequestFullscreen;

  var _exitFullscreen = documentContext.exitFullscreen || documentContext.webkitExitFullscreen || documentContext.webkitCancelFullScreen || documentContext.mozCancelFullScreen || documentContext.msExitFullscreen;

  var _supportsDomFullscreen = !!(_requestFullscreen && _exitFullscreen);

  for (var i = DOCUMENT_FULLSCREEN_EVENTS.length; i--;) {
    documentContext.addEventListener(DOCUMENT_FULLSCREEN_EVENTS[i], changeCallback);
  }

  return {
    events: DOCUMENT_FULLSCREEN_EVENTS,
    supportsDomFullscreen: function supportsDomFullscreen() {
      return _supportsDomFullscreen;
    },
    requestFullscreen: function requestFullscreen() {
      _requestFullscreen.call(elementContext, {
        navigationUI: 'hide'
      });
    },
    exitFullscreen: function exitFullscreen() {
      if (this.fullscreenElement() !== null) {
        _exitFullscreen.apply(documentContext);
      }
    },
    fullscreenElement: function fullscreenElement() {
      var fullscreenElement = documentContext.fullscreenElement,
          webkitCurrentFullScreenElement = documentContext.webkitCurrentFullScreenElement,
          mozFullScreenElement = documentContext.mozFullScreenElement,
          msFullscreenElement = documentContext.msFullscreenElement;

      if (fullscreenElement === null) {
        return fullscreenElement;
      }

      return fullscreenElement || webkitCurrentFullScreenElement || mozFullScreenElement || msFullscreenElement;
    },
    destroy: function destroy() {
      for (var _i = DOCUMENT_FULLSCREEN_EVENTS.length; _i--;) {
        documentContext.removeEventListener(DOCUMENT_FULLSCREEN_EVENTS[_i], changeCallback);
      }
    }
  };
});

/***/ }),

/***/ "./src/js/view/utils/skin.js":
/*!***********************************!*\
  !*** ./src/js/view/utils/skin.js ***!
  \***********************************/
/*! exports provided: normalizeSkin, handleColorOverrides */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeSkin", function() { return normalizeSkin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handleColorOverrides", function() { return handleColorOverrides; });
/* harmony import */ var utils_strings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils/strings */ "./src/js/utils/strings.ts");
/* harmony import */ var utils_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! utils/css */ "./src/js/utils/css.js");


function normalizeSkin(skinConfig) {
  if (!skinConfig) {
    skinConfig = {};
  }

  var active = skinConfig.active;
  var inactive = skinConfig.inactive;
  var background = skinConfig.background;
  var colors = {};
  colors.controlbar = getControlBar(skinConfig.controlbar);
  colors.timeslider = getTimeSlider(skinConfig.timeslider);
  colors.menus = getMenus(skinConfig.menus);
  colors.tooltips = getTooltips(skinConfig.tooltips);

  function getControlBar(controlBarConfig) {
    if (controlBarConfig || active || inactive || background) {
      var config = {};
      controlBarConfig = controlBarConfig || {};
      config.iconsActive = controlBarConfig.iconsActive || active;
      config.icons = controlBarConfig.icons || inactive;
      config.text = controlBarConfig.text || inactive;
      config.background = controlBarConfig.background || background;
      return config;
    }
  }

  function getTimeSlider(timesliderConfig) {
    if (timesliderConfig || active) {
      var config = {};
      timesliderConfig = timesliderConfig || {};
      config.progress = timesliderConfig.progress || active;
      config.rail = timesliderConfig.rail;
      return config;
    }
  }

  function getMenus(menusConfig) {
    if (menusConfig || active || inactive || background) {
      var config = {};
      menusConfig = menusConfig || {};
      config.text = menusConfig.text || inactive;
      config.textActive = menusConfig.textActive || active;
      config.background = menusConfig.background || background;
      return config;
    }
  }

  function getTooltips(tooltipsConfig) {
    if (tooltipsConfig || inactive || background) {
      var config = {};
      tooltipsConfig = tooltipsConfig || {};
      config.text = tooltipsConfig.text || inactive;
      config.background = tooltipsConfig.background || background;
      return config;
    }
  }

  return colors;
}
function handleColorOverrides(playerId, skin) {
  if (!skin) {
    return;
  }

  function addStyle(elements, attr, value, extendParent) {
    if (!value) {
      return;
    }
    /* if extendParent is true, bundle the first selector of
     element string to the player element instead of defining it as a
     child of the player element (default). i.e. #player.sel-1 .sel-2 vs. #player .sel-1 .sel-2 */


    elements = Object(utils_strings__WEBPACK_IMPORTED_MODULE_0__["prefix"])(elements, '#' + playerId + (extendParent ? '' : ' '));
    var o = {};
    o[attr] = value;
    Object(utils_css__WEBPACK_IMPORTED_MODULE_1__["css"])(elements.join(', '), o, playerId);
  } // These will use standard style names for CSS since they are added directly to a style sheet
  // Using background instead of background-color so we don't have to clear gradients with background-image


  if (skin.controlbar) {
    styleControlbar(skin.controlbar);
  }

  if (skin.timeslider) {
    styleTimeslider(skin.timeslider);
  }

  if (skin.menus) {
    styleMenus(skin.menus);
  }

  if (skin.tooltips) {
    styleTooltips(skin.tooltips);
  }

  if (skin.menus) {
    insertGlobalColorClasses(skin.menus);
  }

  function styleControlbar(config) {
    addStyle([// controlbar text colors
    '.jw-controlbar .jw-icon-inline.jw-text', '.jw-title-primary', '.jw-title-secondary'], 'color', config.text);

    if (config.icons) {
      addStyle([// controlbar button colors
      '.jw-button-color:not(.jw-icon-cast)', '.jw-button-color.jw-toggle.jw-off:not(.jw-icon-cast)'], 'color', config.icons);
      addStyle(['.jw-display-icon-container .jw-button-color'], 'color', config.icons); // Chromecast overrides
      // Can't use addStyle since it will camel case the style name

      Object(utils_css__WEBPACK_IMPORTED_MODULE_1__["css"])("#" + playerId + " .jw-icon-cast google-cast-launcher.jw-off", "{--disconnected-color: " + config.icons + "}", playerId);
    }

    if (config.iconsActive) {
      addStyle(['.jw-display-icon-container .jw-button-color:hover', '.jw-display-icon-container .jw-button-color:focus'], 'color', config.iconsActive); // Apply active color

      addStyle([// Toggle and menu button active colors
      '.jw-button-color.jw-toggle:not(.jw-icon-cast)', '.jw-button-color:hover:not(.jw-icon-cast)', '.jw-button-color:focus:not(.jw-icon-cast)', '.jw-button-color.jw-toggle.jw-off:hover:not(.jw-icon-cast)'], 'color', config.iconsActive);
      addStyle(['.jw-svg-icon-buffer'], 'fill', config.icons); // Chromecast overrides
      // Can't use addStyle since it will camel case the style name

      Object(utils_css__WEBPACK_IMPORTED_MODULE_1__["css"])("#" + playerId + " .jw-icon-cast:hover google-cast-launcher.jw-off", "{--disconnected-color: " + config.iconsActive + "}", playerId);
      Object(utils_css__WEBPACK_IMPORTED_MODULE_1__["css"])("#" + playerId + " .jw-icon-cast:focus google-cast-launcher.jw-off", "{--disconnected-color: " + config.iconsActive + "}", playerId);
      Object(utils_css__WEBPACK_IMPORTED_MODULE_1__["css"])("#" + playerId + " .jw-icon-cast google-cast-launcher.jw-off:focus", "{--disconnected-color: " + config.iconsActive + "}", playerId);
      Object(utils_css__WEBPACK_IMPORTED_MODULE_1__["css"])("#" + playerId + " .jw-icon-cast google-cast-launcher", "{--connected-color: " + config.iconsActive + "}", playerId);
      Object(utils_css__WEBPACK_IMPORTED_MODULE_1__["css"])("#" + playerId + " .jw-icon-cast google-cast-launcher:focus", "{--connected-color: " + config.iconsActive + "}", playerId);
      Object(utils_css__WEBPACK_IMPORTED_MODULE_1__["css"])("#" + playerId + " .jw-icon-cast:hover google-cast-launcher", "{--connected-color: " + config.iconsActive + "}", playerId);
      Object(utils_css__WEBPACK_IMPORTED_MODULE_1__["css"])("#" + playerId + " .jw-icon-cast:focus google-cast-launcher", "{--connected-color: " + config.iconsActive + "}", playerId);
    } // A space is purposefully left before '.jw-settings-topbar' since extendParent is set to true in order to append ':not(.jw-state-idle)'


    addStyle([' .jw-settings-topbar', ':not(.jw-state-idle) .jw-controlbar', '.jw-flag-audio-player .jw-controlbar'], 'background', config.background, true);
  }

  function styleTimeslider(config) {
    var progress = config.progress;

    if (progress !== 'none') {
      addStyle(['.jw-progress', '.jw-knob'], 'background-color', progress);
      addStyle(['.jw-buffer'], 'background-color', Object(utils_css__WEBPACK_IMPORTED_MODULE_1__["getRgba"])(progress, 50));
    }

    addStyle(['.jw-rail'], 'background-color', config.rail);
    addStyle(['.jw-background-color.jw-slider-time', '.jw-slider-time .jw-cue'], 'background-color', config.background);
  }

  function styleMenus(config) {
    addStyle(['.jw-option', '.jw-toggle.jw-off', '.jw-skip .jw-skip-icon', '.jw-nextup-tooltip', '.jw-nextup-close', '.jw-settings-content-item', '.jw-related-title'], 'color', config.text);
    addStyle(['.jw-option.jw-active-option', '.jw-option:not(.jw-active-option):hover', '.jw-option:not(.jw-active-option):focus', '.jw-settings-content-item:hover', '.jw-nextup-tooltip:hover', '.jw-nextup-tooltip:focus', '.jw-nextup-close:hover'], 'color', config.textActive);
    addStyle(['.jw-nextup', '.jw-settings-menu'], 'background', config.background);
  }

  function styleTooltips(config) {
    addStyle(['.jw-skip', '.jw-tooltip .jw-text', '.jw-time-tip .jw-text'], 'background-color', config.background);
    addStyle(['.jw-time-tip', '.jw-tooltip'], 'color', config.background);
    addStyle(['.jw-skip'], 'border', 'none');
    addStyle(['.jw-skip .jw-text', '.jw-skip .jw-icon', '.jw-time-tip .jw-text', '.jw-tooltip .jw-text'], 'color', config.text);
  } // Set global colors, used by related plugin
  // If a color is undefined simple-style-loader won't add their styles to the dom


  function insertGlobalColorClasses(config) {
    if (config.textActive) {
      var activeColorSet = {
        color: config.textActive,
        borderColor: config.textActive,
        stroke: config.textActive
      };
      Object(utils_css__WEBPACK_IMPORTED_MODULE_1__["css"])("#" + playerId + " .jw-color-active", activeColorSet, playerId);
      Object(utils_css__WEBPACK_IMPORTED_MODULE_1__["css"])("#" + playerId + " .jw-color-active-hover:hover", activeColorSet, playerId);
    }

    if (config.text) {
      var inactiveColorSet = {
        color: config.text,
        borderColor: config.text,
        stroke: config.text
      };
      Object(utils_css__WEBPACK_IMPORTED_MODULE_1__["css"])("#" + playerId + " .jw-color-inactive", inactiveColorSet, playerId);
      Object(utils_css__WEBPACK_IMPORTED_MODULE_1__["css"])("#" + playerId + " .jw-color-inactive-hover:hover", inactiveColorSet, playerId);
    }
  }
}

/***/ }),

/***/ "./src/js/view/utils/visibility.js":
/*!*****************************************!*\
  !*** ./src/js/view/utils/visibility.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getVisibility; });
function getVisibility(model, element) {
  // Set visibility to 1 if we're in fullscreen
  if (model.get('fullscreen')) {
    return 1;
  } // Set visibility to 0 if we're not in the active tab


  if (!model.get('activeTab')) {
    return 0;
  } // Set visibility to 1 if we're floating in the active tab


  if (model.get('isFloating')) {
    return 1;
  } // Otherwise, set it to the intersection ratio reported from the intersection observer


  var intersectionRatio = model.get('intersectionRatio');

  if (intersectionRatio === undefined) {
    // Get intersectionRatio through brute force
    intersectionRatio = computeVisibility(element); // Disregard intersectionRatio if it returns that the player is viewable in iFrame

    if (window.top !== window.self && intersectionRatio) {
      return 0;
    }
  }

  return intersectionRatio;
}

function computeVisibility(target) {
  var html = document.documentElement;
  var body = document.body;
  var rootRect = {
    top: 0,
    left: 0,
    right: html.clientWidth || body.clientWidth,
    width: html.clientWidth || body.clientWidth,
    bottom: html.clientHeight || body.clientHeight,
    height: html.clientHeight || body.clientHeight
  };

  if (!body.contains(target)) {
    return 0;
  } // If the element isn't displayed, an intersection can't happen.


  if (window.getComputedStyle(target).display === 'none') {
    return 0;
  }

  var targetRect = getBoundingClientRect(target);

  if (!targetRect) {
    return 0;
  }

  var intersectionRect = targetRect;
  var parent = target.parentNode;
  var atRoot = false;

  while (!atRoot) {
    var parentRect = null;

    if (parent === body || parent === html || parent.nodeType !== 1) {
      atRoot = true;
      parentRect = rootRect;
    } else if (window.getComputedStyle(parent).overflow !== 'visible') {
      parentRect = getBoundingClientRect(parent);
    }

    if (parentRect) {
      intersectionRect = computeRectIntersection(parentRect, intersectionRect);

      if (!intersectionRect) {
        return 0;
      }
    }

    parent = parent.parentNode;
  }

  var targetArea = targetRect.width * targetRect.height;
  var intersectionArea = intersectionRect.width * intersectionRect.height;
  return targetArea ? intersectionArea / targetArea : 0;
}

function getBoundingClientRect(el) {
  try {
    return el.getBoundingClientRect();
  } catch (e) {
    /* ignore Windows 7 IE11 "Unspecified error" */
  }
}

function computeRectIntersection(rect1, rect2) {
  var top = Math.max(rect1.top, rect2.top);
  var bottom = Math.min(rect1.bottom, rect2.bottom);
  var left = Math.max(rect1.left, rect2.left);
  var right = Math.min(rect1.right, rect2.right);
  var width = right - left;
  var height = bottom - top;
  return width >= 0 && height >= 0 && {
    top: top,
    bottom: bottom,
    left: left,
    right: right,
    width: width,
    height: height
  };
}

/***/ }),

/***/ "./src/js/view/view-model.ts":
/*!***********************************!*\
  !*** ./src/js/view/view-model.ts ***!
  \***********************************/
/*! exports provided: PlayerViewModel, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlayerViewModel", function() { return PlayerViewModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ViewModel; });
/* harmony import */ var utils_underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils/underscore */ "./src/js/utils/underscore.js");
/* harmony import */ var model_simplemodel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! model/simplemodel */ "./src/js/model/simplemodel.ts");



function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }


var changeEventRegEx = /^change:(.+)$/;

function dispatchDiffChangeEvents(viewModel, newAttributes, oldAttributes) {
  Object.keys(newAttributes).forEach(function (attr) {
    if (attr in newAttributes && newAttributes[attr] !== oldAttributes[attr]) {
      viewModel.trigger("change:" + attr, viewModel, newAttributes[attr], oldAttributes[attr]);
    }
  });
}

function removeListeners(instance, viewModel) {
  if (instance) {
    instance.off(null, null, viewModel);
  }
}

var PlayerViewModel = /*#__PURE__*/function (_SimpleModel) {
  _inheritsLoose(PlayerViewModel, _SimpleModel);

  function PlayerViewModel(playerModel, eventFilter) {
    var _this;

    _this = _SimpleModel.call(this) || this;
    _this._model = playerModel;
    _this._mediaModel = null;

    Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["extend"])(playerModel.attributes, {
      altText: '',
      fullscreen: false,
      logoWidth: 0,
      scrubbing: false
    });

    playerModel.on('all', function (type, objectOrEvent, value, previousValue) {
      if (objectOrEvent === playerModel) {
        objectOrEvent = _assertThisInitialized(_assertThisInitialized(_this));
      }

      if (!eventFilter || eventFilter(type, objectOrEvent, value, previousValue)) {
        _this.trigger(type, objectOrEvent, value, previousValue);
      }
    }, _assertThisInitialized(_assertThisInitialized(_this)));
    playerModel.on('change:mediaModel', function (model, mediaModel) {
      _this.mediaModel = mediaModel;
    }, _assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }

  var _proto = PlayerViewModel.prototype;

  _proto.get = function get(attr) {
    var mediaModel = this._mediaModel;

    if (mediaModel && attr in mediaModel.attributes) {
      return mediaModel.get(attr);
    }

    return this._model.get(attr);
  };

  _proto.set = function set(attr, val) {
    return this._model.set(attr, val);
  };

  _proto.getVideo = function getVideo() {
    return this._model.getVideo();
  };

  _proto.destroy = function destroy() {
    removeListeners(this._model, this);
    removeListeners(this._mediaModel, this);
    this.off();
  };

  _createClass(PlayerViewModel, [{
    key: "mediaModel",
    set: function set(mediaModel) {
      var _this2 = this;

      var previousMediaModel = this._mediaModel;
      removeListeners(previousMediaModel, this);
      this._mediaModel = mediaModel;
      mediaModel.on('all', function (type, objectOrEvent, value, previousValue) {
        if (objectOrEvent === mediaModel) {
          objectOrEvent = _this2;
        }

        _this2.trigger(type, objectOrEvent, value, previousValue);
      }, this);

      if (previousMediaModel) {
        dispatchDiffChangeEvents(this, mediaModel.attributes, previousMediaModel.attributes);
      }
    }
  }]);

  return PlayerViewModel;
}(model_simplemodel__WEBPACK_IMPORTED_MODULE_1__["default"]);

var ViewModel = /*#__PURE__*/function (_PlayerViewModel) {
  _inheritsLoose(ViewModel, _PlayerViewModel);

  function ViewModel(playerModel) {
    var _this3;

    _this3 = _PlayerViewModel.call(this, playerModel, function (type) {
      // Do not propagate attribute changes from the player model for attributes present in instream
      var instreamModel = _this3._instreamModel;

      if (instreamModel) {
        var match = changeEventRegEx.exec(type);

        if (match) {
          var attr = match[1];

          if (attr in instreamModel.attributes) {
            return false;
          }
        }
      }

      return true;
    }) || this;
    _this3._instreamModel = null;
    _this3._playerViewModel = new PlayerViewModel(_this3._model);
    playerModel.on('change:instream', function (model, instream) {
      _this3.instreamModel = instream ? instream.model : null;
    }, _assertThisInitialized(_assertThisInitialized(_this3)));
    return _this3;
  }

  var _proto2 = ViewModel.prototype;

  _proto2.get = function get(attr) {
    var mediaModel = this._mediaModel;

    if (mediaModel && attr in mediaModel.attributes) {
      return mediaModel.get(attr);
    }

    var instreamModel = this._instreamModel;

    if (instreamModel && attr in instreamModel.attributes) {
      return instreamModel.get(attr);
    }

    return this._model.get(attr);
  };

  _proto2.getVideo = function getVideo() {
    var instreamModel = this._instreamModel;

    if (instreamModel && instreamModel.getVideo()) {
      return instreamModel.getVideo();
    }

    return _PlayerViewModel.prototype.getVideo.call(this);
  };

  _proto2.destroy = function destroy() {
    _PlayerViewModel.prototype.destroy.call(this);

    removeListeners(this._instreamModel, this);
  };

  _createClass(ViewModel, [{
    key: "player",
    get: function get() {
      return this._playerViewModel;
    }
  }, {
    key: "instreamModel",
    set: function set(instreamModel) {
      var _this4 = this;

      var previousInstream = this._instreamModel;
      removeListeners(previousInstream, this);

      this._model.off('change:mediaModel', null, this);

      this._instreamModel = instreamModel;
      this.trigger('instreamMode', !!instreamModel);

      if (instreamModel) {
        instreamModel.on('all', function (type, objectOrEvent, value, previousValue) {
          if (objectOrEvent === instreamModel) {
            objectOrEvent = _this4;
          }

          _this4.trigger(type, objectOrEvent, value, previousValue);
        }, this);
        instreamModel.change('mediaModel', function (model, mediaModel) {
          _this4.mediaModel = mediaModel;
        }, this);
        dispatchDiffChangeEvents(this, instreamModel.attributes, this._model.attributes);
      } else if (previousInstream) {
        this._model.change('mediaModel', function (model, mediaModel) {
          _this4.mediaModel = mediaModel;
        }, this);

        var mergedAttributes = Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["extend"])({}, this._model.attributes, previousInstream.attributes);

        dispatchDiffChangeEvents(this, this._model.attributes, mergedAttributes);
      }
    }
  }]);

  return ViewModel;
}(PlayerViewModel);



/***/ }),

/***/ "./src/js/view/view.js":
/*!*****************************!*\
  !*** ./src/js/view/view.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var utils_underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils/underscore */ "./src/js/utils/underscore.js");
/* harmony import */ var templates_player__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! templates/player */ "./src/js/templates/player.ts");
/* harmony import */ var view_error_container__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! view/error-container */ "./src/js/view/error-container.ts");
/* harmony import */ var view_utils_audio_mode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! view/utils/audio-mode */ "./src/js/view/utils/audio-mode.ts");
/* harmony import */ var view_utils_views_manager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! view/utils/views-manager */ "./src/js/view/utils/views-manager.js");
/* harmony import */ var view_utils_visibility__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! view/utils/visibility */ "./src/js/view/utils/visibility.js");
/* harmony import */ var utils_active_tab__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! utils/active-tab */ "./src/js/utils/active-tab.ts");
/* harmony import */ var utils_request_animation_frame__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! utils/request-animation-frame */ "./src/js/utils/request-animation-frame.ts");
/* harmony import */ var view_utils_breakpoint__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! view/utils/breakpoint */ "./src/js/view/utils/breakpoint.ts");
/* harmony import */ var view_utils_skin__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! view/utils/skin */ "./src/js/view/utils/skin.js");
/* harmony import */ var environment_environment__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! environment/environment */ "./src/js/environment/environment.ts");
/* harmony import */ var controller_controls_loader__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! controller/controls-loader */ "./src/js/controller/controls-loader.js");
/* harmony import */ var events_events__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! events/events */ "./src/js/events/events.ts");
/* harmony import */ var utils_backbone_events__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! utils/backbone.events */ "./src/js/utils/backbone.events.ts");
/* harmony import */ var utils_dom__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! utils/dom */ "./src/js/utils/dom.js");
/* harmony import */ var utils_browser__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! utils/browser */ "./src/js/utils/browser.ts");
/* harmony import */ var utils_css__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! utils/css */ "./src/js/utils/css.js");
/* harmony import */ var view_utils_request_fullscreen_helper__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! view/utils/request-fullscreen-helper */ "./src/js/view/utils/request-fullscreen-helper.js");
/* harmony import */ var utils_ui__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! utils/ui */ "./src/js/utils/ui.js");
/* harmony import */ var view_utils_clickhandler__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! view/utils/clickhandler */ "./src/js/view/utils/clickhandler.ts");
/* harmony import */ var view_captionsrenderer__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! view/captionsrenderer */ "./src/js/view/captionsrenderer.js");
/* harmony import */ var view_logo__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! view/logo */ "./src/js/view/logo.js");
/* harmony import */ var view_preview__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! view/preview */ "./src/js/view/preview.ts");
/* harmony import */ var view_title__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! view/title */ "./src/js/view/title.ts");
/* harmony import */ var view_floating_floating_controller__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! view/floating/floating-controller */ "./src/js/view/floating/floating-controller.ts");
/* harmony import */ var view_utils_resize_listener__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! view/utils/resize-listener */ "./src/js/view/utils/resize-listener.js");
/* harmony import */ var view_utils_player_size__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! view/utils/player-size */ "./src/js/view/utils/player-size.ts");





























if (true) {
  __webpack_require__(/*! css/jwplayer.less */ "./src/css/jwplayer.less");
}

var ControlsModule;
var _isMobile = environment_environment__WEBPACK_IMPORTED_MODULE_10__["OS"].mobile;
var _isIE = environment_environment__WEBPACK_IMPORTED_MODULE_10__["Browser"].ie;

function View(_api, _model) {
  var _this3 = this;

  var _this = Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["extend"])(this, utils_backbone_events__WEBPACK_IMPORTED_MODULE_13__["default"], {
    isSetup: false,
    api: _api,
    model: _model
  });

  var _localization = _model.get('localization');

  var _playerElement = Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["createElement"])(Object(templates_player__WEBPACK_IMPORTED_MODULE_1__["default"])(_model.get('id'), _localization.player));

  var _wrapperElement = _playerElement.querySelector('.jw-wrapper');

  var _videoLayer = _playerElement.querySelector('.jw-media');

  var _preview = new view_preview__WEBPACK_IMPORTED_MODULE_22__["default"](_model, _api);

  var _title = new view_title__WEBPACK_IMPORTED_MODULE_23__["default"](_model);

  var _captionsRenderer = new view_captionsrenderer__WEBPACK_IMPORTED_MODULE_20__["default"](_model);

  _captionsRenderer.on('all', _this.trigger, _this);

  var _logo;

  var _lastWidth;

  var _lastHeight;

  var _currentlyFloating;

  var _resizeMediaTimeout = -1;

  var _resizeContainerRequestId = -1;

  var _stateClassRequestId = -1;

  var firstFloatCfg = _model.get('floating');

  this.dismissible = firstFloatCfg && firstFloatCfg.dismissible;
  var playerBounds = {};
  var floatingController = new view_floating_floating_controller__WEBPACK_IMPORTED_MODULE_24__["default"](_model, playerBounds, {
    player: _playerElement,
    wrapper: _wrapperElement,
    preview: _preview
  });
  var displayClickHandler;
  var fullscreenHelpers;
  var focusHelper;
  var _breakpoint = null;
  var _controls = null;

  function reasonInteraction() {
    return {
      reason: 'interaction'
    };
  } // Compute player size, handle DOM removal/insertion, add to views-manager


  this.updateBounds = function () {
    Object(utils_request_animation_frame__WEBPACK_IMPORTED_MODULE_7__["cancelAnimationFrame"])(_resizeContainerRequestId);

    var currentElement = _getCurrentElement();

    var inDOM = document.body.contains(currentElement);
    var rect = Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["bounds"])(currentElement);
    var containerWidth = Math.round(rect.width);
    var containerHeight = Math.round(rect.height);
    playerBounds = Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["bounds"])(_playerElement);
    floatingController.updatePlayerBounds(playerBounds); // If the container is the same size as before, return early

    if (containerWidth === _lastWidth && containerHeight === _lastHeight) {
      // Listen for player to be added to DOM
      if (!_lastWidth || !_lastHeight) {
        _responsiveListener();
      }

      _model.set('inDom', inDOM);

      return;
    } // If we have bad values for either dimension, return early


    if (!containerWidth || !containerHeight) {
      // If we haven't established player size, try again
      if (!_lastWidth || !_lastHeight) {
        _responsiveListener();
      }
    } // Don't update container dimensions to 0, 0 when not in DOM


    if (containerWidth || containerHeight || inDOM) {
      _model.set('containerWidth', containerWidth);

      _model.set('containerHeight', containerHeight);
    }

    _model.set('inDom', inDOM);

    if (inDOM) {
      view_utils_views_manager__WEBPACK_IMPORTED_MODULE_4__["default"].observe(_playerElement);
    }
  }; // Apply styles and classes based on player size


  this.updateStyles = function () {
    var containerWidth = _model.get('containerWidth');

    var containerHeight = _model.get('containerHeight');

    updateContainerStyles(containerWidth, containerHeight);

    if (_controls) {
      _controls.resize(containerWidth, containerHeight);
    }

    _resizeMedia(containerWidth, containerHeight);

    _captionsRenderer.resize();

    floatingController.updateStyles();
  }; // Dispatch UI events for changes in player size


  this.checkResized = function () {
    var containerWidth = _model.get('containerWidth');

    var containerHeight = _model.get('containerHeight');

    var floating = _model.get('isFloating');

    if (containerWidth !== _lastWidth || containerHeight !== _lastHeight) {
      if (!this.resizeListener) {
        this.resizeListener = new view_utils_resize_listener__WEBPACK_IMPORTED_MODULE_25__["default"](_wrapperElement, this, _model);
      }

      _lastWidth = containerWidth;
      _lastHeight = containerHeight;

      _this.trigger(events_events__WEBPACK_IMPORTED_MODULE_12__["RESIZE"], {
        width: containerWidth,
        height: containerHeight
      });

      var breakpoint = Object(view_utils_breakpoint__WEBPACK_IMPORTED_MODULE_8__["getBreakpoint"])(containerWidth);

      if (_breakpoint !== breakpoint) {
        _breakpoint = breakpoint;

        _this.trigger(events_events__WEBPACK_IMPORTED_MODULE_12__["BREAKPOINT"], {
          breakpoint: _breakpoint
        });
      }
    }

    if (floating !== _currentlyFloating) {
      _currentlyFloating = floating;

      _this.trigger(events_events__WEBPACK_IMPORTED_MODULE_12__["FLOAT"], {
        floating: floating
      });

      updateVisibility();
    }
  };

  function _responsiveListener() {
    Object(utils_request_animation_frame__WEBPACK_IMPORTED_MODULE_7__["cancelAnimationFrame"])(_resizeContainerRequestId);
    _resizeContainerRequestId = Object(utils_request_animation_frame__WEBPACK_IMPORTED_MODULE_7__["requestAnimationFrame"])(_responsiveUpdate);
  }

  this.responsiveListener = _responsiveListener;

  function _responsiveUpdate() {
    if (!_this.isSetup) {
      return;
    }

    _this.updateBounds();

    _this.updateStyles();

    _this.checkResized();
  }

  function updateContainerStyles(width, height) {
    // Set responsive player classes
    if (Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(width) && Object(utils_underscore__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(height)) {
      var breakpoint = Object(view_utils_breakpoint__WEBPACK_IMPORTED_MODULE_8__["getBreakpoint"])(width);
      Object(view_utils_breakpoint__WEBPACK_IMPORTED_MODULE_8__["setBreakpoint"])(_playerElement, breakpoint);
      var smallPlayer = breakpoint < 2;
      Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["toggleClass"])(_playerElement, 'jw-flag-small-player', smallPlayer);
      Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["toggleClass"])(_playerElement, 'jw-orientation-portrait', height > width);
    } // Only change audio player mode when controls are enabled


    if (_model.get('controls')) {
      var audioMode = Object(view_utils_audio_mode__WEBPACK_IMPORTED_MODULE_3__["isAudioMode"])(_model);
      Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["toggleClass"])(_playerElement, 'jw-flag-audio-player', audioMode);

      _model.set('audioMode', audioMode);
    }
  }

  this.setup = function () {
    _preview.setup(_playerElement.querySelector('.jw-preview'));

    _title.setup(_playerElement.querySelector('.jw-title'));

    _logo = new view_logo__WEBPACK_IMPORTED_MODULE_21__["default"](_model);

    _logo.setup();

    _logo.setContainer(_wrapperElement);

    _logo.on(events_events__WEBPACK_IMPORTED_MODULE_12__["LOGO_CLICK"], _logoClickHandler); // captions rendering


    _captionsRenderer.setup(_playerElement.id, _model.get('captions')); // captions should be placed behind controls, and not hidden when controls are hidden


    _title.element().parentNode.insertBefore(_captionsRenderer.element(), _title.element()); // Display Click and Double Click Handling


    displayClickHandler = clickHandlerHelper(_api, _model, _videoLayer);
    focusHelper = new utils_ui__WEBPACK_IMPORTED_MODULE_18__["default"](_playerElement).on('click', function () {});
    fullscreenHelpers = Object(view_utils_request_fullscreen_helper__WEBPACK_IMPORTED_MODULE_17__["default"])(_playerElement, document, _fullscreenChangeHandler, _model);

    _model.on('change:hideAdsControls', function (model, val) {
      Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["toggleClass"])(_playerElement, 'jw-flag-ads-hide-controls', val);
    });

    _model.on('change:scrubbing', function (model, val) {
      Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["toggleClass"])(_playerElement, 'jw-flag-dragging', val);
    });

    _model.on('change:playRejected', function (model, val) {
      Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["toggleClass"])(_playerElement, 'jw-flag-play-rejected', val);
    }); // Native fullscreen (coming through from the provider)


    _model.on(events_events__WEBPACK_IMPORTED_MODULE_12__["NATIVE_FULLSCREEN"], _nativeFullscreenChangeHandler);

    _model.on("change:" + events_events__WEBPACK_IMPORTED_MODULE_12__["MEDIA_VISUAL_QUALITY"], function () {
      _resizeMedia();

      _captionsRenderer.resize();
    });

    var playerViewModel = _model.player;
    playerViewModel.on('change:errorEvent', _errorHandler);

    _model.change('stretching', onStretchChange);

    var width = _model.get('width');

    var height = _model.get('height');

    var styles = Object(view_utils_player_size__WEBPACK_IMPORTED_MODULE_26__["getPlayerSizeStyles"])(_model, width, height);
    Object(utils_css__WEBPACK_IMPORTED_MODULE_16__["style"])(_playerElement, styles);

    _model.change('aspectratio', onAspectRatioChange);

    updateContainerStyles(width, height);

    if (!_model.get('controls')) {
      Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["addClass"])(_playerElement, 'jw-flag-controls-hidden');
      Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["removeClass"])(_playerElement, 'jw-floating-dismissible');
    }

    if (_isIE) {
      Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["addClass"])(_playerElement, 'jw-ie');
    }

    var skin = _model.get('skin') || {};

    if (skin.name) {
      Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["replaceClass"])(_playerElement, /jw-skin-\S+/, 'jw-skin-' + skin.name);
    }

    var skinColors = Object(view_utils_skin__WEBPACK_IMPORTED_MODULE_9__["normalizeSkin"])(skin);
    Object(view_utils_skin__WEBPACK_IMPORTED_MODULE_9__["handleColorOverrides"])(_model.get('id'), skinColors); // adds video tag to video layer

    _model.set('mediaContainer', _videoLayer);

    _model.set('iFrame', environment_environment__WEBPACK_IMPORTED_MODULE_10__["Features"].iframe);

    _model.set('activeTab', Object(utils_active_tab__WEBPACK_IMPORTED_MODULE_6__["default"])());

    _model.set('touchMode', _isMobile && (typeof height === 'string' || height >= view_utils_audio_mode__WEBPACK_IMPORTED_MODULE_3__["CONTROLBAR_ONLY_HEIGHT"]));

    view_utils_views_manager__WEBPACK_IMPORTED_MODULE_4__["default"].add(this);

    if (_model.get('enableGradient') && !_isIE) {
      Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["addClass"])(_playerElement, 'jw-ab-drop-shadow');
    }

    this.isSetup = true;

    _model.trigger('viewSetup', _playerElement);

    var inDOM = document.body.contains(_playerElement);

    if (inDOM) {
      view_utils_views_manager__WEBPACK_IMPORTED_MODULE_4__["default"].observe(_playerElement);
    }

    _model.set('inDom', inDOM); // Floating event triggers


    _model.on('forceAspectRatioChange', function (evtArgs) {
      var ar = evtArgs.ratio || _model.get('aspectratio');

      onAspectRatioChange(_model, ar);
    });

    _model.on('forceResponsiveListener', _responsiveListener);

    floatingController.setup();
  };

  function updateVisibility() {
    _model.set('visibility', Object(view_utils_visibility__WEBPACK_IMPORTED_MODULE_5__["default"])(_model, _playerElement));
  }

  this.init = function () {
    this.updateBounds();

    _model.on('change:fullscreen', _fullscreen);

    _model.on('change:activeTab', updateVisibility);

    _model.on('change:fullscreen', updateVisibility);

    _model.on('change:intersectionRatio', updateVisibility);

    _model.on('change:visibility', redraw);

    _model.on('instreamMode', function (instreamMode) {
      if (instreamMode) {
        setupInstream();
      } else {
        destroyInstream();
      }
    });

    updateVisibility(); // Always draw first player for icons to load

    if (view_utils_views_manager__WEBPACK_IMPORTED_MODULE_4__["default"].size() === 1 && !_model.get('visibility')) {
      redraw(_model, 1, 0);
    }

    var playerViewModel = _model.player;

    _model.change('state', _stateHandler);

    playerViewModel.change('controls', changeControls);

    _model.change('streamType', _setLiveMode);

    _model.change('mediaType', _onMediaTypeChange);

    playerViewModel.change('playlistItem', function (model, item) {
      onPlaylistItem(model, item);
    }); // Triggering 'resize' resulting in player 'ready'

    _lastWidth = _lastHeight = null;
    this.initFloatingBehavior();
    this.checkResized();
  };

  function changeControls(model, enable) {
    var controlsEvent = {
      controls: enable
    };

    if (enable) {
      ControlsModule = controller_controls_loader__WEBPACK_IMPORTED_MODULE_11__["ControlsLoader"].controls;

      if (!ControlsModule) {
        controlsEvent.loadPromise = Object(controller_controls_loader__WEBPACK_IMPORTED_MODULE_11__["loadControls"])().then(function (Controls) {
          ControlsModule = Controls; // Check that controls is still true after the loader promise resolves

          var enabledState = model.get('controls');

          if (enabledState) {
            addControls();
          }

          return enabledState;
        });
        controlsEvent.loadPromise.catch(function (error) {
          _this.trigger(events_events__WEBPACK_IMPORTED_MODULE_12__["WARNING"], error);
        });
      } else {
        addControls();
      }
    } else {
      _this.removeControls();
    } // Only trigger controls events after the player and view are set up (and has width/height)


    if (_lastWidth && _lastHeight) {
      _this.trigger(events_events__WEBPACK_IMPORTED_MODULE_12__["CONTROLS"], controlsEvent);
    }
  }

  function addControls() {
    var controls = new ControlsModule(document, _this.element());

    _this.addControls(controls);
  }

  function redraw(model, visibility, lastVisibility) {
    if (visibility && !lastVisibility) {
      _stateHandler(model, model.get('state'));

      _this.updateStyles();
    }
  }

  function clickHandlerHelper(api, model, videoLayer) {
    var clickHandler = new view_utils_clickhandler__WEBPACK_IMPORTED_MODULE_19__["default"](model, videoLayer);
    var controls = model.get('controls');
    clickHandler.on({
      click: function click() {
        _this.trigger(events_events__WEBPACK_IMPORTED_MODULE_12__["DISPLAY_CLICK"]); // Ensures that Firefox focuses the container not the video tag for aria compatibility


        _getCurrentElement().focus();

        if (_controls) {
          if (settingsMenuVisible()) {
            _controls.settingsMenu.close();
          } else if (infoOverlayVisible()) {
            _controls.infoOverlay.close();
          } else {
            api.playToggle(reasonInteraction());
          }
        }
      },
      tap: function tap() {
        _this.trigger(events_events__WEBPACK_IMPORTED_MODULE_12__["DISPLAY_CLICK"]);

        if (settingsMenuVisible()) {
          _controls.settingsMenu.close();
        }

        if (infoOverlayVisible()) {
          _controls.infoOverlay.close();
        }

        var state = model.get('state');

        if (controls && (state === events_events__WEBPACK_IMPORTED_MODULE_12__["STATE_IDLE"] || state === events_events__WEBPACK_IMPORTED_MODULE_12__["STATE_COMPLETE"] || model.get('instream') && state === events_events__WEBPACK_IMPORTED_MODULE_12__["STATE_PAUSED"])) {
          api.playToggle(reasonInteraction());
        }

        if (controls && state === events_events__WEBPACK_IMPORTED_MODULE_12__["STATE_PAUSED"]) {
          // Toggle visibility of the controls when tapping the media
          // Do not add mobile toggle "jw-flag-controls-hidden" in these cases
          if (model.get('instream') || model.get('castActive') || model.get('mediaType') === 'audio') {
            return;
          }

          Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["toggleClass"])(_playerElement, 'jw-flag-controls-hidden');

          if (_this.dismissible) {
            Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["toggleClass"])(_playerElement, 'jw-floating-dismissible', Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["hasClass"])(_playerElement, 'jw-flag-controls-hidden'));
          }

          _captionsRenderer.renderCues(true);
        } else if (_controls) {
          if (!_controls.showing) {
            _controls.userActive();
          } else {
            _controls.userInactive();
          }
        }
      },
      doubleClick: function doubleClick() {
        return _controls && api.setFullscreen();
      }
    });

    if (!_isMobile) {
      _playerElement.addEventListener('mousemove', moveHandler);

      _playerElement.addEventListener('mouseover', overHandler);

      _playerElement.addEventListener('mouseout', outHandler);
    }

    return clickHandler;
  }

  function moveHandler(event) {
    if (_controls) {
      _controls.mouseMove(event);
    }
  }

  function overHandler(event) {
    if (_controls && !_controls.showing && event.target.nodeName === 'IFRAME') {
      _controls.userActive();
    }
  }

  function outHandler(event) {
    // If controls are showing and mouse moves out to relatedTarget not within playerElement, call userActive().
    // Also call userActive() if event does not contain relatedTarget if player is in iFrame. (relatedTarget = null)
    if (_controls && _controls.showing && (event.relatedTarget && !_playerElement.contains(event.relatedTarget) || !event.relatedTarget && environment_environment__WEBPACK_IMPORTED_MODULE_10__["Features"].iframe)) {
      _controls.userActive();
    }
  }

  function onStretchChange(model, newVal) {
    Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["replaceClass"])(_playerElement, /jw-stretch-\S+/, 'jw-stretch-' + newVal);
  }

  function onAspectRatioChange(model, aspectratio) {
    Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["toggleClass"])(_playerElement, 'jw-flag-aspect-mode', !!aspectratio);

    var aspectRatioContainer = _playerElement.querySelectorAll('.jw-aspect');

    Object(utils_css__WEBPACK_IMPORTED_MODULE_16__["style"])(aspectRatioContainer, {
      paddingTop: aspectratio || null
    });

    if (_this.isSetup && aspectratio && !model.get('isFloating')) {
      Object(utils_css__WEBPACK_IMPORTED_MODULE_16__["style"])(_playerElement, Object(view_utils_player_size__WEBPACK_IMPORTED_MODULE_26__["getPlayerSizeStyles"])(model, model.get('width')));

      _responsiveUpdate();
    }
  }

  function _logoClickHandler(evt) {
    if (!evt.link) {
      if (_model.get('controls')) {
        _api.playToggle(reasonInteraction());
      }
    } else {
      _api.pause(reasonInteraction());

      _api.setFullscreen(false);

      Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["openLink"])(evt.link, evt.linktarget, {
        rel: 'noreferrer'
      });
    }
  }

  this.initFloatingBehavior = function () {
    floatingController.initFloatingBehavior();
  };

  this.addControls = function (controls) {
    var _this2 = this;

    _controls = controls;
    Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["removeClass"])(_playerElement, 'jw-flag-controls-hidden');
    Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["toggleClass"])(_playerElement, 'jw-floating-dismissible', this.dismissible);
    controls.enable(_api, _model); // refresh breakpoint and timeslider classes

    if (_lastHeight) {
      updateContainerStyles(_lastWidth, _lastHeight);
      controls.resize(_lastWidth, _lastHeight);

      _captionsRenderer.renderCues(true);
    }

    controls.on('userActive userInactive', function () {
      var state = _model.get('state');

      if (state === events_events__WEBPACK_IMPORTED_MODULE_12__["STATE_PLAYING"] || state === events_events__WEBPACK_IMPORTED_MODULE_12__["STATE_BUFFERING"]) {
        _captionsRenderer.renderCues(true);
      }
    });
    controls.on('dismissFloating', function () {
      _this2.stopFloating(true);

      _api.pause({
        reason: 'interaction'
      });
    });
    controls.on('all', _this.trigger, _this);

    if (_model.get('instream')) {
      _controls.setupInstream();
    }
  };

  this.removeControls = function () {
    if (_controls) {
      _controls.disable(_model);

      _controls = null;
    }

    Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["addClass"])(_playerElement, 'jw-flag-controls-hidden');
    Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["removeClass"])(_playerElement, 'jw-floating-dismissible');
  }; // Perform the switch to fullscreen


  var _fullscreen = function _fullscreen(model, state) {
    // Unmute the video so volume can be adjusted with native controls in fullscreen
    if (state && _controls && model.get('autostartMuted')) {
      _controls.unmuteAutoplay(_api, model);
    }

    if (fullscreenHelpers.supportsDomFullscreen()) {
      if (state) {
        fullscreenHelpers.requestFullscreen();
      } else {
        fullscreenHelpers.exitFullscreen();
      }

      _toggleDOMFullscreen(_playerElement, state);
    } else if (_isIE) {
      _toggleDOMFullscreen(_playerElement, state);
    } else {
      // Request media element fullscreen (iOS)
      var instream = model.get('instream');
      var instreamProvider = instream ? instream.provider : null;
      var provider = model.getVideo() || instreamProvider;

      if (provider && provider.setFullscreen) {
        provider.setFullscreen(state);
      }
    }
  };

  function _resizeMedia(containerWidth, containerHeight) {
    if (!containerWidth || isNaN(1 * containerWidth)) {
      containerWidth = _model.get('containerWidth');

      if (!containerWidth) {
        return;
      }
    }

    if (!containerHeight || isNaN(1 * containerHeight)) {
      containerHeight = _model.get('containerHeight');

      if (!containerHeight) {
        return;
      }
    }

    if (_preview) {
      _preview.resize(containerWidth, containerHeight, _model.get('stretching'));
    }

    var provider = _model.getVideo();

    if (!provider) {
      return;
    }

    provider.resize(containerWidth, containerHeight, _model.get('stretching'));
  }

  this.resize = function (playerWidth, playerHeight) {
    var styles = Object(view_utils_player_size__WEBPACK_IMPORTED_MODULE_26__["getPlayerSizeStyles"])(_model, playerWidth, playerHeight, true);
    var widthSet = playerWidth !== undefined;
    var heightSet = playerHeight !== undefined;

    if (widthSet && heightSet) {
      _model.set('width', playerWidth);

      _model.set('height', playerHeight);
    }

    Object(utils_css__WEBPACK_IMPORTED_MODULE_16__["style"])(_playerElement, styles);
    floatingController.resize();

    _responsiveUpdate();
  };

  this.resizeMedia = _resizeMedia;

  function _isNativeFullscreen() {
    // Return whether or not we're in native fullscreen
    if (fullscreenHelpers.supportsDomFullscreen()) {
      var fsElement = fullscreenHelpers.fullscreenElement();
      return !!(fsElement && fsElement === _playerElement);
    } // If native fullscreen is not available, return video fullscreen state


    var provider = _model.getVideo();

    return provider.getFullScreen();
  }

  function _nativeFullscreenChangeHandler(event) {
    Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["toggleClass"])(_playerElement, 'jw-flag-ios-fullscreen', event.jwstate);

    _fullscreenChangeHandler(event);
  }

  function _fullscreenChangeHandler(event) {
    var modelState = _model.get('fullscreen');

    var newState = event.jwstate !== undefined ? event.jwstate : _isNativeFullscreen(); // If fullscreen was triggered by something other than the player
    //  then we want to sync up our internal state

    if (modelState !== newState) {
      _model.set('fullscreen', newState);
    }

    _responsiveListener();

    clearTimeout(_resizeMediaTimeout);
    _resizeMediaTimeout = setTimeout(_resizeMedia, 200);
  }

  function _toggleDOMFullscreen(playerElement, fullscreenState) {
    Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["toggleClass"])(playerElement, 'jw-flag-fullscreen', fullscreenState);
    Object(utils_css__WEBPACK_IMPORTED_MODULE_16__["style"])(document.body, {
      overflowY: fullscreenState ? 'hidden' : ''
    });

    if (fullscreenState && _controls) {
      // When going into fullscreen, we want the control bar to fade after a few seconds
      _controls.userActive();
    }

    _resizeMedia();

    _responsiveListener();
  }

  function _setLiveMode(model, streamType) {
    var live = streamType === 'LIVE';
    Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["toggleClass"])(_playerElement, 'jw-flag-live', live);
  }

  function _onMediaTypeChange(model, val) {
    var isAudioFile = val === 'audio';
    Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["toggleClass"])(_playerElement, 'jw-flag-media-audio', isAudioFile);
    var element = isAudioFile ? _videoLayer : _videoLayer.nextSibling; // Put the preview element before the media element in order to display browser captions
    // otherwise keep it on top of the media element to display captions with the captions renderer

    _preview.el.parentNode.insertBefore(_preview.el, element);
  }

  function _errorHandler(model, errorEvent) {
    if (!errorEvent) {
      _title.playlistItem(model, model.get('playlistItem'));

      return;
    }

    var errorContainer = Object(view_error_container__WEBPACK_IMPORTED_MODULE_2__["default"])(model, errorEvent);

    if (view_error_container__WEBPACK_IMPORTED_MODULE_2__["default"].cloneIcon) {
      errorContainer.querySelector('.jw-icon').appendChild(view_error_container__WEBPACK_IMPORTED_MODULE_2__["default"].cloneIcon('error'));
    }

    _title.hide();

    _playerElement.appendChild(errorContainer.firstChild);

    Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["toggleClass"])(_playerElement, 'jw-flag-audio-player', !!model.get('audioMode'));
  }

  function _stateHandler(model, newState, oldState) {
    if (!_this.isSetup) {
      return;
    }

    if (oldState === events_events__WEBPACK_IMPORTED_MODULE_12__["STATE_ERROR"]) {
      var errorContainer = _playerElement.querySelector('.jw-error-msg');

      if (errorContainer) {
        errorContainer.parentNode.removeChild(errorContainer);
      }
    }

    Object(utils_request_animation_frame__WEBPACK_IMPORTED_MODULE_7__["cancelAnimationFrame"])(_stateClassRequestId);

    if (newState === events_events__WEBPACK_IMPORTED_MODULE_12__["STATE_PLAYING"]) {
      _stateUpdate(newState);
    } else {
      _stateClassRequestId = Object(utils_request_animation_frame__WEBPACK_IMPORTED_MODULE_7__["requestAnimationFrame"])(function () {
        return _stateUpdate(newState);
      });
    }
  }

  function _stateUpdate(state) {
    if (_model.get('controls') && state !== events_events__WEBPACK_IMPORTED_MODULE_12__["STATE_PAUSED"] && Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["hasClass"])(_playerElement, 'jw-flag-controls-hidden')) {
      Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["removeClass"])(_playerElement, 'jw-flag-controls-hidden');
      Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["toggleClass"])(_playerElement, 'jw-floating-dismissible', _this.dismissible);
    }

    Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["replaceClass"])(_playerElement, /jw-state-\S+/, 'jw-state-' + state);

    switch (state) {
      case events_events__WEBPACK_IMPORTED_MODULE_12__["STATE_ERROR"]:
        _this.stopFloating();

      /* falls through to update captions renderer */

      case events_events__WEBPACK_IMPORTED_MODULE_12__["STATE_IDLE"]:
      case events_events__WEBPACK_IMPORTED_MODULE_12__["STATE_COMPLETE"]:
        if (_captionsRenderer) {
          _captionsRenderer.hide();
        }

        if (_preview) {
          _preview.enableZoomThumbnail();
        }

        break;

      default:
        if (_captionsRenderer) {
          _captionsRenderer.show();

          if (state === events_events__WEBPACK_IMPORTED_MODULE_12__["STATE_PAUSED"] && _controls && !_controls.showing) {
            _captionsRenderer.renderCues(true);
          }
        }

        if (_preview) {
          _preview.removeZoomThumbnail();
        }

        break;
    }
  }

  function setMediaTitleAttribute(model, playlistItem) {
    var videotag = model.get('mediaElement'); // chromecast provider does not support video tags

    if (!videotag) {
      return;
    } // Writing a string to innerHTML completely decodes multiple-encoded strings


    var body = Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["htmlToParentElement"])(playlistItem.title || '');
    videotag.setAttribute('title', body.textContent);
  }

  this.setPosterImage = function (item, preview) {
    preview.setImage(item && item.image);
  };

  var onPlaylistItem = function onPlaylistItem(model, item) {
    _this3.setPosterImage(item, _preview); // Set the title attribute of the video tag to display background media information on mobile devices


    if (_isMobile) {
      setMediaTitleAttribute(model, item);
    }
  };

  var settingsMenuVisible = function settingsMenuVisible() {
    var settingsMenu = _controls && _controls.settingsMenu;
    return !!(settingsMenu && settingsMenu.visible);
  };

  var infoOverlayVisible = function infoOverlayVisible() {
    var info = _controls && _controls.infoOverlay;
    return !!(info && info.visible);
  };

  var setupInstream = function setupInstream() {
    Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["addClass"])(_playerElement, 'jw-flag-ads');

    if (_controls) {
      _controls.setupInstream();
    }

    floatingController.disableFloatingUI();
  };

  var destroyInstream = function destroyInstream() {
    if (!displayClickHandler) {
      // view was destroyed
      return;
    }

    if (_controls) {
      _controls.destroyInstream(_model);
    }

    if (floatingController.getFloatingPlayer() === _playerElement && !Object(utils_browser__WEBPACK_IMPORTED_MODULE_15__["isIframe"])()) {
      floatingController.enableFloatingUI();
    }

    _this.setAltText('');

    Object(utils_dom__WEBPACK_IMPORTED_MODULE_14__["removeClass"])(_playerElement, ['jw-flag-ads', 'jw-flag-ads-hide-controls']);

    _model.set('hideAdsControls', false); // Make sure that the provider's media element is returned to the DOM after instream mode


    var provider = _model.getVideo();

    if (provider) {
      provider.setContainer(_videoLayer);
    } // reset display click handler


    displayClickHandler.revertAlternateClickHandlers();
  };

  this.setAltText = function (text) {
    _model.set('altText', text);
  };

  this.clickHandler = function () {
    return displayClickHandler;
  };

  this.getContainer = this.element = function () {
    return _playerElement;
  };

  this.getWrapper = function () {
    return _wrapperElement;
  };

  this.controlsContainer = function () {
    if (_controls) {
      return _controls.element();
    }

    return null;
  };

  this.getSafeRegion = function (excludeControlbar) {
    if (excludeControlbar === void 0) {
      excludeControlbar = true;
    }

    var safeRegion = {
      x: 0,
      y: 0,
      width: _lastWidth || 0,
      height: _lastHeight || 0
    };

    if (_controls) {
      // Subtract controlbar from the bottom when using one
      if (excludeControlbar) {
        safeRegion.height -= _controls.controlbarHeight();
      }
    }

    return safeRegion;
  };

  this.setCaptions = function (captionsStyle) {
    _captionsRenderer.clear();

    _captionsRenderer.setup(_model.get('id'), captionsStyle);

    _captionsRenderer.resize();
  };

  this.setIntersection = function (entry) {
    // Round as the IntersectionObserver polyfill sometimes returns ±0.00XXX.
    var intersectionRatio = Math.round(entry.intersectionRatio * 100) / 100;

    _model.set('intersectionRatio', intersectionRatio);

    this.checkFloatIntersection(intersectionRatio);
  };

  this.checkFloatIntersection = function (intersectionRatio) {
    floatingController.checkFloatIntersection(intersectionRatio);
  };

  function _getCurrentElement() {
    return _model.get('isFloating') ? _wrapperElement : _playerElement;
  }

  this.stopFloating = function (forever, mobileFloatIntoPlace) {
    floatingController.stopFloating(forever, mobileFloatIntoPlace);
  };

  this.destroy = function () {
    _model.destroy();

    _preview.destroy();

    view_utils_views_manager__WEBPACK_IMPORTED_MODULE_4__["default"].unobserve(_playerElement);
    view_utils_views_manager__WEBPACK_IMPORTED_MODULE_4__["default"].remove(this);
    this.isSetup = false;
    this.off();
    Object(utils_request_animation_frame__WEBPACK_IMPORTED_MODULE_7__["cancelAnimationFrame"])(_resizeContainerRequestId);
    clearTimeout(_resizeMediaTimeout);

    if (focusHelper) {
      focusHelper.destroy();
      focusHelper = null;
    }

    if (fullscreenHelpers) {
      fullscreenHelpers.destroy();
      fullscreenHelpers = null;
    }

    if (_controls) {
      _controls.disable(_model);
    }

    if (displayClickHandler) {
      displayClickHandler.destroy();

      _playerElement.removeEventListener('mousemove', moveHandler);

      _playerElement.removeEventListener('mouseout', outHandler);

      _playerElement.removeEventListener('mouseover', overHandler);

      displayClickHandler = null;
    }

    _captionsRenderer.destroy();

    if (_logo) {
      _logo.destroy();

      _logo = null;
    }

    Object(utils_css__WEBPACK_IMPORTED_MODULE_16__["clearCss"])(_model.get('id'));

    if (this.resizeListener) {
      this.resizeListener.destroy();
      delete this.resizeListener;
    }

    floatingController.destroy();
  };
}

/* harmony default export */ __webpack_exports__["default"] = (View);

/***/ })

}]);
//# sourceMappingURL=jwplayer.core.c57b7bef86dba4bab5ae.map